###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.40338/W32 for 8051         21/Jul/2014  12:20:26 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\Source\oad_app.c         #
#    Command line       =  -f D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\P #
#                          rojects\zstack\Utilities\OAD\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wEndev.cfg (-DCPU32MHZ               #
#                          -DROOT=__near_func -DBLINK_LEDS) -f                #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\Tools\ #
#                          CC2530DB\f8wConfig.cfg (-DSECURE=0                 #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF0                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\Source\oad_app.c -D      #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_APP_FUNC -D MT_NWK_FUNC -D MT_NWK_CB_FUNC -D    #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D MT_ZDO_CB_FUNC -D    #
#                          MT_UTIL_FUNC -D LCD_SUPPORTED -D                   #
#                          RFD_RCVC_ALWAYS_ON -D ZPORT -D HOLD_AUTO_START     #
#                          -lC D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\ #
#                          Projects\zstack\Utilities\OAD\CC2530DB\DongleEB\Li #
#                          st\ -lA D:\WorkReserve\project\AES_BOOT\CC2530EncB #
#                          oot\Projects\zstack\Utilities\OAD\CC2530DB\DongleE #
#                          B\List\ -o D:\WorkReserve\project\AES_BOOT\CC2530E #
#                          ncBoot\Projects\zstack\Utilities\OAD\CC2530DB\Dong #
#                          leEB\Obj\ -e --debug --core=plain --dptr=16,1      #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\P #
#                          rojects\zstack\Utilities\OAD\CC2530DB\ -I          #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\SOURCE\ -I   #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\ZMAIN\ #
#                          TI2530DB\ -I D:\WorkReserve\project\AES_BOOT\CC253 #
#                          0EncBoot\Projects\zstack\Utilities\OAD\CC2530DB\.. #
#                          \..\..\..\..\COMPONENTS\MT\ -I                     #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\HAL\INCLUDE\ -I                         #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\HAL\TARGET\CC2530EB\ -I                 #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\OSAL\INCLUDE\ -I                        #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\STACK\AF\ -I D:\WorkReserve\project\AES #
#                          _BOOT\CC2530EncBoot\Projects\zstack\Utilities\OAD\ #
#                          CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I   #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\STACK\SEC\ -I                           #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\STACK\SAPI\ -I                          #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\STACK\SYS\ -I                           #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\STACK\ZDO\ -I                           #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\ZMAC\F8W\ -I D:\WorkReserve\project\AES #
#                          _BOOT\CC2530EncBoot\Projects\zstack\Utilities\OAD\ #
#                          CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I        #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\SERVICES\SADDR\ -I                      #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\SERVICES\SDATA\ -I                      #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\MAC\INCLUDE\ -I                         #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\MAC\HIGH_LEVEL\ -I                      #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\MAC\LOW_LEVEL\srf04\ -I                 #
#                          D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz   #
#                          --require_prototypes                               #
#    List file          =  D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\DongleEB\List\o #
#                          ad_app.lst                                         #
#    Object file        =  D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Proj #
#                          ects\zstack\Utilities\OAD\CC2530DB\DongleEB\Obj\oa #
#                          d_app.r51                                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\WorkReserve\project\AES_BOOT\CC2530EncBoot\Projects\zstack\Utilities\OAD\Source\oad_app.c
      1          /**************************************************************************************************
      2            Filename:       oad_app.c
      3            Revised:        $Date: 2009-08-21 13:10:13 -0700 (Fri, 21 Aug 2009) $
      4            Revision:       $Revision: 20630 $
      5          
      6            Description:    This file contains the implementation of an Over Air Download application.
      7          
      8          
      9            Copyright 2008-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include <string.h>
     46          
     47          #include "AF.h"
     48          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1
     49          #include "hal_flash.h"
     50          #include "hal_oad.h"
     51          #include "oad_app.h"
     52          #include "oad_preamble.h"
     53          #include "OnBoard.h"
     54          #include "OSAL_Nv.h"
     55          
     56          #if defined ZPORT
     57          #include "hal_key.h"
     58          #include "MT.h"
     59          #include "MT_APP.h"
     60          #include "MT_X.h"
     61          #include "ZDApp.h"
     62          #else
     63          #if (HAL_OAD_XNV_IS_INT && ((HAL_OAD_DL_OSET % HAL_FLASH_PAGE_SIZE) != 0))
     64          #include "hal_xnv.h"
     65          #endif
     66          #endif
     67          
     68          /* ------------------------------------------------------------------------------------------------
     69           *                                           Macros  
     70           * ------------------------------------------------------------------------------------------------
     71           */
     72          
     73          #define  DO_EVENT_CALLBACK(e) st ( if (s_pCallback && ((e) & s_eventMask))  s_pCallback((e)); )
     74          
     75          /* ------------------------------------------------------------------------------------------------
     76           *                                          Constants
     77           * ------------------------------------------------------------------------------------------------
     78           */
     79          
     80          #if !defined OAD_NV_ID
     81          // Arbitrarily pick the last Id available to the user Application.
     82          #define OAD_NV_ID  0x0FFF
     83          #endif
     84          #define PREAMBLE_NV_ID                    OAD_NV_ID
     85          
     86          // support to select callback event for which subscription is desired
     87          // this information is transmitted as a bit map.
     88          #define  ZLCB_EVENT_OADBEGIN_CLIENT     ((uint16)0x0001)
     89          #define  ZLCB_EVENT_OADEND_CLIENT       ((uint16)0x0002)
     90          #define  ZLCB_EVENT_OADBEGIN_SERVER     ((uint16)0x0004)
     91          #define  ZLCB_EVENT_OADEND_SERVER       ((uint16)0x0008)
     92          #define  ZLCB_EVENT_CODE_ENABLE_RESET   ((uint16)0x0010)
     93          #define  ZLCB_EVENT_ALL                 (ZLCB_EVENT_OADBEGIN_CLIENT   | \
     94                                                   ZLCB_EVENT_OADEND_CLIENT     | \
     95                                                   ZLCB_EVENT_OADBEGIN_SERVER   | \
     96                                                   ZLCB_EVENT_OADEND_SERVER     | \
     97                                                   ZLCB_EVENT_CODE_ENABLE_RESET   \
     98                                                  )
     99          
    100          #define  SDC_RETRY_COUNT         (10)
    101          #define  SDR_WAIT_TO             (1000)
    102          // Some reasonable time to get the code enable response out.
    103          #define  SDC_WAIT_TO_ENABLE      (10000)
    104          
    105          /* ------------------------------------------------------------------------------------------------
    106           *                                          Typedefs
    107           * ------------------------------------------------------------------------------------------------
    108           */
    109          
    110          // Used by the optional OAD en masse mode - TODO.
    111          /*
    112          typedef enum {
    113            emBeg = 0x0010,
    114            emDat,
    115            emRst,
    116            emEnd
    117          } en_masse_t;
    118          
    119          #define OAD_CLUSTERID_EM  0x0010
    120          */
    121          
    122          #if defined ZPORT
    123          #define SIZEOF_ZAIN_HDR   (sizeof(uint16) + sizeof(uint8) + sizeof(uint16) + sizeof(uint8))
    124          
    125          // Z-Architect headers
    126          // inbound to host (from dongle directly or external platform)
    127          PACK_1
    128          typedef struct  {
    129              uint16 zaproxy_nwkAddr;
    130              uint8  zaproxy_endp;
    131              uint16 zaproxy_ClusterID;
    132              uint8  zaproxy_msglen;
    133              uint8  zaproxy_payload[1];
    134          } zahdrin_t;
    135          
    136          // outbound from host (to dongle directly or external platform)
    137          PACK_1
    138          typedef struct  {
    139              uint16 zaproxy_nwkAddr;
    140              uint8  zaproxy_endp;
    141              uint16 zaproxy_ClusterID;
    142              uint8  zaproxy_msglen;
    143              uint8  zaproxy_payload[1];
    144          } zahdrout_t;
    145          #endif
    146          
    147          /* ------------------------------------------------------------------------------------------------
    148           *                                       Global Variables
    149           * ------------------------------------------------------------------------------------------------
    150           */
    151          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    152          uint8 oad_app_taskId;
   \                     oad_app_taskId:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    153          
    154          /* ------------------------------------------------------------------------------------------------
    155           *                                       Global Functions
    156           * ------------------------------------------------------------------------------------------------
    157           */
    158          
    159          #if defined ZPORT
    160          #define HalOADChkDL(V)  1
    161          #define HalOADInvRC(V)
    162          #define HalOADAvail(V)  HAL_OAD_DL_SIZE
    163          #define HalOADRead(A, B, C, D)
    164          #define HalOADWrite(A, B, C, D)
    165          #endif
    166          
    167          /* ------------------------------------------------------------------------------------------------
    168           *                                       Local Variables
    169           * ------------------------------------------------------------------------------------------------
    170           */
    171          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    172          static uint8 transId;
   \                     transId:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    173          static afAddrType_t dstAddr;
   \                     dstAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    174          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    175          static zlclientC_t *s_clientInfo;
   \                     s_clientInfo:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          static uint8 s_State, s_SessionID, s_blkSize;
   \                     s_State:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     s_SessionID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     s_blkSize:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    177          static uint16 s_NextPacket, s_NumPktGet, s_SDCRetryCount;
   \                     s_NextPacket:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     s_NumPktGet:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     s_SDCRetryCount:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    178          static zlmhdr_t    *s_sdcmd;
   \                     s_sdcmd:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          static zlsdC_t     *s_sdcpayload;
   \                     s_sdcpayload:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    180          static zlmhdr_t    *s_sdreply;
   \                     s_sdreply:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    181          #if !defined ZPORT
    182          static zlsdR_t     *s_sdrpayload;
    183          static image_t      s_itype;
    184          static uint8       s_lastSeen, s_firstTx = 1;
    185          #endif

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    186          static void        (*s_pCallback)(uint16);
   \                     s_pCallback:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          static uint16      s_eventMask;
   \                     s_eventMask:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          static uint8       s_lastTxSeqNum;
   \                     s_lastTxSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    189          
    190          #if defined ZPORT

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          static uint8       s_serialMsg;
   \                     s_serialMsg:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          static uint16      s_lastSeqNum;
   \                     s_lastSeqNum:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    193          static uint16      s_myNwkAddr = 0xFFFE;
   \                     s_myNwkAddr:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for s_myNwkAddr>`
   \   000002                REQUIRE __INIT_XDATA_I
    194          
    195          // pass through stuff

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    196          static uint8                  s_PTSeqNum;
   \                     s_PTSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    197          static afIncomingMSGPacket_t  s_PTClientInfo;
   \                     s_PTClientInfo:
   \   000000                DS 35
   \   000023                REQUIRE __INIT_XDATA_Z
    198          #else
    199          
    200          #pragma location="CRC_SHDW"
    201          const CODE uint16 _crcShdw = 0xFFFF;
    202          #pragma required=_crcShdw
    203          
    204          #pragma location="PREAMBLE"
    205          const CODE preamble_t _preamble = {
    206           {PREAMBLE_MAGIC1, PREAMBLE_MAGIC2},
    207            HAL_OAD_DL_SIZE,
    208            HAL_OAD_VERS,
    209            HAL_OAD_MANU,
    210            HAL_OAD_PROD
    211          };
    212          #pragma required=_preamble
    213          #endif
    214          
    215          // This list should be filled with Application specific Cluster IDs.

   \                                 In  segment XDATA_ROM_C, align 1
    216          static const cId_t OAD_ClusterList[OAD_CLUSTER_CNT] =
   \                     OAD_ClusterList:
   \   000000   0100         DW 1
   \   000002   0000         DW 0
    217          {
    218            OAD_CLUSTERID_CS
    219            //,OAD_CLUSTERID_EM
    220          };
    221          

   \                                 In  segment XDATA_ROM_C, align 1
    222          static const SimpleDescriptionFormat_t OAD_SimpleDesc =
   \                     OAD_SimpleDesc:
   \   000000   C8           DB 200
   \   000001   03C0         DW 49155
   \   000003   0100         DW 1
   \   000005   00           DB 0
   \   000006   02           DB 2
   \   000007   ....         DW OAD_ClusterList
   \   000009   00           DB 0
   \   00000A   0000         DW 0H
    223          {
    224            OAD_ENDPOINT,
    225            OAD_PROFILE_ID,
    226            OAD_DEVICEID,
    227            OAD_DEVICE_VERSION,
    228            OAD_FLAGS,
    229            OAD_CLUSTER_CNT,
    230            (cId_t *)OAD_ClusterList,
    231            0,
    232            NULL
    233          };
    234          

   \                                 In  segment XDATA_ROM_C, align 1
    235          static const endPointDesc_t OAD_epDesc=
   \                     OAD_epDesc:
   \   000000   C8           DB 200
   \   000001   ....         DW oad_app_taskId
   \   000003   ....         DW OAD_SimpleDesc
   \   000005   00           DB 0
    236          {
    237            OAD_ENDPOINT,
    238            &oad_app_taskId,
    239            (SimpleDescriptionFormat_t *)&OAD_SimpleDesc,
    240            noLatencyReqs,
    241          };
    242          
    243          #if defined HAL_OAD_BL21
    244          // this is the mailbox value that tells the boot code to flash the downloaded image
    245          // even though the operational image may be sane.
    246          #define MBOX_OAD_ENABLE      0x454E424C           // 'ENBL' enable downloaded code
    247          PACK_1
    248          typedef struct mbox_s {
    249            volatile unsigned long BootRead;
    250            volatile unsigned long AppRead;
    251          } mboxMsg_t;
    252          #pragma location="MBOXMSG_ADDR"
    253          __no_init mboxMsg_t mboxMsg;
    254          PACK_1
    255          typedef struct  {
    256               uint8      (*ReadFlash)(image_t, uint32 addr, uint8 *pBuf, uint16 len);
    257               uint8      (*WriteFlash)(image_t, uint32 addr, uint8 *pBuf, uint16 len);
    258               uint8      (*CheckCodeSanity)(image_t, uint32 addr1, uint32 addr2);
    259               uint8      (*GetPreamble)(image_t, uint32 addr, preamble_t *pBuf);
    260          } mbox_t;
    261          #pragma location="MBOX_ADDR"
    262          __no_init mbox_t mbox;
    263          #endif
    264          
    265          /* ------------------------------------------------------------------------------------------------
    266           *                                       Local Functions
    267           * ------------------------------------------------------------------------------------------------
    268           */
    269          
    270          static void procSysEvtMsg(void);
    271          static void zlResetState(void);
    272          
    273          static void   ZLOADApp_MessageMSGCB( afIncomingMSGPacket_t * );
    274          static void   ZLOADApp_handleCommand(afIncomingMSGPacket_t *, zlmhdr_t *);
    275          static void   ZLOADApp_handleReply(afIncomingMSGPacket_t *, zlmhdr_t *);
    276          
    277          static void   zlCleanupOnReset(void);
    278          static void   zlStartClientSession(void);
    279          static void   zlProcessSDR(zlsdR_t *);
    280          static void   zlRequestNextDataPacket(void);
    281          static void   zlCleanupOnXferDone(void);
    282          static void   zlResendSDC(void);
    283          
    284          #if defined ZPORT
    285          static void   zlSendSerial(uint8 *, uint8);
    286          static void   ZLOADApp_SerialMessageMSGCB(zahdrout_t *);
    287          static void   zlZArchitectProxyMsg(zahdrout_t *);
    288          
    289          static uint8      zlPassOnStartSessionOK(uint8 *);
    290          static zahdrin_t *zlBuildExternalInboundSerialMSG(afIncomingMSGPacket_t *, uint8 *, uint8);
    291          static zahdrin_t *zlBuildInternalInboundSerialMSG(uint8 *, uint8);
    292          static void zlHandleKeys(uint8 shift, uint8 keys);
    293          #else
    294          static uint8  zlSendCommand(uint8, uint8 *);
    295          static void   zlProcessSDC(zlsdC_t *);
    296          static uint8  zlIsReqPacketNumOK(uint16);
    297          #if (HAL_OAD_XNV_IS_INT && ((HAL_OAD_DL_OSET % HAL_FLASH_PAGE_SIZE) != 0))
    298          static Status_t zlEraseHalfPage(void);
    299          #endif
    300          #endif
    301          
    302          /**************************************************************************************************
    303           * @fn          oadAppInit
    304           *
    305           * @brief       This function is called by OSAL system startup.
    306           *
    307           * input parameters
    308           *
    309           * @param       id - The Task ID assigned by OSAL.
    310           *
    311           * output parameters
    312           *
    313           * None.
    314           *
    315           * @return      None.
    316           **************************************************************************************************
    317           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    318          void oadAppInit(uint8 id)
   \                     oadAppInit:
    319          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   85..82       MOV     DPL,?XSP + 0
   \   00000E   85..83       MOV     DPH,?XSP + 1
   \   000011   F0           MOVX    @DPTR,A
    320            oad_app_taskId = id;
   \   000012   90....       MOV     DPTR,#oad_app_taskId
   \   000015   F0           MOVX    @DPTR,A
    321            afRegister((endPointDesc_t *)&OAD_epDesc);
   \   000016                ; Setup parameters for call to function afRegister
   \   000016   7A..         MOV     R2,#OAD_epDesc & 0xff
   \   000018   7B..         MOV     R3,#(OAD_epDesc >> 8) & 0xff
   \   00001A   12....       LCALL   ??afRegister?relay
    322            s_State = ZLSTATE_IDLE;
   \   00001D   90....       MOV     DPTR,#s_State
   \   000020   7401         MOV     A,#0x1
   \   000022   F0           MOVX    @DPTR,A
    323            id = PREAMBLE_OFFSET;
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   748C         MOV     A,#-0x74
   \   00002B   F0           MOVX    @DPTR,A
    324            osal_nv_item_init(PREAMBLE_NV_ID, 1, &id);
   \   00002C                ; Setup parameters for call to function osal_nv_item_init
   \   00002C   8582..       MOV     ?V0 + 0,DPL
   \   00002F   8583..       MOV     ?V0 + 1,DPH
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000037   7C01         MOV     R4,#0x1
   \   000039   7D00         MOV     R5,#0x0
   \   00003B   7AFF         MOV     R2,#-0x1
   \   00003D   7B0F         MOV     R3,#0xf
   \   00003F   12....       LCALL   ??osal_nv_item_init?relay
   \   000042   7402         MOV     A,#0x2
   \   000044   12....       LCALL   ?DEALLOC_XSTACK8
    325          #if defined HAL_OAD_BL21
    326            mboxMsg.BootRead = 0;
    327          #endif
    328          #if defined ZPORT
    329            // Register for all key events - This app will handle all key events
    330            RegisterForKeys(oad_app_taskId);
   \   000047                ; Setup parameters for call to function RegisterForKeys
   \   000047   90....       MOV     DPTR,#oad_app_taskId
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F9           MOV     R1,A
   \   00004C   12....       LCALL   ??RegisterForKeys?relay
    331            mtxMode = TRUE;
   \   00004F   90....       MOV     DPTR,#mtxMode
   \   000052   7401         MOV     A,#0x1
   \   000054   F0           MOVX    @DPTR,A
    332          #endif
    333          }
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
   \   000058                REQUIRE ?Subroutine0
   \   000058                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    334          
    335          /**************************************************************************************************
    336           * @fn          oadAppEvt
    337           *
    338           * @brief       This function is called to process the OSAL events for the task.
    339           *
    340           * input parameters
    341           *
    342           * @param       id - The Task ID assigned by OSAL.
    343           * @param       evts - A bit mask representing the OSAL events that are pending for this task.
    344           *
    345           * output parameters
    346           *
    347           * None.
    348           *
    349           * @return      None.
    350           **************************************************************************************************
    351           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    352          uint16 oadAppEvt(uint8 id, uint16 evts)
   \                     oadAppEvt:
    353          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    354            uint16 mask = 0;
    355            (void)id;
    356            
    357            if (evts & SYS_EVENT_MSG)
   \   000009   5480         ANL     A,#0x80
   \   00000B   600C         JZ      ??oadAppEvt_0
    358            {
    359              mask = SYS_EVENT_MSG;
   \   00000D   75..00       MOV     ?V0 + 0,#0x0
   \   000010   75..80       MOV     ?V0 + 1,#-0x80
    360              procSysEvtMsg();
   \   000013                ; Setup parameters for call to function procSysEvtMsg
   \   000013   12....       LCALL   ??procSysEvtMsg?relay
   \   000016   02....       LJMP    ??oadAppEvt_1 & 0xFFFF
    361            }
    362            else if (evts & ZLOAD_CODE_ENABLE_EVT)
   \                     ??oadAppEvt_0:
   \   000019   EE           MOV     A,R6
   \   00001A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001C   5026         JNC     ??oadAppEvt_2
    363            {
    364              // let the user shut down the environment if requested
    365              DO_EVENT_CALLBACK(ZLCB_EVENT_CODE_ENABLE_RESET);
   \   00001E   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000021   6017         JZ      ??oadAppEvt_3
   \   000023   90....       MOV     DPTR,#s_eventMask
   \   000026   E0           MOVX    A,@DPTR
   \   000027   5410         ANL     A,#0x10
   \   000029   600F         JZ      ??oadAppEvt_3
   \   00002B                ; Setup parameters for indirect call
   \   00002B   7A10         MOV     R2,#0x10
   \   00002D   7B00         MOV     R3,#0x0
   \   00002F   90....       MOV     DPTR,#s_pCallback + 1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F583         MOV     DPH,A
   \   000035   8882         MOV     DPL,R0
   \   000037   12....       LCALL   ?CALL_IND
    366          
    367          #if defined HAL_OAD_BL21
    368              // Set up mail box to tell the pre-2.2 boot code to flash the downloaded image.
    369              mboxMsg.BootRead = MBOX_OAD_ENABLE;
    370          #else
    371              HalOADInvRC();
    372          #endif
    373              SystemReset();
   \                     ??oadAppEvt_3:
   \   00003A   C2AF         CLR     0xa8.7
   \   00003C   75C9AB       MOV     0xc9,#-0x55
   \   00003F   75C95B       MOV     0xc9,#0x5b
   \                     ??oadAppEvt_4:
   \   000042   80FE         SJMP    ??oadAppEvt_4
    374            }
    375            else if (evts & ZLOAD_IS_CLIENT_EVT)
   \                     ??oadAppEvt_2:
   \   000044   5402         ANL     A,#0x2
   \   000046   600C         JZ      ??oadAppEvt_5
    376            {
    377              mask = ZLOAD_IS_CLIENT_EVT;
   \   000048   75..02       MOV     ?V0 + 0,#0x2
   \   00004B   75..00       MOV     ?V0 + 1,#0x0
    378              zlStartClientSession();
   \   00004E                ; Setup parameters for call to function zlStartClientSession
   \   00004E   12....       LCALL   ??zlStartClientSession?relay
   \   000051   02....       LJMP    ??oadAppEvt_1 & 0xFFFF
    379            }
    380            else if (evts & ZLOAD_XFER_DONE_EVT)
   \                     ??oadAppEvt_5:
   \   000054   EE           MOV     A,R6
   \   000055   5404         ANL     A,#0x4
   \   000057   6070         JZ      ??oadAppEvt_6
    381            {
    382              mask = ZLOAD_XFER_DONE_EVT;
   \   000059   75..04       MOV     ?V0 + 0,#0x4
   \   00005C   75..00       MOV     ?V0 + 1,#0x0
    383              zlCleanupOnXferDone();
   \   00005F   90....       MOV     DPTR,#s_State
   \   000062   E0           MOVX    A,@DPTR
   \   000063   6404         XRL     A,#0x4
   \   000065   7006         JNZ     ??oadAppEvt_7
   \   000067   7401         MOV     A,#0x1
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   02....       LJMP    ??oadAppEvt_1 & 0xFFFF
   \                     ??oadAppEvt_7:
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   6402         XRL     A,#0x2
   \   000070   7052         JNZ     ??oadAppEvt_8
   \   000072                ; Setup parameters for call to function osal_mem_alloc
   \   000072   7A04         MOV     R2,#0x4
   \   000074   7B00         MOV     R3,#0x0
   \   000076   12....       LCALL   ??osal_mem_alloc?relay
   \   000079   8A..         MOV     ?V0 + 2,R2
   \   00007B   8B..         MOV     ?V0 + 3,R3
   \   00007D   EA           MOV     A,R2
   \   00007E   45..         ORL     A,?V0 + 3
   \   000080   6042         JZ      ??oadAppEvt_8
   \   000082   8A82         MOV     DPL,R2
   \   000084   8B83         MOV     DPH,R3
   \   000086   7403         MOV     A,#0x3
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   7401         MOV     A,#0x1
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   90....       MOV     DPTR,#s_SessionID
   \   000091   12....       LCALL   ?Subroutine18 & 0xFFFF
    384            }
   \                     ??CrossCallReturnLabel_22:
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   F0           MOVX    @DPTR,A
   \   000097   90....       MOV     DPTR,#s_lastTxSeqNum
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   04           INC     A
   \   00009C   F0           MOVX    @DPTR,A
   \   00009D   8A82         MOV     DPL,R2
   \   00009F   8B83         MOV     DPH,R3
   \   0000A1   A3           INC     DPTR
   \   0000A2   F0           MOVX    @DPTR,A
   \   0000A3                ; Setup parameters for call to function zlBuildInternalInboundSerialMSG
   \   0000A3   7904         MOV     R1,#0x4
   \   0000A5   12....       LCALL   ??zlBuildInternalInboundSerialMSG?relay
   \   0000A8   8A..         MOV     ?V0 + 4,R2
   \   0000AA   8B..         MOV     ?V0 + 5,R3
   \   0000AC   EA           MOV     A,R2
   \   0000AD   45..         ORL     A,?V0 + 5
   \   0000AF   600C         JZ      ??oadAppEvt_9
   \   0000B1                ; Setup parameters for call to function zlSendSerial
   \   0000B1   790A         MOV     R1,#0xa
   \   0000B3   12....       LCALL   ??zlSendSerial?relay
   \   0000B6                ; Setup parameters for call to function osal_mem_free
   \   0000B6   AA..         MOV     R2,?V0 + 4
   \   0000B8   AB..         MOV     R3,?V0 + 5
   \   0000BA   12....       LCALL   ??osal_mem_free?relay
   \                     ??oadAppEvt_9:
   \   0000BD                ; Setup parameters for call to function osal_mem_free
   \   0000BD   AA..         MOV     R2,?V0 + 2
   \   0000BF   AB..         MOV     R3,?V0 + 3
   \   0000C1   12....       LCALL   ??osal_mem_free?relay
   \                     ??oadAppEvt_8:
   \   0000C4                ; Setup parameters for call to function zlResetState
   \   0000C4   12....       LCALL   ??zlResetState?relay
   \   0000C7   8077         SJMP    ??oadAppEvt_1
    385            else if (evts & ZLOAD_RESET_EVT)
   \                     ??oadAppEvt_6:
   \   0000C9   EE           MOV     A,R6
   \   0000CA   5408         ANL     A,#0x8
   \   0000CC   6008         JZ      ??oadAppEvt_10
    386            {
    387              mask = ZLOAD_RESET_EVT;
   \   0000CE   75..08       MOV     ?V0 + 0,#0x8
   \   0000D1   75..00       MOV     ?V0 + 1,#0x0
    388              zlCleanupOnReset();
   \   0000D4                ; Setup parameters for call to function zlResetState
   \   0000D4   80EE         SJMP    ??oadAppEvt_8
    389            }
    390            else if (evts & ZLOAD_SDRTIMER_EVT)
   \                     ??oadAppEvt_10:
   \   0000D6   EE           MOV     A,R6
   \   0000D7   5410         ANL     A,#0x10
   \   0000D9   6052         JZ      ??oadAppEvt_11
    391            {
    392              mask = ZLOAD_SDRTIMER_EVT;
   \   0000DB   75..10       MOV     ?V0 + 0,#0x10
   \   0000DE   75..00       MOV     ?V0 + 1,#0x0
    393              zlResendSDC();
   \   0000E1   90....       MOV     DPTR,#s_State
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   6402         XRL     A,#0x2
   \   0000E7   7057         JNZ     ??oadAppEvt_1
   \   0000E9   90....       MOV     DPTR,#s_SDCRetryCount
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   24FF         ADD     A,#-0x1
   \   0000EF   F0           MOVX    @DPTR,A
   \   0000F0   F8           MOV     R0,A
   \   0000F1   A3           INC     DPTR
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   34FF         ADDC    A,#-0x1
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   F9           MOV     R1,A
   \   0000F7   E8           MOV     A,R0
   \   0000F8   49           ORL     A,R1
   \   0000F9   602E         JZ      ??oadAppEvt_12
   \   0000FB   12....       LCALL   ?Subroutine5 & 0xFFFF
    394            }
   \                     ??CrossCallReturnLabel_7:
   \   0000FE   C0E0         PUSH    A
   \   000100   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000103   D0E0         POP     A
   \   000105   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000108   8A..         MOV     ?V0 + 2,R2
   \   00010A   8B..         MOV     ?V0 + 3,R3
   \   00010C   EA           MOV     A,R2
   \   00010D   45..         ORL     A,?V0 + 3
   \   00010F   600C         JZ      ??oadAppEvt_13
   \   000111                ; Setup parameters for call to function zlSendSerial
   \   000111   790C         MOV     R1,#0xc
   \   000113   12....       LCALL   ??zlSendSerial?relay
   \   000116                ; Setup parameters for call to function osal_mem_free
   \   000116   AA..         MOV     R2,?V0 + 2
   \   000118   AB..         MOV     R3,?V0 + 3
   \   00011A   12....       LCALL   ??osal_mem_free?relay
   \                     ??oadAppEvt_13:
   \   00011D                ; Setup parameters for call to function osal_start_timerEx
   \   00011D   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000120   601E         JZ      ??oadAppEvt_1
   \   000122                ; Setup parameters for call to function osal_set_event
   \   000122   7A10         MOV     R2,#0x10
   \                     ??oadAppEvt_14:
   \   000124   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000127   8017         SJMP    ??oadAppEvt_1
   \                     ??oadAppEvt_12:
   \   000129                ; Setup parameters for call to function osal_set_event
   \   000129   7A04         MOV     R2,#0x4
   \   00012B   80F7         SJMP    ??oadAppEvt_14
    395            else if (evts & ZLOAD_RESET_BOARD_EVT)
   \                     ??oadAppEvt_11:
   \   00012D   EE           MOV     A,R6
   \   00012E   5420         ANL     A,#0x20
   \   000130   600A         JZ      ??oadAppEvt_15
    396            {
    397              SystemReset();
   \   000132   C2AF         CLR     0xa8.7
   \   000134   75C9AB       MOV     0xc9,#-0x55
   \   000137   75C95B       MOV     0xc9,#0x5b
   \                     ??oadAppEvt_16:
   \   00013A   80FE         SJMP    ??oadAppEvt_16
    398            }
    399            else
    400            {
    401              mask = evts;  // Discard unknown events - should never happen.
   \                     ??oadAppEvt_15:
   \   00013C   8E..         MOV     ?V0 + 0,R6
   \   00013E   8F..         MOV     ?V0 + 1,R7
    402            }
    403          
    404            return (evts ^ mask);  // Return unprocessed events.
   \                     ??oadAppEvt_1:
   \   000140   EE           MOV     A,R6
   \   000141   65..         XRL     A,?V0 + 0
   \   000143   FA           MOV     R2,A
   \   000144   EF           MOV     A,R7
   \   000145   65..         XRL     A,?V0 + 1
   \   000147   FB           MOV     R3,A
   \   000148                REQUIRE ?Subroutine1
   \   000148                REQUIRE _A_IEN0
   \   000148                REQUIRE WDCTL
   \   000148                ; // Fall through to label ?Subroutine1
    405          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   7CE8         MOV     R4,#-0x18
   \   000002   7D03         MOV     R5,#0x3
   \   000004   7A10         MOV     R2,#0x10
   \   000006                REQUIRE ??Subroutine34_0
   \   000006                ; // Fall through to label ??Subroutine34_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   90....       MOV     DPTR,#oad_app_taskId
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F9           MOV     R1,A
   \   000007   12....       LCALL   ??osal_start_timerEx?relay
   \   00000A   E9           MOV     A,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   90....       MOV     DPTR,#s_sdcmd
   \   000003                REQUIRE ??Subroutine35_0
   \   000003                ; // Fall through to label ??Subroutine35_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine35_0:
   \   000000   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   90....       MOV     DPTR,#s_pCallback
   \   000003                REQUIRE ??Subroutine36_0
   \   000003                ; // Fall through to label ??Subroutine36_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine36_0:
   \   000000   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine39_0
   \   000002                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   90....       MOV     DPTR,#oad_app_taskId
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??osal_set_event?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   90....       MOV     DPTR,#s_lastSeqNum
   \   000003   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000006   F0           MOVX    @DPTR,A
   \   000007   90....       MOV     DPTR,#s_lastSeqNum
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2401         ADD     A,#0x1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zlBuildInternalInboundSerialMSG
   \   000001                ; Setup parameters for call to function zlBuildInternalInboundSerialMSG
   \   000001   7906         MOV     R1,#0x6
   \   000003   90....       MOV     DPTR,#s_sdcmd
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FA           MOV     R2,A
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FB           MOV     R3,A
   \   00000B   12....       LCALL   ??zlBuildInternalInboundSerialMSG?relay
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    406          
    407          /**************************************************************************************************
    408           * @fn          procSysEvtMsg
    409           *
    410           * @brief       This function is called by oadAppEvt() to process all of the pending OSAL messages.
    411           *
    412           * input parameters
    413           *
    414           * None.
    415           *
    416           * output parameters
    417           *
    418           * None.
    419           *
    420           * @return      None.
    421           **************************************************************************************************
    422           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    423          static void procSysEvtMsg(void)
   \                     procSysEvtMsg:
    424          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8015         SJMP    ??procSysEvtMsg_0
    425            uint8 *msgPtr;
    426          
    427            while ((msgPtr = osal_msg_receive(oad_app_taskId)))
    428            {
    429          #if defined ZPORT
    430              s_serialMsg = 0;
    431          #endif
    432          
    433              switch ( *msgPtr )
    434              {
    435              case MT_SYS_APP_MSG:
    436              case MT_SYS_APP_RSP_MSG:
    437          #if defined ZPORT
    438                // This is how we get messages from a Host application (ZOAD.exe).
    439                s_serialMsg = 1;
    440                ZLOADApp_SerialMessageMSGCB((zahdrout_t *)(((mtSysAppMsg_t *)msgPtr)->appData));
    441          #endif
    442                break;
    443          
    444              case AF_DATA_CONFIRM_CMD:
    445                break;
    446          
    447              case AF_INCOMING_MSG_CMD:
    448                ZLOADApp_MessageMSGCB((afIncomingMSGPacket_t *)msgPtr);
    449                break;
    450          
    451          #if defined ZPORT
    452              case KEY_CHANGE:
    453                zlHandleKeys(((keyChange_t *)msgPtr)->state, ((keyChange_t *)msgPtr)->keys);
    454                break;
    455          #endif
    456          
    457              case ZDO_NEW_DSTADDR:
    458                /*
    459                dstEP = msgPtr[1];
    460                dstAddr = (zAddrType_t *)&msgPtr[2];
    461          
    462                dstAddr.addrMode = dstAddr->addrMode;
    463                dstAddr.endPoint = dstEP;
    464                if (dstAddr->addrMode == afAddr16Bit)
    465                  dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
    466                else
    467                  osal_memcpy(dstAddr.addr.extAddr, dstAddr->addr.extAddr, Z_EXTADDR_LEN);
    468                 */
    469                break;
    470          
    471              case ZDO_STATE_CHANGE:
    472          #if defined ZPORT
    473                if (((devStates_t)(((osal_event_hdr_t *)msgPtr)->status) == DEV_END_DEVICE_UNAUTH) ||
    474                    ((devStates_t)(((osal_event_hdr_t *)msgPtr)->status) == DEV_END_DEVICE))
   \                     ??procSysEvtMsg_1:
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6405         XRL     A,#0x5
   \   00000B   6005         JZ      ??procSysEvtMsg_2
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6406         XRL     A,#0x6
   \   000010   7003         JNZ     ??procSysEvtMsg_3
    475                {
    476                  MT_X_FakeNwkJoinCnf();
   \                     ??procSysEvtMsg_2:
   \   000012                ; Setup parameters for call to function MT_X_FakeNwkJoinCnf
   \   000012   12....       LCALL   ??MT_X_FakeNwkJoinCnf?relay
    477                }
    478          #endif
    479                break;
    480          
    481              default:
    482                break;
    483              }
    484          
    485              osal_msg_deallocate(msgPtr);  // Receiving task is responsible for releasing the memory.
   \                     ??procSysEvtMsg_3:
   \   000015                ; Setup parameters for call to function osal_msg_deallocate
   \   000015   EE           MOV     A,R6
   \   000016   FA           MOV     R2,A
   \   000017   EF           MOV     A,R7
   \   000018   FB           MOV     R3,A
   \   000019   12....       LCALL   ??osal_msg_deallocate?relay
   \                     ??procSysEvtMsg_0:
   \   00001C                ; Setup parameters for call to function osal_msg_receive
   \   00001C   90....       MOV     DPTR,#oad_app_taskId
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   12....       LCALL   ??osal_msg_receive?relay
   \   000024   8A..         MOV     ?V0 + 0,R2
   \   000026   8B..         MOV     ?V0 + 1,R3
   \   000028   A8..         MOV     R0,?V0 + 0
   \   00002A   A9..         MOV     R1,?V0 + 1
   \   00002C   E8           MOV     A,R0
   \   00002D   FE           MOV     R6,A
   \   00002E   E9           MOV     A,R1
   \   00002F   FF           MOV     R7,A
   \   000030   E8           MOV     A,R0
   \   000031   49           ORL     A,R1
   \   000032   607B         JZ      ??procSysEvtMsg_4
   \   000034   90....       MOV     DPTR,#s_serialMsg
   \   000037   E4           CLR     A
   \   000038   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   24E6         ADD     A,#-0x1a
   \   00003E   6024         JZ      ??procSysEvtMsg_5
   \   000040   24F7         ADD     A,#-0x9
   \   000042   600D         JZ      ??procSysEvtMsg_6
   \   000044   14           DEC     A
   \   000045   600A         JZ      ??procSysEvtMsg_6
   \   000047   2464         ADD     A,#0x64
   \   000049   603B         JZ      ??procSysEvtMsg_7
   \   00004B   24EF         ADD     A,#-0x11
   \   00004D   60B8         JZ      ??procSysEvtMsg_1
   \   00004F   80C4         SJMP    ??procSysEvtMsg_3
   \                     ??procSysEvtMsg_6:
   \   000051   90....       MOV     DPTR,#s_serialMsg
   \   000054   7401         MOV     A,#0x1
   \   000056   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00005F   12....       LCALL   ??ZLOADApp_SerialMessageMSGCB?relay
   \   000062   80B1         SJMP    ??procSysEvtMsg_3
   \                     ??procSysEvtMsg_5:
   \   000064   EE           MOV     A,R6
   \   000065   2421         ADD     A,#0x21
   \   000067   F582         MOV     DPL,A
   \   000069   EF           MOV     A,R7
   \   00006A   3400         ADDC    A,#0x0
   \   00006C   F583         MOV     DPH,A
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   FC           MOV     R4,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   FD           MOV     R5,A
   \   000073   8C82         MOV     DPL,R4
   \   000075   8D83         MOV     DPH,R5
   \   000077   E0           MOVX    A,@DPTR
   \   000078   A2E7         MOV     C,0xE0 /* A   */.7
   \   00007A   5005         JNC     ??procSysEvtMsg_8
   \   00007C                ; Setup parameters for call to function ZLOADApp_handleReply
   \   00007C   12....       LCALL   ??ZLOADApp_handleReply?relay
   \   00007F   8094         SJMP    ??procSysEvtMsg_3
   \                     ??procSysEvtMsg_8:
   \   000081                ; Setup parameters for call to function ZLOADApp_handleCommand
   \   000081   12....       LCALL   ??ZLOADApp_handleCommand?relay
   \   000084   808F         SJMP    ??procSysEvtMsg_3
   \                     ??procSysEvtMsg_7:
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F8           MOV     R0,A
   \   00008B   8E82         MOV     DPL,R6
   \   00008D   8F83         MOV     DPH,R7
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   7081         JNZ     ??procSysEvtMsg_3
   \   000094   E8           MOV     A,R0
   \   000095   A2E0         MOV     C,0xE0 /* A   */.0
   \   000097   5006         JNC     ??procSysEvtMsg_9
   \   000099   90....       MOV     DPTR,#mtxMode
   \   00009C   7401         MOV     A,#0x1
   \   00009E   F0           MOVX    @DPTR,A
   \                     ??procSysEvtMsg_9:
   \   00009F   E8           MOV     A,R0
   \   0000A0   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000A2   4003         JC      $+5
   \   0000A4   02....       LJMP    ??procSysEvtMsg_3 & 0xFFFF
   \   0000A7   90....       MOV     DPTR,#mtxMode
   \   0000AA   E4           CLR     A
   \   0000AB   F0           MOVX    @DPTR,A
   \   0000AC   02....       LJMP    ??procSysEvtMsg_3 & 0xFFFF
    486            }
    487          }
   \                     ??procSysEvtMsg_4:
   \   0000AF   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZLOADApp_SerialMessageMSGCB
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000003   A3           INC     DPTR
   \   000004   22           RET
    488          
    489          /**********************************************************************************
    490           * @fn      ZLOADApp_MessageMSGCB
    491           *
    492           * @brief   Handle a normal ZLOAD command or reply. Forward it to proper handler
    493           *
    494           * @param   MSGpkt -  pointer to incoming AF packet
    495           *
    496           * @return  none
    497           */
    498          static void ZLOADApp_MessageMSGCB(afIncomingMSGPacket_t *MSGpkt)
    499          {
    500            zlmhdr_t *inMsg = (zlmhdr_t *)MSGpkt->cmd.Data;
    501          
    502            if (inMsg->zlhdr_msgid & ZLMSGID_REPLY_BIT)
    503            {
    504              ZLOADApp_handleReply(MSGpkt, inMsg);
    505            }
    506            else
    507            {
    508              ZLOADApp_handleCommand(MSGpkt, inMsg);
    509            }
    510          
    511            return;
    512          }
    513          
    514          /**********************************************************************************
    515           * @fn      ZLOADApp_handleCommand
    516           *
    517           * @brief   Handle a normal ZLOAD command
    518           *
    519           * @param   input
    520           *            MSGpkt  pointer to incoming AF packet. needed to get
    521           *                    reply address info
    522           *            msg     pointer to ZLOAD message
    523           *
    524           * @return  none
    525           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    526          static void ZLOADApp_handleCommand(afIncomingMSGPacket_t *MSGpkt, zlmhdr_t *msg)
   \                     ZLOADApp_handleCommand:
    527          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 10,R2
   \   00000C   8B..         MOV     ?V0 + 11,R3
   \   00000E   8C..         MOV     ?V0 + 8,R4
   \   000010   8D..         MOV     ?V0 + 9,R5
    528            uint8 *cpc, *cpr, paylSize;
    529            preamble_t preamble;
    530          
    531          #if defined ZPORT
    532            static uint8 *buf;
    533            if (!buf)
   \   000012   90....       MOV     DPTR,#??buf
   \   000015   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000018   701A         JNZ     ??ZLOADApp_handleCommand_0
    534            {
    535              if (!(buf = osal_mem_alloc(sizeof(zlmhdr_t) + sizeof(zlreply_t))))
   \   00001A                ; Setup parameters for call to function osal_mem_alloc
   \   00001A   7A17         MOV     R2,#0x17
   \   00001C   7B00         MOV     R3,#0x0
   \   00001E   12....       LCALL   ??osal_mem_alloc?relay
   \   000021   90....       MOV     DPTR,#??buf
   \   000024   EA           MOV     A,R2
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   EB           MOV     A,R3
   \   000028   F0           MOVX    @DPTR,A
   \   000029   90....       MOV     DPTR,#??buf
   \   00002C   12....       LCALL   ??Subroutine36_0 & 0xFFFF
    536              {
    537                return;
    538              }
    539            }
   \                     ??CrossCallReturnLabel_61:
   \   00002F   7003         JNZ     $+5
   \   000031   02....       LJMP    ??ZLOADApp_handleCommand_1 & 0xFFFF
    540          #else
    541            uint8 *buf = NULL;
    542            // allocate the reply buffer. use a union of the replies -- they're all pretty
    543            // small -- except for Send Data. that one is preallocated because we want
    544            // to really have it and not spend time doing malloc/free for so many transactions
    545            // besides, we don't want a malloc() to fail during the transfer.
    546            if (msg->zlhdr_msgid != ZLMSGID_SEND_DATA)
    547            {
    548              if (!(buf = osal_mem_alloc(sizeof(zlmhdr_t) + sizeof(zlreply_t))))
    549              {
    550                return;
    551              }
    552            }
    553            else
    554            {
    555              // make sure we don't have a premature send-data command. this is awkward because
    556              // in the normal case we've done a "static" allocation (for the durtion of the session)
    557              // to prevent thousands of alloc/free calls or a failed alloc. but now, we dont' have
    558              // that "static" memory yet.
    559              if (s_State != ZLSTATE_SERVER)
    560              {
    561                // uh oh. we never got a start session. now we need memory to
    562                // send the reply
    563                if (!(buf = osal_mem_alloc(sizeof(zlmhdr_t) + sizeof(zlsdR_t))))
    564                {
    565                  return;
    566                }
    567                // make the rest of the code work
    568                s_sdreply                     = (zlmhdr_t *)buf;
    569                s_sdreply->zlhdr_msgid        = ZLMSGID_SEND_DATA | ZLMSGID_REPLY_BIT;
    570                s_sdreply->zlhdr_msglen       = sizeof(zlsdR_t);
    571                s_sdrpayload                  = (zlsdR_t *)(buf+sizeof(zlmhdr_t));
    572                s_sdrpayload->zlsdR_state     = s_State;
    573                s_sdrpayload->zlsdR_errorCode = EC_SD_NOT_SERVER;
    574              }
    575            }
    576          #endif
    577          
    578            cpr = buf + sizeof(zlmhdr_t);            // offset of reply payload
   \                     ??ZLOADApp_handleCommand_0:
   \   000034   90....       MOV     DPTR,#??buf
   \   000037   E0           MOVX    A,@DPTR
   \   000038   2403         ADD     A,#0x3
   \   00003A   F5..         MOV     ?V0 + 4,A
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   3400         ADDC    A,#0x0
   \   000040   F5..         MOV     ?V0 + 5,A
    579            cpc = (uint8 *)msg + sizeof(zlmhdr_t);   // offset of command payload
   \   000042   E5..         MOV     A,?V0 + 8
   \   000044   2403         ADD     A,#0x3
   \   000046   F5..         MOV     ?V0 + 6,A
   \   000048   E5..         MOV     A,?V0 + 9
   \   00004A   3400         ADDC    A,#0x0
   \   00004C   F5..         MOV     ?V0 + 7,A
    580          
    581            switch (msg->zlhdr_msgid)  {
   \   00004E   85..82       MOV     DPL,?V0 + 4
   \   000051   85..83       MOV     DPH,?V0 + 5
   \   000054   A3           INC     DPTR
   \   000055   AE82         MOV     R6,DPL
   \   000057   AF83         MOV     R7,DPH
   \   000059   85..82       MOV     DPL,?V0 + 8
   \   00005C   85..83       MOV     DPH,?V0 + 9
   \   00005F   A3           INC     DPTR
   \   000060   8582..       MOV     ?V0 + 14,DPL
   \   000063   8583..       MOV     ?V0 + 15,DPH
   \   000066   E5..         MOV     A,?V0 + 10
   \   000068   2406         ADD     A,#0x6
   \   00006A   F5..         MOV     ?V0 + 12,A
   \   00006C   E5..         MOV     A,?V0 + 11
   \   00006E   3400         ADDC    A,#0x0
   \   000070   F5..         MOV     ?V0 + 13,A
   \   000072   85..82       MOV     DPL,?V0 + 8
   \   000075   85..83       MOV     DPH,?V0 + 9
   \   000078   E0           MOVX    A,@DPTR
   \   000079   14           DEC     A
   \   00007A   6027         JZ      ??ZLOADApp_handleCommand_2
   \   00007C   14           DEC     A
   \   00007D   7003         JNZ     $+5
   \   00007F   02....       LJMP    ??ZLOADApp_handleCommand_3 & 0xFFFF
   \   000082   14           DEC     A
   \   000083   7003         JNZ     $+5
   \   000085   02....       LJMP    ??ZLOADApp_handleCommand_4 & 0xFFFF
   \   000088   14           DEC     A
   \   000089   7003         JNZ     $+5
   \   00008B   02....       LJMP    ??ZLOADApp_handleCommand_5 & 0xFFFF
   \   00008E   14           DEC     A
   \   00008F   7003         JNZ     $+5
   \   000091   02....       LJMP    ??ZLOADApp_handleCommand_6 & 0xFFFF
   \   000094   14           DEC     A
   \   000095   7003         JNZ     $+5
   \   000097   02....       LJMP    ??ZLOADApp_handleCommand_7 & 0xFFFF
   \   00009A   14           DEC     A
   \   00009B   7003         JNZ     $+5
   \   00009D   02....       LJMP    ??ZLOADApp_handleCommand_8 & 0xFFFF
   \   0000A0   02....       LJMP    ??ZLOADApp_handleCommand_1 & 0xFFFF
    582            case ZLMSGID_STATUSQ:
    583              {
    584                uint8 dlImagePreambleOffset;
    585                zlstatusR_t *reply = (zlstatusR_t *)cpr;
    586                paylSize = sizeof(zlstatusR_t);
   \                     ??ZLOADApp_handleCommand_2:
   \   0000A3   75..14       MOV     ?V0 + 3,#0x14
    587          
    588                reply->zlsqR_state     = s_State;
   \   0000A6   12....       LCALL   ?Subroutine4 & 0xFFFF
    589                reply->zlsqR_errorCode = EC_NO_ERROR;
    590                // report capabiltities and version
    591                reply->zlsqR_ProtocolVersion = ZLOAD_PROTOCOL_VERSION;
   \                     ??CrossCallReturnLabel_4:
   \   0000A9   85..82       MOV     DPL,?V0 + 4
   \   0000AC   85..83       MOV     DPH,?V0 + 5
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   04           INC     A
   \   0000B2   F0           MOVX    @DPTR,A
    592                reply->zlsqR_capabilties     = ZLOAD_CAPABILTIES;
   \   0000B3   85..82       MOV     DPL,?V0 + 4
   \   0000B6   85..83       MOV     DPH,?V0 + 5
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   E4           CLR     A
   \   0000BD   F0           MOVX    @DPTR,A
    593                cpr +=4;
    594          
    595                // populate the operational version values
    596                HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    597                cpr = osal_memcpy(cpr, &preamble.vers, ZL_IMAGE_ID_LENGTH);
   \   0000BE   7407         MOV     A,#0x7
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   A982         MOV     R1,DPL
   \   0000C5   AA83         MOV     R2,DPH
   \   0000C7   89..         MOV     ?V0 + 0,R1
   \   0000C9   8A..         MOV     ?V0 + 1,R2
   \   0000CB   75..00       MOV     ?V0 + 2,#0x0
   \   0000CE                ; Setup parameters for call to function osal_memcpy
   \   0000CE   78..         MOV     R0,#?V0 + 0
   \   0000D0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D3   7C06         MOV     R4,#0x6
   \   0000D5   7D00         MOV     R5,#0x0
   \   0000D7   E5..         MOV     A,?V0 + 4
   \   0000D9   2404         ADD     A,#0x4
   \   0000DB   FA           MOV     R2,A
   \   0000DC   E5..         MOV     A,?V0 + 5
   \   0000DE   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   0000E1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E4   8A..         MOV     ?V0 + 4,R2
   \   0000E6   8B..         MOV     ?V0 + 5,R3
    598          
    599                // do downloaded image if it's there
    600                osal_nv_read(PREAMBLE_NV_ID, 0, 1, &dlImagePreambleOffset);
   \   0000E8                ; Setup parameters for call to function osal_nv_read
   \   0000E8   85..82       MOV     DPL,?XSP + 0
   \   0000EB   85..83       MOV     DPH,?XSP + 1
   \   0000EE   8582..       MOV     ?V0 + 6,DPL
   \   0000F1   8583..       MOV     ?V0 + 7,DPH
   \   0000F4   78..         MOV     R0,#?V0 + 6
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   75..01       MOV     ?V0 + 6,#0x1
   \   0000FC   75..00       MOV     ?V0 + 7,#0x0
   \   0000FF   78..         MOV     R0,#?V0 + 6
   \   000101   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000104   7C00         MOV     R4,#0x0
   \   000106   7D00         MOV     R5,#0x0
   \   000108   7AFF         MOV     R2,#-0x1
   \   00010A   7B0F         MOV     R3,#0xf
   \   00010C   12....       LCALL   ??osal_nv_read?relay
   \   00010F   7404         MOV     A,#0x4
   \   000111   12....       LCALL   ?DEALLOC_XSTACK8
    601                HalOADRead(dlImagePreambleOffset, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
    602                if (preamble.vers != 0xFF)
   \   000114   7407         MOV     A,#0x7
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   F4           CPL     A
   \   00011B   7002         JNZ     ??ZLOADApp_handleCommand_9
   \   00011D   A3           INC     DPTR
   \   00011E   E0           MOVX    A,@DPTR
   \                     ??ZLOADApp_handleCommand_9:
   \   00011F   6019         JZ      ??ZLOADApp_handleCommand_10
    603                {
    604                  cpr = osal_memcpy(cpr, &preamble.vers, ZL_IMAGE_ID_LENGTH);
   \   000121                ; Setup parameters for call to function osal_memcpy
   \   000121   78..         MOV     R0,#?V0 + 0
   \   000123   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000126   7C06         MOV     R4,#0x6
   \   000128   7D00         MOV     R5,#0x0
   \   00012A   AA..         MOV     R2,?V0 + 4
   \   00012C   AB..         MOV     R3,?V0 + 5
   \   00012E   12....       LCALL   ??Subroutine44_0 & 0xFFFF
    605                }
   \                     ??CrossCallReturnLabel_93:
   \   000131   12....       LCALL   ?DEALLOC_XSTACK8
   \   000134   8A..         MOV     ?V0 + 4,R2
   \   000136   8B..         MOV     ?V0 + 5,R3
   \   000138   8019         SJMP    ??ZLOADApp_handleCommand_11
    606                else
    607                {
    608                  osal_memset(cpr, 0, ZL_IMAGE_ID_LENGTH);
   \                     ??ZLOADApp_handleCommand_10:
   \   00013A                ; Setup parameters for call to function osal_memset
   \   00013A   7C06         MOV     R4,#0x6
   \   00013C   7D00         MOV     R5,#0x0
   \   00013E   7900         MOV     R1,#0x0
   \   000140   AA..         MOV     R2,?V0 + 4
   \   000142   AB..         MOV     R3,?V0 + 5
   \   000144   12....       LCALL   ??osal_memset?relay
    609                  cpr += ZL_IMAGE_ID_LENGTH;
   \   000147   E5..         MOV     A,?V0 + 4
   \   000149   2406         ADD     A,#0x6
   \   00014B   F5..         MOV     ?V0 + 4,A
   \   00014D   E5..         MOV     A,?V0 + 5
   \   00014F   3400         ADDC    A,#0x0
   \   000151   F5..         MOV     ?V0 + 5,A
    610                }
    611          
    612                cpr = osal_memcpy(cpr, &s_NextPacket, sizeof(s_NextPacket));
    613                osal_memcpy(cpr, &s_NumPktGet, sizeof(s_NumPktGet));
   \                     ??ZLOADApp_handleCommand_11:
   \   000153                ; Setup parameters for call to function osal_memcpy
   \   000153   75....       MOV     ?V0 + 0,#s_NumPktGet & 0xff
   \   000156   75....       MOV     ?V0 + 1,#(s_NumPktGet >> 8) & 0xff
   \   000159   78..         MOV     R0,#?V0 + 0
   \   00015B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00015E                ; Setup parameters for call to function osal_memcpy
   \   00015E   75....       MOV     ?V0 + 0,#s_NextPacket & 0xff
   \   000161   75....       MOV     ?V0 + 1,#(s_NextPacket >> 8) & 0xff
   \   000164   78..         MOV     R0,#?V0 + 0
   \   000166   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000169   7C02         MOV     R4,#0x2
   \   00016B   7D00         MOV     R5,#0x0
   \   00016D   AA..         MOV     R2,?V0 + 4
   \   00016F   AB..         MOV     R3,?V0 + 5
   \   000171   12....       LCALL   ??Subroutine44_0 & 0xFFFF
    614              }
   \                     ??CrossCallReturnLabel_94:
   \   000174   12....       LCALL   ?DEALLOC_XSTACK8
   \   000177   7C02         MOV     R4,#0x2
   \   000179   7D00         MOV     R5,#0x0
   \   00017B   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   00017E   12....       LCALL   ?DEALLOC_XSTACK8
    615              break;
   \   000181   02....       LJMP    ??CrossCallReturnLabel_75 & 0xFFFF
    616          
    617            case ZLMSGID_SESSION_START:
    618          #if defined ZPORT
    619              // the pass through condition starts here, when a client tries
    620              // to begin a session with the dongle.
    621              if (s_State != ZLSTATE_IDLE)  {
   \                     ??ZLOADApp_handleCommand_3:
   \   000184   90....       MOV     DPTR,#s_State
   \   000187   E0           MOVX    A,@DPTR
   \   000188   6401         XRL     A,#0x1
   \   00018A   600A         JZ      ??ZLOADApp_handleCommand_12
    622                ((zlbegsessR_t *)cpr)->zlbsR_errorCode = EC_BS_NOT_IDLE;
   \   00018C   8E82         MOV     DPL,R6
   \   00018E   8F83         MOV     DPH,R7
   \   000190   7421         MOV     A,#0x21
   \                     ??ZLOADApp_handleCommand_13:
   \   000192   F0           MOVX    @DPTR,A
   \   000193   02....       LJMP    ??CrossCallReturnLabel_75 & 0xFFFF
    623              }
    624              else if (s_serialMsg)  {
   \                     ??ZLOADApp_handleCommand_12:
   \   000196   90....       MOV     DPTR,#s_serialMsg
   \   000199   E0           MOVX    A,@DPTR
   \   00019A   6008         JZ      ??ZLOADApp_handleCommand_14
    625                // somehow this came over the serial port and it isn't legal
    626                ((zlbegsessR_t *)cpr)->zlbsR_errorCode = EC_BS_NOT_SERVER;
   \   00019C   8E82         MOV     DPL,R6
   \   00019E   8F83         MOV     DPH,R7
   \   0001A0   7424         MOV     A,#0x24
   \   0001A2   80EE         SJMP    ??ZLOADApp_handleCommand_13
    627              }
    628              else  {
    629                // set mode. delay reply until we hear back from the Host
    630                s_PTSeqNum     = msg->zlhdr_seqnum;
   \                     ??ZLOADApp_handleCommand_14:
   \   0001A4   85..82       MOV     DPL,?V0 + 14
   \   0001A7   85..83       MOV     DPH,?V0 + 15
   \   0001AA   E0           MOVX    A,@DPTR
   \   0001AB   90....       MOV     DPTR,#s_PTSeqNum
   \   0001AE   F0           MOVX    @DPTR,A
    631                s_PTClientInfo = *MSGpkt;
   \   0001AF   85..82       MOV     DPL,?V0 + 10
   \   0001B2   85..83       MOV     DPH,?V0 + 11
   \   0001B5   7C..         MOV     R4,#s_PTClientInfo & 0xff
   \   0001B7   7D..         MOV     R5,#(s_PTClientInfo >> 8) & 0xff
   \   0001B9   7423         MOV     A,#0x23
   \   0001BB   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    632                s_SessionID    = ((zlbegsessC_t *)cpc)->zlbsC_sessionID;
   \   0001BE   85..82       MOV     DPL,?V0 + 6
   \   0001C1   85..83       MOV     DPH,?V0 + 7
   \   0001C4   A3           INC     DPTR
   \   0001C5   A3           INC     DPTR
   \   0001C6   A3           INC     DPTR
   \   0001C7   A3           INC     DPTR
   \   0001C8   A3           INC     DPTR
   \   0001C9   A3           INC     DPTR
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   90....       MOV     DPTR,#s_SessionID
   \   0001CE   F0           MOVX    @DPTR,A
    633                if (zlPassOnStartSessionOK((uint8 *)msg))  {
   \   0001CF                ; Setup parameters for call to function zlBuildExternalInboundSerialMSG
   \   0001CF   790A         MOV     R1,#0xa
   \   0001D1   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0001D4   7008         JNZ     ??ZLOADApp_handleCommand_15
    634                  s_State = ZLSTATE_PASS_THROUGH;
    635                  return;
    636                }
    637                else  {
    638                  ((zlbegsessR_t *)cpr)->zlbsR_errorCode = EC_BS_NO_MEM;
   \   0001D6   8E82         MOV     DPL,R6
   \   0001D8   8F83         MOV     DPH,R7
   \   0001DA   7423         MOV     A,#0x23
   \   0001DC   80B4         SJMP    ??ZLOADApp_handleCommand_13
   \                     ??ZLOADApp_handleCommand_15:
   \   0001DE                ; Setup parameters for call to function zlSendSerial
    639                }
   \   0001DE   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   0001E1   90....       MOV     DPTR,#s_State
   \   0001E4   7404         MOV     A,#0x4
   \   0001E6   F0           MOVX    @DPTR,A
   \   0001E7   02....       LJMP    ??ZLOADApp_handleCommand_1 & 0xFFFF
    640              }
    641          #else
    642              do {
    643                uint8 dlImagePreambleOffset;
    644                zlbegsessR_t *reply = (zlbegsessR_t *)cpr;
    645          
    646                // assume we're OK and set up fixed part of reply here
    647                reply->zlbsR_blkSize   = ZL_DATA_BLK_SIZE;
    648                reply->zlbsR_numBlks   = ZL_NUM_DATA_BLKS;
    649                reply->zlbsR_state     = s_State;
    650                reply->zlbsR_errorCode = EC_NO_ERROR;
    651          
    652                paylSize = sizeof(zlbegsessR_t);
    653          
    654                if (s_State != ZLSTATE_IDLE)  {
    655                  if (s_SessionID == ((zlbegsessC_t *)cpc)->zlbsC_sessionID)
    656                  {
    657                    // Ok - this must be a no ack retransmit or a retry.
    658                  }
    659                  else
    660                  {
    661                    reply->zlbsR_errorCode = EC_BS_NOT_IDLE;
    662                    continue;  // done
    663                  }
    664                }
    665          
    666                // see if there is a DL image to send
    667                osal_nv_read(PREAMBLE_NV_ID, 0, 1, &dlImagePreambleOffset);
    668                HalOADRead(dlImagePreambleOffset, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
    669                if (preamble.vers != 0xFFFF)
    670                {
    671                  if (!memcmp(cpc, (uint8 *)&preamble.vers, ZL_IMAGE_ID_LENGTH))  {
    672                    // image matches request.
    673                    osal_memcpy(&reply->zlbsR_imgLen, &preamble.len, sizeof(uint32));
    674                    s_State             = ZLSTATE_SERVER;
    675                    s_itype             = HAL_OAD_DL;
    676                    reply->zlbsR_preambleOffset = (uint8)PREAMBLE_OFFSET;
    677                    continue;    // done
    678                  }
    679                }
    680                // no DL image. we know there's an operational image
    681                HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    682                if (!memcmp(cpc, (uint8 *)&preamble.vers, ZL_IMAGE_ID_LENGTH))  {
    683                  // image matches request.
    684                  osal_memcpy(&reply->zlbsR_imgLen, &preamble.len, sizeof(uint32));
    685                  s_State                     = ZLSTATE_SERVER;
    686                  s_itype                     = HAL_OAD_RC;
    687                  reply->zlbsR_preambleOffset = (uint8)PREAMBLE_OFFSET;
    688                }
    689                else  {
    690                  reply->zlbsR_errorCode = EC_BS_NO_MATCHES;
    691                }
    692              } while (0);
    693          
    694              // if we're good to go, allocate the memory for the SD replies
    695              // this will make things more efficient during the transfer
    696              if (!((zlbegsessR_t *)cpr)->zlbsR_errorCode)  {
    697                uint8 *cp;
    698                zlbegsessR_t *reply = (zlbegsessR_t *)cpr;
    699          
    700                // need memory for sending replies and for holding flash pages
    701                if (!(cp=osal_mem_alloc(sizeof(zlmhdr_t)+sizeof(zlsdR_t))))  {
    702                  // oops -- none available. let Client decide what to do.
    703                  s_State                = ZLSTATE_IDLE;
    704                  reply->zlbsR_errorCode = EC_BS_NO_MEM;
    705                }
    706                else  {
    707                  s_NumPktGet  = (preamble.len + (ZL_DATA_BLK_SIZE*ZL_NUM_DATA_BLKS-1)) /
    708                                                 (ZL_DATA_BLK_SIZE*ZL_NUM_DATA_BLKS);
    709                  s_blkSize = ZL_DATA_BLK_SIZE * ZL_NUM_DATA_BLKS;
    710                  s_NextPacket = 0;
    711                  s_SessionID  = ((zlbegsessC_t *)cpc)->zlbsC_sessionID;
    712          
    713                  // set up other pointers
    714                  s_sdreply               = (zlmhdr_t *)cp;
    715                  s_sdreply->zlhdr_msgid  = ZLMSGID_SEND_DATA | ZLMSGID_REPLY_BIT;
    716                  s_sdreply->zlhdr_msglen = sizeof(zlsdR_t);
    717                  s_sdrpayload            = (zlsdR_t *)(cp+sizeof(zlmhdr_t));
    718                  DO_EVENT_CALLBACK(ZLCB_EVENT_OADBEGIN_SERVER);
    719                }
    720              }
    721          #endif
    722              break;
    723          
    724            case ZLMSGID_SESSION_TERM:
    725              {
    726                zlendsessR_t *reply = (zlendsessR_t *)cpr;
    727          
    728                reply->zlesR_state     = s_State;
   \                     ??ZLOADApp_handleCommand_4:
   \   0001EA   12....       LCALL   ?Subroutine4 & 0xFFFF
    729                reply->zlesR_errorCode = EC_NO_ERROR;
    730          
    731                // guard against terminating the wrong session
    732                if (((zlendsessC_t *)cpc)->zlesC_sessionID != s_SessionID)  {
   \                     ??CrossCallReturnLabel_5:
   \   0001ED   85..82       MOV     DPL,?V0 + 6
   \   0001F0   85..83       MOV     DPH,?V0 + 7
   \   0001F3   E0           MOVX    A,@DPTR
   \   0001F4   F8           MOV     R0,A
   \   0001F5   90....       MOV     DPTR,#s_SessionID
   \   0001F8   E0           MOVX    A,@DPTR
   \   0001F9   68           XRL     A,R0
   \   0001FA   6008         JZ      ??ZLOADApp_handleCommand_16
    733                  // wrong session ID
    734                  reply->zlesR_errorCode = EC_ES_BAD_SESS_ID;
   \   0001FC   8E82         MOV     DPL,R6
   \   0001FE   8F83         MOV     DPH,R7
   \   000200   7431         MOV     A,#0x31
   \   000202   8050         SJMP    ??ZLOADApp_handleCommand_17
    735                }
    736          #if defined ZPORT
    737                else if (s_serialMsg)  {
   \                     ??ZLOADApp_handleCommand_16:
   \   000204   90....       MOV     DPTR,#s_serialMsg
   \   000207   E0           MOVX    A,@DPTR
   \   000208   7044         JNZ     ??ZLOADApp_handleCommand_18
    738                  // somehow this came over the serial port and it isn't legal
    739                  ((zlbegsessR_t *)cpr)->zlbsR_errorCode = EC_ES_NOT_SERVER;
    740                }
    741          #endif
    742                else  {
    743          #if defined ZPORT
    744                  if (ZLSTATE_PASS_THROUGH == s_State)  {
   \   00020A   90....       MOV     DPTR,#s_State
   \   00020D   E0           MOVX    A,@DPTR
   \   00020E   6404         XRL     A,#0x4
   \   000210   703C         JNZ     ??ZLOADApp_handleCommand_18
    745                    // everything is OK. pass this up to host if we're in pass-through mode
    746                    // forward message to host
    747                    zahdrin_t *zain = zlBuildExternalInboundSerialMSG(&s_PTClientInfo, (uint8 *)msg, sizeof(zlmhdr_t) + sizeof(zlendsessC_t));
   \   000212                ; Setup parameters for call to function zlBuildExternalInboundSerialMSG
   \   000212   7904         MOV     R1,#0x4
   \   000214   12....       LCALL   ?Subroutine26 & 0xFFFF
    748          
    749                    if (zain)  {
   \                     ??CrossCallReturnLabel_35:
   \   000217   602D         JZ      ??ZLOADApp_handleCommand_19
    750                      if (SUCCESS != osal_start_timerEx(oad_app_taskId, ZLOAD_XFER_DONE_EVT, SDR_WAIT_TO))
   \   000219                ; Setup parameters for call to function osal_start_timerEx
   \   000219   7CE8         MOV     R4,#-0x18
   \   00021B   7D03         MOV     R5,#0x3
   \   00021D   7A04         MOV     R2,#0x4
   \   00021F   12....       LCALL   ??Subroutine34_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000222   6003         JZ      ??CrossCallReturnLabel_70
    751                      {
    752                        osal_set_event(oad_app_taskId, ZLOAD_XFER_DONE_EVT);
   \   000224                ; Setup parameters for call to function osal_set_event
   \   000224   12....       LCALL   ?Subroutine13 & 0xFFFF
    753                      }
    754          
    755                      s_PTClientInfo = *MSGpkt;
   \                     ??CrossCallReturnLabel_70:
   \   000227   85..82       MOV     DPL,?V0 + 10
   \   00022A   85..83       MOV     DPH,?V0 + 11
   \   00022D   7C..         MOV     R4,#s_PTClientInfo & 0xff
   \   00022F   7D..         MOV     R5,#(s_PTClientInfo >> 8) & 0xff
   \   000231   7423         MOV     A,#0x23
   \   000233   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    756                      zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + sizeof(zlendsessC_t));
   \   000236                ; Setup parameters for call to function zlSendSerial
   \   000236   790A         MOV     R1,#0xa
   \   000238   AA..         MOV     R2,?V0 + 0
   \   00023A   AB..         MOV     R3,?V0 + 1
   \   00023C   12....       LCALL   ??zlSendSerial?relay
    757                      osal_mem_free(zain);
   \   00023F                ; Setup parameters for call to function osal_mem_free
   \   00023F   AA..         MOV     R2,?V0 + 0
   \   000241   AB..         MOV     R3,?V0 + 1
   \   000243   02....       LJMP    ??ZLOADApp_handleCommand_20 & 0xFFFF
    758                      return;
    759                    }
    760                    else  {
    761                      reply->zlesR_errorCode = EC_ES_NO_MEM;
   \                     ??ZLOADApp_handleCommand_19:
   \   000246   8E82         MOV     DPL,R6
   \   000248   8F83         MOV     DPH,R7
   \   00024A   7433         MOV     A,#0x33
   \   00024C   8006         SJMP    ??ZLOADApp_handleCommand_17
    762                    }
    763                  }
    764          #else
    765                  if (s_State == ZLSTATE_SERVER)  {
    766                    // everything is OK.
    767                    osal_set_event(oad_app_taskId, ZLOAD_XFER_DONE_EVT);
    768                  }
    769          #endif
    770                  else  {
    771                    // right session ID but I'm not the server
    772                    reply->zlesR_errorCode = EC_ES_NOT_SERVER;
   \                     ??ZLOADApp_handleCommand_18:
   \   00024E   8E82         MOV     DPL,R6
   \   000250   8F83         MOV     DPH,R7
   \   000252   7432         MOV     A,#0x32
   \                     ??ZLOADApp_handleCommand_17:
   \   000254   F0           MOVX    @DPTR,A
    773                  }
    774                }
    775              }
    776              paylSize = sizeof(zlendsessR_t);
   \   000255   75..02       MOV     ?V0 + 3,#0x2
    777              break;
   \   000258   02....       LJMP    ??CrossCallReturnLabel_75 & 0xFFFF
    778          
    779                  case ZLMSGID_CLIENT_CMD:
    780                      {
    781                          zlclientR_t *reply = (zlclientR_t *)cpr;
    782          
    783                          reply->zlclR_errorCode = EC_NO_ERROR;
   \                     ??ZLOADApp_handleCommand_5:
   \   00025B   8E82         MOV     DPL,R6
   \   00025D   8F83         MOV     DPH,R7
   \   00025F   E4           CLR     A
   \   000260   F0           MOVX    @DPTR,A
    784                          paylSize               = sizeof(zlclientR_t);
   \   000261   12....       LCALL   ?Subroutine16 & 0xFFFF
    785                          reply->zlclR_state     = s_State;
    786          
    787          #if defined ZPORT
    788                          // we can be the client only if the dongle code itself is being updated
    789                          // and then only if the Host is the server
    790                          if (!s_serialMsg)  {
   \                     ??CrossCallReturnLabel_20:
   \   000264   7009         JNZ     ??ZLOADApp_handleCommand_21
    791                              reply->zlclR_errorCode = EC_CL_NOT_CLIENT;
   \   000266   8E82         MOV     DPL,R6
   \   000268   8F83         MOV     DPH,R7
   \   00026A   7443         MOV     A,#0x43
   \   00026C   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    792                          }
    793                          else                
    794          #endif
    795                          if (s_State != ZLSTATE_IDLE) {
   \                     ??ZLOADApp_handleCommand_21:
   \   00026F   85....       MOV     ?V0 + 0,?V0 + 6
   \   000272   85....       MOV     ?V0 + 1,?V0 + 7
   \   000275   75..00       MOV     ?V0 + 2,#0x0
   \   000278   90....       MOV     DPTR,#s_State
   \   00027B   E0           MOVX    A,@DPTR
   \   00027C   6401         XRL     A,#0x1
   \   00027E   602C         JZ      ??ZLOADApp_handleCommand_22
    796                            if (!osal_memcmp(s_clientInfo, cpc, sizeof(zlclientC_t))) {
   \   000280                ; Setup parameters for call to function osal_memcmp
   \   000280   78..         MOV     R0,#?V0 + 0
   \   000282   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000285   7C11         MOV     R4,#0x11
   \   000287   7D00         MOV     R5,#0x0
   \   000289   90....       MOV     DPTR,#s_clientInfo
   \   00028C   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00028F   A982         MOV     R1,DPL
   \   000291   AA83         MOV     R2,DPH
   \   000293   7B00         MOV     R3,#0x0
   \   000295   12....       LCALL   ??osal_memcmp?relay
   \   000298   7403         MOV     A,#0x3
   \   00029A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00029D   E9           MOV     A,R1
   \   00029E   6003         JZ      $+5
   \   0002A0   02....       LJMP    ??CrossCallReturnLabel_75 & 0xFFFF
    797                              reply->zlclR_errorCode = EC_CL_NOT_IDLE;
   \   0002A3   8E82         MOV     DPL,R6
   \   0002A5   8F83         MOV     DPH,R7
   \   0002A7   7441         MOV     A,#0x41
   \   0002A9   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    798                            }
    799                          }
    800          #if (HAL_OAD_XNV_IS_INT && ((HAL_OAD_DL_OSET % HAL_FLASH_PAGE_SIZE) != 0))
    801                          // Bug 2946 - HalXNVWrite() only triggers a page erase when the first byte of a
    802                          // page boundary is written, so when dividing the available internal flash in half
    803                          // results in a page being split in half, this remedial measure is necessary.
    804                          else if (zlEraseHalfPage() != SUCCESS)
    805                          {
    806                            reply->zlclR_errorCode = EC_CL_NO_MEM;
    807                          }
    808          #endif
    809                          else  {
    810                              zlclientC_t *cmd = (zlclientC_t *)cpc;
    811                              uint8       *cp;
    812          
    813                              // need memory for holding client info, and current send-data cmd
    814                              // do one alloc and set up the pointers
    815                              cp = osal_mem_alloc(sizeof(zlclientC_t)+sizeof(zlmhdr_t)+sizeof(zlsdC_t));
   \                     ??ZLOADApp_handleCommand_22:
   \   0002AC                ; Setup parameters for call to function osal_mem_alloc
   \   0002AC   7A17         MOV     R2,#0x17
   \   0002AE   7B00         MOV     R3,#0x0
   \   0002B0   12....       LCALL   ??osal_mem_alloc?relay
   \   0002B3   8A..         MOV     ?V0 + 4,R2
   \   0002B5   8B..         MOV     ?V0 + 5,R3
   \   0002B7   A8..         MOV     R0,?V0 + 4
   \   0002B9   A9..         MOV     R1,?V0 + 5
    816                              if (!cp)  {
   \   0002BB   E8           MOV     A,R0
   \   0002BC   49           ORL     A,R1
   \   0002BD   7009         JNZ     ??ZLOADApp_handleCommand_23
    817                                  // no more memory. let Commissioner decide what to do. maybe retry later.
    818                                  reply->zlclR_errorCode = EC_CL_NO_MEM;
   \   0002BF   8E82         MOV     DPL,R6
   \   0002C1   8F83         MOV     DPH,R7
   \   0002C3   7442         MOV     A,#0x42
   \   0002C5   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    819                                  break;
    820                              }
    821                              else  {
    822                                  // set up other pointers
    823                                  s_clientInfo  = (zlclientC_t *)cp;
   \                     ??ZLOADApp_handleCommand_23:
   \   0002C8   90....       MOV     DPTR,#s_clientInfo
   \   0002CB   E8           MOV     A,R0
   \   0002CC   F0           MOVX    @DPTR,A
   \   0002CD   A3           INC     DPTR
   \   0002CE   E9           MOV     A,R1
   \   0002CF   F0           MOVX    @DPTR,A
    824                                  s_sdcmd       = (zlmhdr_t *)(cp+sizeof(zlclientC_t));
   \   0002D0   E8           MOV     A,R0
   \   0002D1   2411         ADD     A,#0x11
   \   0002D3   FA           MOV     R2,A
   \   0002D4   E9           MOV     A,R1
   \   0002D5   3400         ADDC    A,#0x0
   \   0002D7   FB           MOV     R3,A
   \   0002D8   90....       MOV     DPTR,#s_sdcmd
   \   0002DB   EA           MOV     A,R2
   \   0002DC   F0           MOVX    @DPTR,A
   \   0002DD   A3           INC     DPTR
   \   0002DE   EB           MOV     A,R3
   \   0002DF   F0           MOVX    @DPTR,A
    825                                  s_sdcpayload  = (zlsdC_t *)(cp+sizeof(zlclientC_t)+sizeof(zlmhdr_t));
   \   0002E0   E8           MOV     A,R0
   \   0002E1   2414         ADD     A,#0x14
   \   0002E3   F8           MOV     R0,A
   \   0002E4   E9           MOV     A,R1
   \   0002E5   3400         ADDC    A,#0x0
   \   0002E7   F9           MOV     R1,A
   \   0002E8   90....       MOV     DPTR,#s_sdcpayload
   \   0002EB   E8           MOV     A,R0
   \   0002EC   F0           MOVX    @DPTR,A
   \   0002ED   A3           INC     DPTR
   \   0002EE   E9           MOV     A,R1
   \   0002EF   F0           MOVX    @DPTR,A
    826                              }
    827          
    828                              // the info on the image to be downloaded and
    829                              // the address of the Server is now saved both here
    830                              // and in persistent memory
    831                              osal_memcpy(s_clientInfo, cpc, sizeof(zlclientC_t));
   \   0002F0                ; Setup parameters for call to function osal_memcpy
   \   0002F0   78..         MOV     R0,#?V0 + 0
   \   0002F2   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0002F5   7C11         MOV     R4,#0x11
   \   0002F7   7D00         MOV     R5,#0x0
   \   0002F9   90....       MOV     DPTR,#s_clientInfo
   \   0002FC   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   0002FF   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000302   12....       LCALL   ?DEALLOC_XSTACK8
    832          
    833                              // populate destination address structure for convenience
    834                              dstAddr.addrMode       = afAddr16Bit;
   \   000305   90....       MOV     DPTR,#dstAddr + 8
   \   000308   7402         MOV     A,#0x2
   \   00030A   F0           MOVX    @DPTR,A
    835                              dstAddr.endPoint       = cmd->zlclC_endp;
   \   00030B   E5..         MOV     A,?V0 + 6
   \   00030D   2410         ADD     A,#0x10
   \   00030F   F582         MOV     DPL,A
   \   000311   E5..         MOV     A,?V0 + 7
   \   000313   3400         ADDC    A,#0x0
   \   000315   F583         MOV     DPH,A
   \   000317   E0           MOVX    A,@DPTR
   \   000318   90....       MOV     DPTR,#dstAddr + 9
   \   00031B   F0           MOVX    @DPTR,A
    836                              osal_memcpy(&dstAddr.addr.shortAddr, &cmd->zlclC_nwk, sizeof(uint16));
   \   00031C                ; Setup parameters for call to function osal_memcpy
   \   00031C   E5..         MOV     A,?V0 + 6
   \   00031E   240E         ADD     A,#0xe
   \   000320   F5..         MOV     ?V0 + 0,A
   \   000322   E5..         MOV     A,?V0 + 7
   \   000324   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000327   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00032A   7C02         MOV     R4,#0x2
   \   00032C   7D00         MOV     R5,#0x0
   \   00032E   7A..         MOV     R2,#dstAddr & 0xff
   \   000330   7B..         MOV     R3,#(dstAddr >> 8) & 0xff
   \   000332   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000335   12....       LCALL   ?DEALLOC_XSTACK8
    837          
    838                              // set event to cause the session to begin
    839                              osal_set_event(oad_app_taskId, ZLOAD_IS_CLIENT_EVT);
   \   000338                ; Setup parameters for call to function osal_set_event
   \   000338   7A02         MOV     R2,#0x2
   \   00033A   7B00         MOV     R3,#0x0
   \   00033C   02....       LJMP    ??ZLOADApp_handleCommand_24 & 0xFFFF
    840                          }
    841                      }
    842          
    843                      break;
    844          
    845                  case ZLMSGID_CODE_ENABLE:
    846                      {
    847                          zlceR_t *reply   = (zlceR_t *)cpr;
    848          
    849                          paylSize = sizeof(zlceR_t);
   \                     ??ZLOADApp_handleCommand_6:
   \   00033F   12....       LCALL   ?Subroutine16 & 0xFFFF
    850          
    851                          reply->zlceR_state = s_State;
    852          
    853          #if defined ZPORT
    854                          // we can enable code if the dongle code itself is being updated.
    855                          if (!s_serialMsg)  {
   \                     ??CrossCallReturnLabel_21:
   \   000342   7009         JNZ     ??ZLOADApp_handleCommand_25
    856                              reply->zlceR_errorCode = EC_CE_NOT_CLIENT;
   \   000344   8E82         MOV     DPL,R6
   \   000346   8F83         MOV     DPH,R7
   \   000348   7455         MOV     A,#0x55
   \   00034A   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    857                          }
    858                          else
    859          #endif
    860                          if (s_State != ZLSTATE_IDLE)  {
   \                     ??ZLOADApp_handleCommand_25:
   \   00034D   90....       MOV     DPTR,#s_State
   \   000350   E0           MOVX    A,@DPTR
   \   000351   6401         XRL     A,#0x1
   \   000353   6009         JZ      ??ZLOADApp_handleCommand_26
    861                              reply->zlceR_errorCode = EC_CE_NOT_IDLE;
   \   000355   8E82         MOV     DPL,R6
   \   000357   8F83         MOV     DPH,R7
   \   000359   7453         MOV     A,#0x53
   \   00035B   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    862                          }
    863                          // see if we're supposed to enable the DL image. spec is in command payload
    864                          // see if there is one...
    865                          else {
    866                            uint8 dlImagePreambleOset;
    867                            osal_nv_read(PREAMBLE_NV_ID, 0, 1, &dlImagePreambleOset);
   \                     ??ZLOADApp_handleCommand_26:
   \   00035E                ; Setup parameters for call to function osal_nv_read
   \   00035E   85..82       MOV     DPL,?XSP + 0
   \   000361   85..83       MOV     DPH,?XSP + 1
   \   000364   8582..       MOV     ?V0 + 0,DPL
   \   000367   8583..       MOV     ?V0 + 1,DPH
   \   00036A   78..         MOV     R0,#?V0 + 0
   \   00036C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00036F   75..01       MOV     ?V0 + 0,#0x1
   \   000372   75..00       MOV     ?V0 + 1,#0x0
   \   000375   78..         MOV     R0,#?V0 + 0
   \   000377   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00037A   7C00         MOV     R4,#0x0
   \   00037C   7D00         MOV     R5,#0x0
   \   00037E   7AFF         MOV     R2,#-0x1
   \   000380   7B0F         MOV     R3,#0xf
   \   000382   12....       LCALL   ??osal_nv_read?relay
   \   000385   7404         MOV     A,#0x4
   \   000387   12....       LCALL   ?DEALLOC_XSTACK8
    868                            HalOADRead(dlImagePreambleOset,(uint8 *)&preamble,sizeof(preamble_t),HAL_OAD_DL);
    869                            if (preamble.vers != 0xFFFF) {
   \   00038A   7407         MOV     A,#0x7
   \   00038C   12....       LCALL   ?XSTACK_DISP0_8
   \   00038F   E0           MOVX    A,@DPTR
   \   000390   F4           CPL     A
   \   000391   7003         JNZ     ??ZLOADApp_handleCommand_27
   \   000393   A3           INC     DPTR
   \   000394   E0           MOVX    A,@DPTR
   \   000395   F4           CPL     A
   \                     ??ZLOADApp_handleCommand_27:
   \   000396   6032         JZ      ??ZLOADApp_handleCommand_28
    870                              // see if they match
    871                              if (!memcmp(cpc, (uint8 *)&preamble.vers, ZL_IMAGE_ID_LENGTH))  {
   \   000398                ; Setup parameters for call to function memcmp
   \   000398   75..06       MOV     ?V0 + 0,#0x6
   \   00039B   78..         MOV     R0,#?V0 + 0
   \   00039D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003A0   7409         MOV     A,#0x9
   \   0003A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A5   AC82         MOV     R4,DPL
   \   0003A7   AD83         MOV     R5,DPH
   \   0003A9   AA..         MOV     R2,?V0 + 6
   \   0003AB   AB..         MOV     R3,?V0 + 7
   \   0003AD   12....       LCALL   ??memcmp?relay
   \   0003B0   7402         MOV     A,#0x2
   \   0003B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0003B5   8B..         MOV     ?V0 + 1,R3
   \   0003B7   EA           MOV     A,R2
   \   0003B8   45..         ORL     A,?V0 + 1
   \   0003BA   8E82         MOV     DPL,R6
   \   0003BC   8F83         MOV     DPH,R7
   \   0003BE   7005         JNZ     ??ZLOADApp_handleCommand_29
    872                                  // DL image there and matches request, see if image is sane.
    873                                  if (SUCCESS == HalOADChkDL(dlImagePreambleOset)) {
    874                                      //set event to cause reset
    875                                      if (SUCCESS != osal_start_timerEx(oad_app_taskId, ZLOAD_CODE_ENABLE_EVT,
    876                                                                        SDC_WAIT_TO_ENABLE))
    877                                      {
    878                                        osal_set_event(oad_app_taskId, ZLOAD_CODE_ENABLE_EVT);
    879                                      }
    880                                      reply->zlceR_errorCode = EC_NO_ERROR;
    881                                  }
    882                                  else  {
    883                                      reply->zlceR_errorCode = EC_CE_IMAGE_INSANE;
   \   0003C0   7454         MOV     A,#0x54
   \   0003C2   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    884                                  }
    885                              }
    886                              else  {
    887                                  // DL image there but doesn't match request
    888                                  reply->zlceR_errorCode = EC_CE_NO_MATCH;
   \                     ??ZLOADApp_handleCommand_29:
   \   0003C5   7452         MOV     A,#0x52
   \                     ??ZLOADApp_handleCommand_30:
   \   0003C7   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    889                              }
    890                            }
    891                            else  {
    892                              // no DL image
    893                              reply->zlceR_errorCode = EC_CE_NO_IMAGE;
   \                     ??ZLOADApp_handleCommand_28:
   \   0003CA   8E82         MOV     DPL,R6
   \   0003CC   8F83         MOV     DPH,R7
   \   0003CE   7451         MOV     A,#0x51
   \   0003D0   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    894                            }
    895                          }
    896                      }
    897                      break;
    898          
    899                  case ZLMSGID_SEND_DATA:
    900          #if defined ZPORT
    901                  {
    902                    zlsdR_t *reply = (zlsdR_t *)cpr;
    903          
    904                    paylSize = sizeof(zlsdR_t);
   \                     ??ZLOADApp_handleCommand_7:
   \   0003D3   75..24       MOV     ?V0 + 3,#0x24
    905          
    906                    // do a sanity check.
    907                    if (s_serialMsg)  {
   \   0003D6   90....       MOV     DPTR,#s_serialMsg
   \   0003D9   E0           MOVX    A,@DPTR
   \   0003DA   6009         JZ      ??ZLOADApp_handleCommand_31
    908                      reply->zlsdR_errorCode = EC_SD_NOT_SERVER;
   \                     ??ZLOADApp_handleCommand_32:
   \   0003DC   8E82         MOV     DPL,R6
   \   0003DE   8F83         MOV     DPH,R7
   \   0003E0   7461         MOV     A,#0x61
   \   0003E2   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    909                    }
    910                    else if (ZLSTATE_PASS_THROUGH == s_State)  {
   \                     ??ZLOADApp_handleCommand_31:
   \   0003E5   90....       MOV     DPTR,#s_State
   \   0003E8   E0           MOVX    A,@DPTR
   \   0003E9   6404         XRL     A,#0x4
   \   0003EB   70EF         JNZ     ??ZLOADApp_handleCommand_32
    911                      // this should be good enough...
    912                      if (s_PTClientInfo.srcAddr.addr.shortAddr != MSGpkt->srcAddr.addr.shortAddr)  {
   \   0003ED   90....       MOV     DPTR,#s_PTClientInfo + 6
   \   0003F0   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0003F3   85..82       MOV     DPL,?V0 + 12
   \   0003F6   85..83       MOV     DPH,?V0 + 13
   \   0003F9   E0           MOVX    A,@DPTR
   \   0003FA   68           XRL     A,R0
   \   0003FB   7003         JNZ     ??ZLOADApp_handleCommand_33
   \   0003FD   A3           INC     DPTR
   \   0003FE   E0           MOVX    A,@DPTR
   \   0003FF   69           XRL     A,R1
   \                     ??ZLOADApp_handleCommand_33:
   \   000400   6009         JZ      ??ZLOADApp_handleCommand_34
    913                          // wrong client -- not the current client
    914                          reply->zlsdR_errorCode = EC_SD_NOT_CLIENT;
   \   000402   8E82         MOV     DPL,R6
   \   000404   8F83         MOV     DPH,R7
   \   000406   7465         MOV     A,#0x65
   \   000408   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    915                      }
    916                      else if (((zlsdC_t *)cpc)->zlsdC_sessionID != s_SessionID)  {
   \                     ??ZLOADApp_handleCommand_34:
   \   00040B   85..82       MOV     DPL,?V0 + 6
   \   00040E   85..83       MOV     DPH,?V0 + 7
   \   000411   A3           INC     DPTR
   \   000412   A3           INC     DPTR
   \   000413   E0           MOVX    A,@DPTR
   \   000414   F8           MOV     R0,A
   \   000415   90....       MOV     DPTR,#s_SessionID
   \   000418   E0           MOVX    A,@DPTR
   \   000419   68           XRL     A,R0
   \   00041A   6008         JZ      ??ZLOADApp_handleCommand_35
    917                          reply->zlsdR_errorCode = EC_SD_BAD_SESS_ID;
   \   00041C   8E82         MOV     DPL,R6
   \   00041E   8F83         MOV     DPH,R7
   \   000420   7462         MOV     A,#0x62
   \   000422   80A3         SJMP    ??ZLOADApp_handleCommand_30
    918                      }
    919                      else  {
    920                          zahdrin_t *zain = zlBuildExternalInboundSerialMSG(&s_PTClientInfo, (uint8 *)msg, sizeof(zlmhdr_t) + sizeof(zlsdC_t));
   \                     ??ZLOADApp_handleCommand_35:
   \   000424                ; Setup parameters for call to function zlBuildExternalInboundSerialMSG
   \   000424   7906         MOV     R1,#0x6
   \   000426   12....       LCALL   ?Subroutine26 & 0xFFFF
    921          
    922                          // forward message to host
    923                          if (zain)  {
   \                     ??CrossCallReturnLabel_36:
   \   000429   6017         JZ      ??ZLOADApp_handleCommand_36
    924                              zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + sizeof(zlsdC_t));
   \   00042B                ; Setup parameters for call to function zlSendSerial
   \   00042B   790C         MOV     R1,#0xc
   \   00042D   12....       LCALL   ??Subroutine41_0 & 0xFFFF
    925                              osal_mem_free(zain);
    926                              // save the AF data. there may be AF parameters we need for the reply
    927                              s_PTClientInfo = *MSGpkt;
   \                     ??CrossCallReturnLabel_82:
   \   000430   85..82       MOV     DPL,?V0 + 10
   \   000433   85..83       MOV     DPH,?V0 + 11
   \   000436   7C..         MOV     R4,#s_PTClientInfo & 0xff
   \   000438   7D..         MOV     R5,#(s_PTClientInfo >> 8) & 0xff
   \   00043A   7423         MOV     A,#0x23
   \   00043C   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    928                              return;
   \   00043F   02....       LJMP    ??ZLOADApp_handleCommand_1 & 0xFFFF
    929                          }
    930                          else  {
    931                              reply->zlsdR_errorCode = EC_SD_NO_MEM;
   \                     ??ZLOADApp_handleCommand_36:
   \   000442   8E82         MOV     DPL,R6
   \   000444   8F83         MOV     DPH,R7
   \   000446   7466         MOV     A,#0x66
   \   000448   02....       LJMP    ??ZLOADApp_handleCommand_13 & 0xFFFF
    932                          }
    933                      }
    934                    }
    935                    else  {
    936                      reply->zlsdR_errorCode = EC_SD_NOT_SERVER;
    937                    }
    938                }
    939          #else
    940                      paylSize = sizeof(zlsdR_t);
    941                      if (s_State != ZLSTATE_SERVER)  {
    942                          // this is the error case when we get a SD before we've started a session
    943                          break;
    944                      }
    945                      s_sdrpayload->zlsdR_state = s_State;
    946                      buf = (uint8 *)s_sdreply;
    947                      if (((zlsdC_t *)cpc)->zlsdC_sessionID != s_SessionID)  {
    948                          s_sdrpayload->zlsdR_errorCode = EC_SD_BAD_SESS_ID;
    949                      }
    950                      else  {
    951                          // set error code first. it might get reset in the processing routine
    952                          s_sdrpayload->zlsdR_errorCode = EC_NO_ERROR;
    953                          // process the command
    954                          zlProcessSDC((zlsdC_t *)cpc);
    955                      }
    956          #endif
    957                      break;
    958          
    959                  case ZLMSGID_RESET:
    960          #if defined ZPORT
    961                      // always legal if over serial port
    962                      if (!s_serialMsg)  {
   \                     ??ZLOADApp_handleCommand_8:
   \   00044B   90....       MOV     DPTR,#s_serialMsg
   \   00044E   E0           MOVX    A,@DPTR
   \   00044F   7003         JNZ     $+5
   \   000451   02....       LJMP    ??ZLOADApp_handleCommand_1 & 0xFFFF
    963                          return;
    964                      }
    965                      else  
    966          #endif
    967                      {
    968                          zlrstR_t *reply = (zlrstR_t *)cpr;
    969          
    970                          reply->zlrstR_state     = s_State;
   \   000454   12....       LCALL   ?Subroutine4 & 0xFFFF
    971                          reply->zlrstR_errorCode = EC_NO_ERROR;
    972                      }
    973                      paylSize = sizeof(zlrstR_t);
   \                     ??CrossCallReturnLabel_6:
   \   000457   75..02       MOV     ?V0 + 3,#0x2
    974                      osal_set_event(oad_app_taskId, ZLOAD_RESET_EVT);
   \   00045A                ; Setup parameters for call to function osal_set_event
   \   00045A   7A08         MOV     R2,#0x8
   \   00045C   FB           MOV     R3,A
   \                     ??ZLOADApp_handleCommand_24:
   \   00045D   12....       LCALL   ??Subroutine39_0 & 0xFFFF
    975                      break;
    976          
    977                  default:
    978                      return;
    979              }
    980          
    981              // the case above has filled in the payload. the header is the
    982              // same for all. go ahead and fill in header and send reply
    983              {
    984                  zlmhdr_t *hdr = (zlmhdr_t *)buf;
   \                     ??CrossCallReturnLabel_75:
   \   000460   90....       MOV     DPTR,#??buf
   \   000463   12....       LCALL   ?Subroutine20 & 0xFFFF
    985          
    986                  hdr->zlhdr_msgid  = msg->zlhdr_msgid | ZLMSGID_REPLY_BIT;
   \                     ??CrossCallReturnLabel_29:
   \   000466   85..82       MOV     DPL,?V0 + 8
   \   000469   85..83       MOV     DPH,?V0 + 9
   \   00046C   E0           MOVX    A,@DPTR
   \   00046D   4480         ORL     A,#0x80
   \   00046F   8A82         MOV     DPL,R2
   \   000471   8B83         MOV     DPH,R3
   \   000473   F0           MOVX    @DPTR,A
    987                  hdr->zlhdr_seqnum = msg->zlhdr_seqnum;
   \   000474   85..82       MOV     DPL,?V0 + 14
   \   000477   85..83       MOV     DPH,?V0 + 15
   \   00047A   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00047D   12....       LCALL   ?Subroutine29 & 0xFFFF
    988                  hdr->zlhdr_msglen = paylSize;
   \                     ??CrossCallReturnLabel_41:
   \   000480   E5..         MOV     A,?V0 + 3
   \   000482   F0           MOVX    @DPTR,A
    989          
    990          #if defined ZPORT
    991                  if (!s_serialMsg)  {
   \   000483   90....       MOV     DPTR,#s_serialMsg
   \   000486   E0           MOVX    A,@DPTR
   \   000487   7051         JNZ     ??ZLOADApp_handleCommand_37
    992          #endif
    993                  AF_DataRequest( &MSGpkt->srcAddr,
    994                                   afFindEndPointDesc( MSGpkt->endPoint),
    995                                   MSGpkt->clusterId,
    996                                   sizeof(zlmhdr_t) + paylSize, buf,
    997                                  &MSGpkt->cmd.TransSeqNumber,
    998                                   AF_DISCV_ROUTE, AF_DEFAULT_RADIUS );
   \   000489                ; Setup parameters for call to function afFindEndPointDesc
   \   000489   E5..         MOV     A,?V0 + 10
   \   00048B   2414         ADD     A,#0x14
   \   00048D   F582         MOV     DPL,A
   \   00048F   E5..         MOV     A,?V0 + 11
   \   000491   3400         ADDC    A,#0x0
   \   000493   F583         MOV     DPH,A
   \   000495   12....       LCALL   ??Subroutine40_0 & 0xFFFF
    999          #if defined ZPORT
   1000                  } else  {
   \                     ??CrossCallReturnLabel_80:
   \   000498   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00049B   E5..         MOV     A,?V0 + 10
   \   00049D   241E         ADD     A,#0x1e
   \   00049F   F5..         MOV     ?V0 + 0,A
   \   0004A1   E5..         MOV     A,?V0 + 11
   \   0004A3   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0004A6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0004A9   90....       MOV     DPTR,#??buf
   \   0004AC   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0004AF   85....       MOV     ?V0 + 0,?V0 + 3
   \   0004B2   E5..         MOV     A,?V0 + 0
   \   0004B4   2403         ADD     A,#0x3
   \   0004B6   F5..         MOV     ?V0 + 0,A
   \   0004B8   E4           CLR     A
   \   0004B9   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0004BC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0004BF   85..82       MOV     DPL,?V0 + 10
   \   0004C2   85..83       MOV     DPH,?V0 + 11
   \   0004C5   A3           INC     DPTR
   \   0004C6   A3           INC     DPTR
   \   0004C7   A3           INC     DPTR
   \   0004C8   A3           INC     DPTR
   \   0004C9   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0004CC   7920         MOV     R1,#0x20
   \   0004CE   AA..         MOV     R2,?V0 + 12
   \   0004D0   AB..         MOV     R3,?V0 + 13
   \   0004D2   12....       LCALL   ??Subroutine42_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0004D5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0004D8   8023         SJMP    ??ZLOADApp_handleCommand_1
   1001                      zahdrin_t *zain = zlBuildInternalInboundSerialMSG((uint8 *)hdr, sizeof(zlmhdr_t) + paylSize);
   \                     ??ZLOADApp_handleCommand_37:
   \   0004DA                ; Setup parameters for call to function zlBuildInternalInboundSerialMSG
   \   0004DA   7403         MOV     A,#0x3
   \   0004DC   25..         ADD     A,?V0 + 3
   \   0004DE   F9           MOV     R1,A
   \   0004DF   12....       LCALL   ??zlBuildInternalInboundSerialMSG?relay
   \   0004E2   8A..         MOV     ?V0 + 0,R2
   \   0004E4   8B..         MOV     ?V0 + 1,R3
   \   0004E6   AE..         MOV     R6,?V0 + 0
   \   0004E8   AF..         MOV     R7,?V0 + 1
   1002          
   1003                      if (zain)  {
   \   0004EA   EE           MOV     A,R6
   \   0004EB   4F           ORL     A,R7
   \   0004EC   600F         JZ      ??ZLOADApp_handleCommand_1
   1004                          zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + paylSize);
   \   0004EE                ; Setup parameters for call to function zlSendSerial
   \   0004EE   7409         MOV     A,#0x9
   \   0004F0   25..         ADD     A,?V0 + 3
   \   0004F2   F9           MOV     R1,A
   \   0004F3   12....       LCALL   ??zlSendSerial?relay
   1005                          osal_mem_free(zain);
   \   0004F6                ; Setup parameters for call to function osal_mem_free
   \   0004F6   EE           MOV     A,R6
   \   0004F7   FA           MOV     R2,A
   \   0004F8   EF           MOV     A,R7
   \   0004F9   FB           MOV     R3,A
   \                     ??ZLOADApp_handleCommand_20:
   \   0004FA   12....       LCALL   ??osal_mem_free?relay
   \                     ??ZLOADApp_handleCommand_1:
   \   0004FD   740D         MOV     A,#0xd
   \   0004FF   12....       LCALL   ?DEALLOC_XSTACK8
   \   000502   7F10         MOV     R7,#0x10
   \   000504   02....       LJMP    ?BANKED_LEAVE_XDATA
   1006                      }
   1007                  }
   1008          #else
   1009                  if ((buf != NULL) && 
   1010                     ((msg->zlhdr_msgid != ZLMSGID_SEND_DATA) || (s_State != ZLSTATE_SERVER)))
   1011                  {
   1012                    osal_mem_free(buf);
   1013                  }
   1014          #endif
   1015              }
   1016          
   1017              return;
   1018          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F5..         MOV     ?V0 + 1,A
   \   000004   78..         MOV     R0,#?V0 + 0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   AC..         MOV     R4,?V0 + 8
   \   000002   AD..         MOV     R5,?V0 + 9
   \   000004   7A..         MOV     R2,#s_PTClientInfo & 0xff
   \   000006   7B..         MOV     R3,#(s_PTClientInfo >> 8) & 0xff
   \   000008   12....       LCALL   ??zlBuildExternalInboundSerialMSG?relay
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   EA           MOV     A,R2
   \   000010   45..         ORL     A,?V0 + 1
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   75..02       MOV     ?V0 + 3,#0x2
   \   000003   90....       MOV     DPTR,#s_State
   \   000006   E0           MOVX    A,@DPTR
   \   000007   85..82       MOV     DPL,?V0 + 4
   \   00000A   85..83       MOV     DPH,?V0 + 5
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   90....       MOV     DPTR,#s_serialMsg
   \   000011   E0           MOVX    A,@DPTR
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   90....       MOV     DPTR,#s_State
   \   000003   E0           MOVX    A,@DPTR
   \   000004   85..82       MOV     DPL,?V0 + 4
   \   000007   85..83       MOV     DPH,?V0 + 5
   \   00000A   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   7A04         MOV     R2,#0x4
   \   000002                REQUIRE ??Subroutine38_0
   \   000002                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??afFindEndPointDesc?relay
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   AC..         MOV     R4,?V0 + 0
   \   00000B   AD..         MOV     R5,?V0 + 1
   \   00000D                ; Setup parameters for call to function AF_DataRequest
   \   00000D                ; Setup parameters for call to function AF_DataRequest
   \   00000D                ; Setup parameters for call to function AF_DataRequest
   \   00000D                ; Setup parameters for call to function AF_DataRequest
   \   00000D   75..1E       MOV     ?V0 + 0,#0x1e
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   7910         MOV     R1,#0x10
   \   000002                REQUIRE ??Subroutine41_0
   \   000002                ; // Fall through to label ??Subroutine41_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   12....       LCALL   ??zlSendSerial?relay
   \   000003                ; Setup parameters for call to function osal_mem_free
   \   000003                ; Setup parameters for call to function osal_mem_free
   \   000003                ; Setup parameters for call to function osal_mem_free
   \   000003   AA..         MOV     R2,?V0 + 0
   \   000005   AB..         MOV     R3,?V0 + 1
   \   000007   12....       LCALL   ??osal_mem_free?relay
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   12....       LCALL   ??AF_DataRequest?relay
   \   000003   7409         MOV     A,#0x9
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FB           MOV     R3,A
   \   000003                REQUIRE ??Subroutine44_0
   \   000003                ; // Fall through to label ??Subroutine44_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??buf:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
   1019          
   1020          #if !defined ZPORT
   1021          /**********************************************************************************
   1022           * @fn      zlProcessSDC
   1023           *
   1024           * @brief   Process the SDC command.
   1025           *
   1026           * @param   cmd - A valid alsdC_t structure with valid data.
   1027           *
   1028           * @return  none
   1029           */
   1030          static void zlProcessSDC(zlsdC_t *cmd)
   1031          {
   1032            uint16 reqPktNum;
   1033            osal_memcpy(&reqPktNum, &cmd->zlsdC_pktNum, sizeof(uint16));
   1034          
   1035            // if the requested packet is the previous one the Client didn't get the
   1036            // transmission for some reason. just resend the previous one. the data
   1037            // are already in there. if we never got the command this test will fail.
   1038            if (s_NextPacket && (reqPktNum == (s_NextPacket-1)))  {
   1039                return;
   1040            }
   1041          
   1042            // make sure the request is otherwise valid
   1043            if (!zlIsReqPacketNumOK(reqPktNum))  {
   1044                s_sdrpayload->zlsdR_errorCode = EC_SD_BAD_PKT_NUM;
   1045                return;
   1046            }
   1047          
   1048            // Read data into reply buffer.
   1049            HalOADRead((uint32)s_NextPacket * s_blkSize, s_sdrpayload->zlsdR_data,
   1050                                              ZL_DATA_BLK_SIZE*ZL_NUM_DATA_BLKS, s_itype);
   1051          
   1052            // set packet number in reply
   1053            osal_memcpy(&s_sdrpayload->zlsdR_pktNum, &reqPktNum, sizeof(uint16));
   1054            s_NextPacket++;
   1055          }
   1056          
   1057          /**********************************************************************************
   1058           * @fn      zlIsReqPacketNumOK
   1059           *
   1060           * @brief   Check validity of resquested packet number as Server
   1061           *
   1062           * @param   input
   1063           *            reqNum  requested packet number
   1064           *
   1065           * @return  0: packet number request illegal
   1066           *          1: packet number request is valid
   1067           */
   1068          static uint8 zlIsReqPacketNumOK(uint16 reqNum)
   1069          {
   1070              if (reqNum >= s_NumPktGet) {
   1071                  return 0;
   1072              }
   1073              return 1;
   1074          }
   1075          #endif
   1076          
   1077          /**********************************************************************************
   1078           * @fn      ZLOADApp_handleReply
   1079           *
   1080           * @brief   Handle a normal ZLOAD reply
   1081           *
   1082           * @param   input
   1083           *            msg pointer to ZLOAD message
   1084           *
   1085           * @return  none.
   1086           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1087          static void ZLOADApp_handleReply(afIncomingMSGPacket_t *MSGpkt, zlmhdr_t *msg)
   \                     ZLOADApp_handleReply:
   1088          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 2,R4
   \   00000C   8D..         MOV     ?V0 + 3,R5
   1089            uint8    *cpr;
   1090          #if defined ZPORT
   1091            uint8 msgSize = 0;
   1092          #endif
   1093          
   1094          #if !defined ZPORT
   1095            // right reply?
   1096            if (s_firstTx)  {
   1097                s_firstTx = 0;
   1098            }
   1099            else  {
   1100              if (msg->zlhdr_seqnum != s_lastTxSeqNum)  {
   1101                return;
   1102              }
   1103              if (msg->zlhdr_seqnum == s_lastSeen)  {
   1104                // duplicate reply to a resend
   1105                return;
   1106              }
   1107            }
   1108            s_lastSeen = msg->zlhdr_seqnum;
   1109          #endif
   1110          
   1111            cpr = (uint8 *)msg + sizeof(zlmhdr_t);   // offset of reply payload
   \   00000E   EC           MOV     A,R4
   \   00000F   2403         ADD     A,#0x3
   \   000011   ED           MOV     A,R5
   \   000012   3400         ADDC    A,#0x0
   \   000014   0C           INC     R4
   \   000015   0C           INC     R4
   \   000016   0C           INC     R4
   \   000017   FD           MOV     R5,A
   1112          
   1113            // generate replies to commands here. reply may generate another command out, for
   1114            // example, if data are being transfered and the dvice is acting as client.
   1115            // Commands handled here. replies in next routine
   1116          
   1117            // ignore reply bit on switch()
   1118            switch (msg->zlhdr_msgid & (0xFF ^ ZLMSGID_REPLY_BIT))  {
   \   000018   8C82         MOV     DPL,R4
   \   00001A   8D83         MOV     DPH,R5
   \   00001C   A3           INC     DPTR
   \   00001D   AE82         MOV     R6,DPL
   \   00001F   AF83         MOV     R7,DPH
   \   000021   EC           MOV     A,R4
   \   000022   2402         ADD     A,#0x2
   \   000024   F5..         MOV     ?V0 + 0,A
   \   000026   ED           MOV     A,R5
   \   000027   3400         ADDC    A,#0x0
   \   000029   F5..         MOV     ?V0 + 1,A
   \   00002B   85..82       MOV     DPL,?V0 + 2
   \   00002E   85..83       MOV     DPH,?V0 + 3
   \   000031   E0           MOVX    A,@DPTR
   \   000032   547F         ANL     A,#0x7f
   \   000034   14           DEC     A
   \   000035   601B         JZ      ??ZLOADApp_handleReply_0
   \   000037   14           DEC     A
   \   000038   6050         JZ      ??ZLOADApp_handleReply_1
   \   00003A   14           DEC     A
   \   00003B   7003         JNZ     $+5
   \   00003D   02....       LJMP    ??ZLOADApp_handleReply_2 & 0xFFFF
   \   000040   14           DEC     A
   \   000041   6014         JZ      ??ZLOADApp_handleReply_3
   \   000043   14           DEC     A
   \   000044   6011         JZ      ??ZLOADApp_handleReply_3
   \   000046   14           DEC     A
   \   000047   7003         JNZ     $+5
   \   000049   02....       LJMP    ??ZLOADApp_handleReply_4 & 0xFFFF
   \   00004C   14           DEC     A
   \   00004D   6008         JZ      ??ZLOADApp_handleReply_3
   \   00004F   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1119            case ZLMSGID_STATUSQ:
   1120          #if defined ZPORT
   1121              msgSize = 20;
   \                     ??ZLOADApp_handleReply_0:
   \   000052   75..14       MOV     ?V0 + 0,#0x14
   \   000055   8003         SJMP    ??ZLOADApp_handleReply_6
   1122              //  * * *  NO BREAK  * * *
   1123            case ZLMSGID_CLIENT_CMD:
   1124            case ZLMSGID_RESET:
   1125            case ZLMSGID_CODE_ENABLE:
   1126              if (!msgSize)  {
   1127                msgSize = 2;
   \                     ??ZLOADApp_handleReply_3:
   \   000057   75..02       MOV     ?V0 + 0,#0x2
   1128              }
   1129              // right now, only the host could have sent these -- the dongle never sends these
   1130              // commands on its own. it's a proxy reply. forward it on...
   1131              if (!s_serialMsg)  {
   \                     ??ZLOADApp_handleReply_6:
   \   00005A   90....       MOV     DPTR,#s_serialMsg
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6003         JZ      $+5
   \   000060   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1132                zahdrin_t *zain = zlBuildExternalInboundSerialMSG(MSGpkt, (uint8 *)msg, sizeof(zlmhdr_t) + msgSize);
   \   000063                ; Setup parameters for call to function zlBuildExternalInboundSerialMSG
   \   000063   7403         MOV     A,#0x3
   \   000065   25..         ADD     A,?V0 + 0
   \   000067   F9           MOV     R1,A
   \   000068   1C           DEC     R4
   \   000069   1C           DEC     R4
   \   00006A   1C           DEC     R4
   \   00006B   AD..         MOV     R5,?V0 + 3
   \   00006D   12....       LCALL   ??zlBuildExternalInboundSerialMSG?relay
   \   000070   8A..         MOV     ?V0 + 2,R2
   \   000072   8B..         MOV     ?V0 + 3,R3
   \   000074   AE..         MOV     R6,?V0 + 2
   \   000076   AF..         MOV     R7,?V0 + 3
   1133          
   1134                if (zain)  {
   \   000078   EE           MOV     A,R6
   \   000079   4F           ORL     A,R7
   \   00007A   7003         JNZ     $+5
   \   00007C   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1135                  zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + msgSize);
   \   00007F                ; Setup parameters for call to function zlSendSerial
   \   00007F   7409         MOV     A,#0x9
   \   000081   25..         ADD     A,?V0 + 0
   \   000083   F9           MOV     R1,A
   \   000084   12....       LCALL   ?Subroutine23 & 0xFFFF
   1136                  osal_mem_free(zain);
   1137                }
   1138              }
   \                     ??CrossCallReturnLabel_31:
   \   000087   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1139          #endif
   1140              break;
   1141          
   1142            case ZLMSGID_SESSION_START:
   1143          #if defined ZPORT
   1144                      // this can happen both in pass-through and client mode -- the dongle could be
   1145                      // getting updated firmware and is the client receiving the start session reply.
   1146                      // in any case we cannot get this reply over air. it has to have come from the Host
   1147                      if (!s_serialMsg)  {
   \                     ??ZLOADApp_handleReply_1:
   \   00008A   90....       MOV     DPTR,#s_serialMsg
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   7003         JNZ     $+5
   \   000090   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1148                          break;
   1149                      }
   1150                      else if (ZLSTATE_PASS_THROUGH == s_State) {
   \   000093   90....       MOV     DPTR,#s_State
   \   000096   E0           MOVX    A,@DPTR
   \   000097   6404         XRL     A,#0x4
   \   000099   7028         JNZ     ??ZLOADApp_handleReply_7
   1151                          // pass reply back to original client
   1152                          msg->zlhdr_seqnum = s_PTSeqNum;
   \   00009B   90....       MOV     DPTR,#s_PTSeqNum
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   85..82       MOV     DPL,?V0 + 2
   \   0000A2   85..83       MOV     DPH,?V0 + 3
   \   0000A5   A3           INC     DPTR
   \   0000A6   F0           MOVX    @DPTR,A
   1153                          AF_DataRequest( &s_PTClientInfo.srcAddr,
   1154                             afFindEndPointDesc( s_PTClientInfo.endPoint ),
   1155                             s_PTClientInfo.clusterId,
   1156                             sizeof(zlmhdr_t) + sizeof(zlbegsessR_t), (uint8 *)msg,
   1157                             &s_PTClientInfo.cmd.TransSeqNumber,
   1158                             AF_TX_OPTIONS_NONE, AF_DEFAULT_RADIUS );
   \   0000A7                ; Setup parameters for call to function afFindEndPointDesc
   \   0000A7   12....       LCALL   ?Subroutine10 & 0xFFFF
   1159                      }
   \                     ??CrossCallReturnLabel_77:
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AD   75....       MOV     ?V0 + 0,#(s_PTClientInfo + 30) & 0xff
   \   0000B0   75....       MOV     ?V0 + 1,#((s_PTClientInfo + 30) >> 8) & 0xff
   \   0000B3   78..         MOV     R0,#?V0 + 0
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B8   78..         MOV     R0,#?V0 + 2
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BD   75..0C       MOV     ?V0 + 0,#0xc
   \   0000C0   02....       LJMP    ??ZLOADApp_handleReply_8 & 0xFFFF
   1160                      else if (((zlbegsessR_t *)cpr)->zlbsR_errorCode)  {
   \                     ??ZLOADApp_handleReply_7:
   \   0000C3   8E82         MOV     DPL,R6
   \   0000C5   8F83         MOV     DPH,R7
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   6008         JZ      ??ZLOADApp_handleReply_9
   1161                          // Server rejected the real client session. back to Idle state.
   1162                          osal_set_event(oad_app_taskId, ZLOAD_RESET_EVT);
   \   0000CA                ; Setup parameters for call to function osal_set_event
   \   0000CA   7A08         MOV     R2,#0x8
   1163                      }
   \                     ??ZLOADApp_handleReply_10:
   \   0000CC   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000CF   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1164                      // reply from Server to Begin Session command from Client
   1165                      else if (ZLSTATE_CLIENT != s_State) {
   \                     ??ZLOADApp_handleReply_9:
   \   0000D2   90....       MOV     DPTR,#s_State
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   6402         XRL     A,#0x2
   \   0000D8   6003         JZ      $+5
   \   0000DA   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1166                          // I didn't send it...ignore.
   1167                          break;
   1168                      }
   1169          #else
   1170          
   1171          		    // reply from Server to Begin Session command from Client
   1172          		    if (s_State != ZLSTATE_CLIENT) {
   1173          				// I didn't send it...ignore.
   1174          				break;
   1175          			}
   1176                else if (((zlbegsessR_t *)cpr)->zlbsR_errorCode)  {
   1177                  // Server rejected the session. back to Idle state.
   1178                  osal_set_event(oad_app_taskId, ZLOAD_RESET_EVT);
   1179                }
   1180          #endif
   1181                else  {
   1182                  // get length and make sure we have room
   1183                  uint32 imglen = ((zlbegsessR_t *)cpr)->zlbsR_imgLen;
   \   0000DD   85..82       MOV     DPL,?V0 + 0
   \   0000E0   85..83       MOV     DPH,?V0 + 1
   \   0000E3   78..         MOV     R0,#?V0 + 0
   \   0000E5   12....       LCALL   ?L_MOV_X
   1184          
   1185                  if (imglen > HalOADAvail()) {
   \   0000E8   90....       MOV     DPTR,#__Constant_3a801
   \   0000EB   78..         MOV     R0,#?V0 + 0
   \   0000ED   12....       LCALL   ?UL_GE_X
   \   0000F0   5004         JNC     ??ZLOADApp_handleReply_11
   1186                    // no room. terminate session
   1187                    osal_set_event(oad_app_taskId, ZLOAD_XFER_DONE_EVT);
   \                     ??ZLOADApp_handleReply_12:
   \   0000F2                ; Setup parameters for call to function osal_set_event
   \   0000F2   7A04         MOV     R2,#0x4
   \   0000F4   80D6         SJMP    ??ZLOADApp_handleReply_10
   1188                  }
   1189                  else  {
   1190                    // TODO: The OAD Dongle Tool is broken and passes the wrong offset.
   1191                    //uint8 dlImagePreambleOffset = ((zlbegsessR_t *)cpr)->zlbsR_preambleOffset;
   1192                    //osal_nv_write(PREAMBLE_NV_ID, 0, 1, &dlImagePreambleOffset);
   1193          
   1194                    s_blkSize  = ((zlbegsessR_t *)cpr)->zlbsR_blkSize;
   1195                    s_blkSize *= ((zlbegsessR_t *)cpr)->zlbsR_numBlks;
   \                     ??ZLOADApp_handleReply_11:
   \   0000F6   8C82         MOV     DPL,R4
   \   0000F8   8D83         MOV     DPH,R5
   \   0000FA   A3           INC     DPTR
   \   0000FB   A3           INC     DPTR
   \   0000FC   A3           INC     DPTR
   \   0000FD   A3           INC     DPTR
   \   0000FE   A3           INC     DPTR
   \   0000FF   A3           INC     DPTR
   \   000100   A3           INC     DPTR
   \   000101   E0           MOVX    A,@DPTR
   \   000102   F5F0         MOV     B,A
   \   000104   8C82         MOV     DPL,R4
   \   000106   8D83         MOV     DPH,R5
   \   000108   A3           INC     DPTR
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   A3           INC     DPTR
   \   00010D   A3           INC     DPTR
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   A4           MUL     AB
   \   000110   90....       MOV     DPTR,#s_blkSize
   \   000113   F0           MOVX    @DPTR,A
   1196          
   1197                    // figure out how many data packets to request.
   1198                    s_NumPktGet   = (imglen+(s_blkSize-1)) / s_blkSize;
   \   000114   24FF         ADD     A,#-0x1
   \   000116   F5..         MOV     ?V0 + 4,A
   \   000118   E4           CLR     A
   \   000119   34FF         ADDC    A,#-0x1
   \   00011B   F5..         MOV     ?V0 + 5,A
   \   00011D   33           RLC     A
   \   00011E   95E0         SUBB    A,0xE0 /* A   */
   \   000120   F5..         MOV     ?V0 + 6,A
   \   000122   F5..         MOV     ?V0 + 7,A
   \   000124   78..         MOV     R0,#?V0 + 0
   \   000126   79..         MOV     R1,#?V0 + 4
   \   000128   12....       LCALL   ?L_ADD
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   F5..         MOV     ?V0 + 4,A
   \   00012E   E4           CLR     A
   \   00012F   F5..         MOV     ?V0 + 5,A
   \   000131   F5..         MOV     ?V0 + 6,A
   \   000133   F5..         MOV     ?V0 + 7,A
   \   000135   78..         MOV     R0,#?V0 + 0
   \   000137   79..         MOV     R1,#?V0 + 4
   \   000139   12....       LCALL   ?UL_DIV_MOD
   \   00013C   90....       MOV     DPTR,#s_NumPktGet
   \   00013F   E5..         MOV     A,?V0 + 0
   \   000141   F0           MOVX    @DPTR,A
   \   000142   A3           INC     DPTR
   \   000143   E5..         MOV     A,?V0 + 1
   \   000145   F0           MOVX    @DPTR,A
   1199                    s_NextPacket  = 0;
   \   000146   90....       MOV     DPTR,#s_NextPacket
   \   000149   E4           CLR     A
   \   00014A   F0           MOVX    @DPTR,A
   \   00014B   A3           INC     DPTR
   \                     ??ZLOADApp_handleReply_13:
   \   00014C   F0           MOVX    @DPTR,A
   1200                    // request "next" (i.e., first) packet
   1201                    zlRequestNextDataPacket();
   \   00014D                ; Setup parameters for call to function zlRequestNextDataPacket
   \   00014D   12....       LCALL   ??zlRequestNextDataPacket?relay
   \   000150   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1202                  }
   1203                }
   1204                break;
   1205          
   1206            case ZLMSGID_SESSION_TERM:
   1207          #if defined ZPORT
   1208                      // pass it back if we're in pass-through mode
   1209                    if (s_serialMsg && (ZLSTATE_PASS_THROUGH == s_State))  {
   \                     ??ZLOADApp_handleReply_2:
   \   000153   90....       MOV     DPTR,#s_serialMsg
   \   000156   E0           MOVX    A,@DPTR
   \   000157   7003         JNZ     $+5
   \   000159   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   \   00015C   90....       MOV     DPTR,#s_State
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   6404         XRL     A,#0x4
   \   000162   6003         JZ      $+5
   \   000164   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1210                        AF_DataRequest( &s_PTClientInfo.srcAddr,
   1211                           afFindEndPointDesc( s_PTClientInfo.endPoint),
   1212                           s_PTClientInfo.clusterId,
   1213                           sizeof(zlmhdr_t) + sizeof(zlendsessR_t), (uint8 *)msg,
   1214                           &s_PTClientInfo.cmd.TransSeqNumber,
   1215                           AF_TX_OPTIONS_NONE, AF_DEFAULT_RADIUS );
   \   000167                ; Setup parameters for call to function afFindEndPointDesc
   \   000167   12....       LCALL   ?Subroutine10 & 0xFFFF
   1216                        // in any case, clean up
   1217                        osal_set_event(oad_app_taskId, ZLOAD_XFER_DONE_EVT);
   1218                      }
   \                     ??CrossCallReturnLabel_78:
   \   00016A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016D   75....       MOV     ?V0 + 0,#(s_PTClientInfo + 30) & 0xff
   \   000170   75....       MOV     ?V0 + 1,#((s_PTClientInfo + 30) >> 8) & 0xff
   \   000173   78..         MOV     R0,#?V0 + 0
   \   000175   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000178   78..         MOV     R0,#?V0 + 2
   \   00017A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017D   75..05       MOV     ?V0 + 0,#0x5
   \   000180   75..00       MOV     ?V0 + 1,#0x0
   \   000183   78..         MOV     R0,#?V0 + 0
   \   000185   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000188   90....       MOV     DPTR,#s_PTClientInfo + 4
   \   00018B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00018E   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000191   12....       LCALL   ?DEALLOC_XSTACK8
   \   000194   02....       LJMP    ??ZLOADApp_handleReply_12 & 0xFFFF
   1219          #else
   1220                      // don't care. right now the Commisioner can't be
   1221                      // the client so it will never get a reply to the
   1222                      // terminate session command because it can't send
   1223                      // that command.
   1224          #endif
   1225                      break;
   1226          
   1227            case ZLMSGID_SEND_DATA:
   1228          #if defined ZPORT
   1229                      if (!s_serialMsg)  {
   \                     ??ZLOADApp_handleReply_4:
   \   000197   90....       MOV     DPTR,#s_serialMsg
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   7003         JNZ     $+5
   \   00019D   02....       LJMP    ??ZLOADApp_handleReply_5 & 0xFFFF
   1230                          // reply should not be over air
   1231                          break;
   1232                      }
   1233                      else if (ZLSTATE_CLIENT == s_State)  {
   \   0001A0   90....       MOV     DPTR,#s_State
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   6402         XRL     A,#0x2
   \   0001A6   7052         JNZ     ??ZLOADApp_handleReply_14
   1234                          // not a don't care if we're in client state
   1235                          zlProcessSDR((zlsdR_t *)cpr);
   \   0001A8                ; Setup parameters for call to function osal_memcpy
   \   0001A8   75..00       MOV     ?V0 + 2,#0x0
   \   0001AB   78..         MOV     R0,#?V0 + 0
   \   0001AD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001B0   7C02         MOV     R4,#0x2
   \   0001B2   7D00         MOV     R5,#0x0
   \   0001B4   7403         MOV     A,#0x3
   \   0001B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B9   AA82         MOV     R2,DPL
   \   0001BB   AB83         MOV     R3,DPH
   \   0001BD   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   1236                      }
   \                     ??CrossCallReturnLabel_100:
   \   0001C0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C3   85..82       MOV     DPL,?XSP + 0
   \   0001C6   85..83       MOV     DPH,?XSP + 1
   \   0001C9   C082         PUSH    DPL
   \   0001CB   C083         PUSH    DPH
   \   0001CD   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0001D0   D083         POP     DPH
   \   0001D2   D082         POP     DPL
   \   0001D4   C3           CLR     C
   \   0001D5   E0           MOVX    A,@DPTR
   \   0001D6   98           SUBB    A,R0
   \   0001D7   A3           INC     DPTR
   \   0001D8   E0           MOVX    A,@DPTR
   \   0001D9   99           SUBB    A,R1
   \   0001DA   4050         JC      ??ZLOADApp_handleReply_5
   \   0001DC   85..82       MOV     DPL,?XSP + 0
   \   0001DF   85..83       MOV     DPH,?XSP + 1
   \   0001E2   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   0001E5   5003         JNC     $+5
   \   0001E7   02....       LJMP    ??ZLOADApp_handleReply_12 & 0xFFFF
   \   0001EA   8E82         MOV     DPL,R6
   \   0001EC   8F83         MOV     DPH,R7
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   703B         JNZ     ??ZLOADApp_handleReply_5
   \   0001F1   90....       MOV     DPTR,#s_NextPacket
   \   0001F4   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0001F7   02....       LJMP    ??ZLOADApp_handleReply_13 & 0xFFFF
   1237                      else if (ZLSTATE_PASS_THROUGH == s_State)  {
   \                     ??ZLOADApp_handleReply_14:
   \   0001FA   E0           MOVX    A,@DPTR
   \   0001FB   6404         XRL     A,#0x4
   \   0001FD   702D         JNZ     ??ZLOADApp_handleReply_5
   1238                          // forward to client
   1239                          AF_DataRequest( &s_PTClientInfo.srcAddr,
   1240                             afFindEndPointDesc( s_PTClientInfo.endPoint),
   1241                             s_PTClientInfo.clusterId,
   1242                             sizeof(zlmhdr_t) + sizeof(zlsdR_t), (uint8 *)msg,
   1243                             &s_PTClientInfo.cmd.TransSeqNumber,
   1244                             AF_TX_OPTIONS_NONE, AF_DEFAULT_RADIUS );
   \   0001FF                ; Setup parameters for call to function afFindEndPointDesc
   \   0001FF   12....       LCALL   ?Subroutine10 & 0xFFFF
   1245                      }
   1246          #else
   1247                      // not a don't care if we're in client state
   1248                      if (s_State == ZLSTATE_CLIENT)  {
   1249                          zlProcessSDR((zlsdR_t *)cpr);
   1250                      }
   1251          #endif
   1252                      break;
   1253          
   1254            default:
   1255                      // don't care
   1256                      break;
   1257            }
   \                     ??CrossCallReturnLabel_79:
   \   000202   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000205   75....       MOV     ?V0 + 0,#(s_PTClientInfo + 30) & 0xff
   \   000208   75....       MOV     ?V0 + 1,#((s_PTClientInfo + 30) >> 8) & 0xff
   \   00020B   78..         MOV     R0,#?V0 + 0
   \   00020D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000210   78..         MOV     R0,#?V0 + 2
   \   000212   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000215   75..27       MOV     ?V0 + 0,#0x27
   \                     ??ZLOADApp_handleReply_8:
   \   000218   75..00       MOV     ?V0 + 1,#0x0
   \   00021B   78..         MOV     R0,#?V0 + 0
   \   00021D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000220   90....       MOV     DPTR,#s_PTClientInfo + 4
   \   000223   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000226   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000229   12....       LCALL   ?DEALLOC_XSTACK8
   1258          }
   \                     ??ZLOADApp_handleReply_5:
   \   00022C   7402         MOV     A,#0x2
   \   00022E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000231   02....       LJMP    ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   90....       MOV     DPTR,#s_NextPacket
   \   000003                REQUIRE ??Subroutine37_0
   \   000003                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   90....       MOV     DPTR,#s_PTClientInfo + 20
   \   000003                REQUIRE ??Subroutine40_0
   \   000003                ; // Fall through to label ??Subroutine40_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ??zlSendSerial?relay
   \   000003                ; Setup parameters for call to function osal_mem_free
   \   000003                ; Setup parameters for call to function osal_mem_free
   \   000003   EE           MOV     A,R6
   \   000004   FA           MOV     R2,A
   \   000005   EF           MOV     A,R7
   \   000006   FB           MOV     R3,A
   \   000007   12....       LCALL   ??osal_mem_free?relay
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000003   7583..       MOV     DPH,#(s_NextPacket >> 8) & 0xff
   \   000006   7582..       MOV     DPL,#s_NextPacket & 0xff
   \   000009   C3           CLR     C
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   98           SUBB    A,R0
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   99           SUBB    A,R1
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   7900         MOV     R1,#0x0
   \   000002   7A..         MOV     R2,#(s_PTClientInfo + 6) & 0xff
   \   000004   7B..         MOV     R3,#((s_PTClientInfo + 6) >> 8) & 0xff
   \   000006                REQUIRE ??Subroutine42_0
   \   000006                ; // Fall through to label ??Subroutine42_0
   1259          
   1260          /**********************************************************************************
   1261           * @fn      zlProcessSDR
   1262           *
   1263           * @brief   Process the Send Data Reply as Client
   1264           *
   1265           * @param   input
   1266           *            sdr  pointer to received Send Data Reply
   1267           *
   1268           * @return  none
   1269           */
   1270          static void zlProcessSDR(zlsdR_t *sdr)
   1271          {
   1272            uint16 tmp;
   1273            osal_memcpy(&tmp, &sdr->zlsdR_pktNum, sizeof(uint16));
   1274          
   1275            // is this the right packet?
   1276            if (s_NextPacket > tmp)
   1277            {
   1278              return;  // we've already seen this one. ignore it
   1279            }
   1280            else if (s_NextPacket < tmp)  {
   1281              // uh oh. we've missed one. kill session...
   1282              osal_set_event(oad_app_taskId, ZLOAD_XFER_DONE_EVT);
   1283              return;
   1284            }
   1285            else if (sdr->zlsdR_errorCode)  {
   1286              // there are no data here. just ignaore the packet. if things
   1287              // are relly screwed up the timer will expire and we'll quit.
   1288              return;
   1289            }
   1290          
   1291            // Store the data in Xtra-NV.
   1292            HalOADWrite((uint32)s_NextPacket * s_blkSize, sdr->zlsdR_data, s_blkSize, HAL_OAD_DL);
   1293            s_NextPacket++;  // OK to increment next packet number now.
   1294            zlRequestNextDataPacket();  // ask for next packet
   1295          }
   1296          
   1297          /**********************************************************************************
   1298           * @fn      zlRequestNextDataPacket
   1299           *
   1300           * @brief   Set up the next data packet request. Takes care of knowing when
   1301           *          transfer is done. Takes care of retry timer.
   1302           *
   1303           * @param   none
   1304           *
   1305           * @return  none
   1306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1307          static void zlRequestNextDataPacket()
   \                     zlRequestNextDataPacket:
   1308          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1309              if (s_NextPacket >= s_NumPktGet)  {
   \   000005   90....       MOV     DPTR,#s_NumPktGet
   \   000008   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00000B   4011         JC      ??zlRequestNextDataPacket_0
   1310                  osal_set_event(oad_app_taskId, ZLOAD_XFER_DONE_EVT);
   \   00000D                ; Setup parameters for call to function osal_set_event
   \   00000D   12....       LCALL   ?Subroutine13 & 0xFFFF
   1311                  // kill response timeout check
   1312                  osal_stop_timerEx(oad_app_taskId, ZLOAD_SDRTIMER_EVT);
   \                     ??CrossCallReturnLabel_71:
   \   000010                ; Setup parameters for call to function osal_stop_timerEx
   \   000010   7A10         MOV     R2,#0x10
   \   000012   7B00         MOV     R3,#0x0
   \   000014   90....       MOV     DPTR,#oad_app_taskId
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   12....       LCALL   ??osal_stop_timerEx?relay
   1313                  return;
   \   00001C   8044         SJMP    ??zlRequestNextDataPacket_1
   1314              }
   1315          
   1316          #if defined ZPORT
   1317              s_sdcpayload->zlsdC_pktNum = s_NextPacket;
   \                     ??zlRequestNextDataPacket_0:
   \   00001E   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000021   90....       MOV     DPTR,#s_sdcpayload
   \   000024   E0           MOVX    A,@DPTR
   \   000025   FA           MOV     R2,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F583         MOV     DPH,A
   \   00002A   8A82         MOV     DPL,R2
   \   00002C   E8           MOV     A,R0
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   E9           MOV     A,R1
   \   000030   F0           MOVX    @DPTR,A
   1318              s_sdcmd->zlhdr_seqnum      = ++s_lastSeqNum;
   \   000031   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000034   C0E0         PUSH    A
   \   000036   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000039   D0E0         POP     A
   \   00003B   12....       LCALL   ?Subroutine2 & 0xFFFF
   1319          
   1320              {
   1321                  zahdrin_t *zain = zlBuildInternalInboundSerialMSG((uint8 *)s_sdcmd, sizeof(zlmhdr_t) + sizeof(zlsdC_t));
   \                     ??CrossCallReturnLabel_0:
   \   00003E   8A..         MOV     ?V0 + 0,R2
   \   000040   8B..         MOV     ?V0 + 1,R3
   \   000042   AE..         MOV     R6,?V0 + 0
   \   000044   AF..         MOV     R7,?V0 + 1
   1322          
   1323                  if (zain)  {
   \   000046   EE           MOV     A,R6
   \   000047   4F           ORL     A,R7
   \   000048   6005         JZ      ??CrossCallReturnLabel_32
   1324                      zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + sizeof(zlsdC_t));
   \   00004A                ; Setup parameters for call to function zlSendSerial
   \   00004A   790C         MOV     R1,#0xc
   \   00004C   12....       LCALL   ?Subroutine23 & 0xFFFF
   1325                      osal_mem_free(zain);
   1326                  }
   1327              }
   1328          #else
   1329              osal_memcpy(&s_sdcpayload->zlsdC_pktNum, &s_NextPacket, sizeof(uint16));
   1330              s_sdcmd->zlhdr_seqnum      = ++s_lastTxSeqNum;
   1331          
   1332              zlSendCommand(sizeof(zlmhdr_t) + sizeof(zlsdC_t), (uint8 *)s_sdcmd);
   1333          #endif
   1334          
   1335              if (SUCCESS != osal_start_timerEx(oad_app_taskId, ZLOAD_SDRTIMER_EVT, SDR_WAIT_TO))
   \                     ??CrossCallReturnLabel_32:
   \   00004F                ; Setup parameters for call to function osal_start_timerEx
   \   00004F   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000052   6005         JZ      ??CrossCallReturnLabel_73
   1336              {
   1337                osal_set_event(oad_app_taskId, ZLOAD_SDRTIMER_EVT);
   \   000054                ; Setup parameters for call to function osal_set_event
   \   000054   7A10         MOV     R2,#0x10
   \   000056   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   1338              }
   1339              s_SDCRetryCount = SDC_RETRY_COUNT;
   \                     ??CrossCallReturnLabel_73:
   \   000059   90....       MOV     DPTR,#s_SDCRetryCount
   \   00005C   740A         MOV     A,#0xa
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   E4           CLR     A
   \   000061   F0           MOVX    @DPTR,A
   1340          
   1341              // set timeout timer
   1342              // need osal timer resource and set event flag and need a method to process timeout event
   1343              return;
   \                     ??zlRequestNextDataPacket_1:
   \   000062   02....       LJMP    ?Subroutine0 & 0xFFFF
   1344          }
   1345          
   1346          /**********************************************************************************
   1347           * @fn      zlCleanupOnReset
   1348           *
   1349           * @brief   ZLOAD reset occurred. Free resources and reset state machine and other
   1350           *          supporting constructs
   1351           *
   1352           * @param   none
   1353           *
   1354           * @return  none
   1355           */
   1356          static void zlCleanupOnReset()
   1357          {
   1358          #if !defined ZPORT
   1359            if (ZLSTATE_CLIENT == s_State)  {
   1360              DO_EVENT_CALLBACK(ZLCB_EVENT_OADEND_CLIENT);
   1361            }
   1362            else if (ZLSTATE_SERVER == s_State)  {
   1363              DO_EVENT_CALLBACK(ZLCB_EVENT_OADEND_SERVER);
   1364            }
   1365          #endif
   1366          
   1367            zlResetState();
   1368          }
   1369          
   1370          /**************************************************************************************
   1371           * @fn      zlCleanupOnXferDone
   1372           *
   1373           * @brief   Data transfer session complete (not necessarily correctly). Free resources
   1374           *          and reset state machine and other supporting constructs. Send Terminate
   1375           *          Session command to Server.
   1376           *
   1377           * @param   none
   1378           *
   1379           * @return  none
   1380           */
   1381          static void  zlCleanupOnXferDone()
   1382          {
   1383          #if defined ZPORT
   1384              if (ZLSTATE_PASS_THROUGH == s_State)  {
   1385                s_State = ZLSTATE_IDLE;
   1386                return;
   1387              }
   1388          #endif
   1389          
   1390            // check for flashing last block and send Session Terminate command
   1391            if (ZLSTATE_CLIENT == s_State)  {
   1392              zlmhdr_t *hdr = osal_mem_alloc(sizeof(zlmhdr_t) + sizeof(zlendsessC_t));
   1393          
   1394              if (hdr)  {
   1395                zlendsessC_t *cmd = (zlendsessC_t *)((uint8 *)hdr + sizeof(zlmhdr_t));
   1396          
   1397                hdr->zlhdr_msgid  = ZLMSGID_SESSION_TERM;
   1398                hdr->zlhdr_msglen = sizeof(zlendsessC_t);
   1399          
   1400                cmd->zlesC_sessionID = s_SessionID;
   1401                hdr->zlhdr_seqnum    = ++s_lastTxSeqNum;
   1402          
   1403          #if defined ZPORT
   1404                      {
   1405                          zahdrin_t *zain = zlBuildInternalInboundSerialMSG((uint8 *)hdr, sizeof(zlmhdr_t) + sizeof(zlendsessC_t));
   1406          
   1407                          if (zain)  {
   1408                              zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + sizeof(zlendsessC_t));
   1409                              osal_mem_free(zain);
   1410                          }
   1411                      }
   1412          #else
   1413                zlSendCommand(sizeof(zlmhdr_t) + sizeof(zlendsessC_t), (uint8 *)hdr);
   1414          #endif
   1415          
   1416                osal_mem_free(hdr);
   1417              }
   1418          
   1419          #if !defined ZPORT
   1420              DO_EVENT_CALLBACK(ZLCB_EVENT_OADEND_CLIENT);
   1421          #endif
   1422            }
   1423          #if !defined ZPORT
   1424            else if (ZLSTATE_SERVER == s_State) {
   1425              DO_EVENT_CALLBACK(ZLCB_EVENT_OADEND_SERVER);
   1426            }
   1427          #endif
   1428          
   1429            zlResetState();
   1430          }
   1431          
   1432          /**************************************************************************************
   1433           * @fn      zlStartClientSession
   1434           *
   1435           * @brief   We have been commanded to be in the Client role. Set up to start the
   1436           *          session with the Server by sending the Begin Session command
   1437           *
   1438           * @param   none
   1439           *
   1440           * @return  none
   1441           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1442          static void zlStartClientSession()
   \                     zlStartClientSession:
   1443          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1444              uint8 *buf;
   1445          
   1446              // we already have Server info. Contact Server to set up session
   1447              if (buf=osal_mem_alloc(sizeof(zlmhdr_t) + sizeof(zlbegsessC_t)))  {
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   7A0A         MOV     R2,#0xa
   \   00000C   7B00         MOV     R3,#0x0
   \   00000E   12....       LCALL   ??osal_mem_alloc?relay
   \   000011   8A..         MOV     ?V0 + 0,R2
   \   000013   8B..         MOV     ?V0 + 1,R3
   \   000015   AE..         MOV     R6,?V0 + 0
   \   000017   AF..         MOV     R7,?V0 + 1
   \   000019   EE           MOV     A,R6
   \   00001A   4F           ORL     A,R7
   \   00001B   7003         JNZ     $+5
   \   00001D   02....       LJMP    ??zlStartClientSession_0 & 0xFFFF
   1448                  zlmhdr_t     *hdr = (zlmhdr_t *)buf;
   1449                  zlbegsessC_t *cmd = (zlbegsessC_t *)((uint8 *)buf+sizeof(zlmhdr_t));
   \   000020   EE           MOV     A,R6
   \   000021   2403         ADD     A,#0x3
   \   000023   F5..         MOV     ?V0 + 0,A
   \   000025   EF           MOV     A,R7
   \   000026   3400         ADDC    A,#0x0
   \   000028   F5..         MOV     ?V0 + 1,A
   1450          
   1451                  // initialize session id as lsb of IEEE address
   1452                  if (!s_SessionID)  {
   \   00002A   90....       MOV     DPTR,#s_SessionID
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   701A         JNZ     ??zlStartClientSession_1
   1453                      uint8 addr[Z_EXTADDR_LEN];
   1454          
   1455                      ZMacGetReq(ZMacExtAddr, addr);
   \   000030                ; Setup parameters for call to function ZMacGetReq
   \   000030   85..82       MOV     DPL,?XSP + 0
   \   000033   85..83       MOV     DPH,?XSP + 1
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   79E2         MOV     R1,#-0x1e
   \   00003C   12....       LCALL   ??ZMacGetReq?relay
   1456                      s_SessionID = addr[0];
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   90....       MOV     DPTR,#s_SessionID
   \   000049   F0           MOVX    @DPTR,A
   1457                  }
   1458          
   1459                  s_State = ZLSTATE_CLIENT;
   \                     ??zlStartClientSession_1:
   \   00004A   90....       MOV     DPTR,#s_State
   \   00004D   7402         MOV     A,#0x2
   \   00004F   F0           MOVX    @DPTR,A
   1460                  s_SessionID++;
   \   000050   90....       MOV     DPTR,#s_SessionID
   \   000053   E0           MOVX    A,@DPTR
   \   000054   04           INC     A
   \   000055   12....       LCALL   ?Subroutine30 & 0xFFFF
   1461          
   1462                  hdr->zlhdr_msgid     = ZLMSGID_SESSION_START;
   \                     ??CrossCallReturnLabel_46:
   \   000058   7402         MOV     A,#0x2
   \   00005A   F0           MOVX    @DPTR,A
   1463                  hdr->zlhdr_seqnum    = ++s_lastTxSeqNum;
   \   00005B   90....       MOV     DPTR,#s_lastTxSeqNum
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   04           INC     A
   \   000060   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000063   12....       LCALL   ?Subroutine7 & 0xFFFF
   1464                  hdr->zlhdr_msglen    = sizeof(zlbegsessC_t);
   \                     ??CrossCallReturnLabel_12:
   \   000066   A3           INC     DPTR
   \   000067   7407         MOV     A,#0x7
   \   000069   F0           MOVX    @DPTR,A
   1465                  osal_memcpy(&cmd->zlbsC_ver, &s_clientInfo->zlclC_ver, sizeof(uint16));
   \   00006A                ; Setup parameters for call to function osal_memcpy
   \   00006A   90....       MOV     DPTR,#s_clientInfo
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F5..         MOV     ?V0 + 4,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F5..         MOV     ?V0 + 5,A
   \   000074   75..00       MOV     ?V0 + 6,#0x0
   \   000077   78..         MOV     R0,#?V0 + 4
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007C   7C02         MOV     R4,#0x2
   \   00007E   7D00         MOV     R5,#0x0
   \   000080   AA..         MOV     R2,?V0 + 0
   \   000082   AB..         MOV     R3,?V0 + 1
   \   000084   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000087   12....       LCALL   ?DEALLOC_XSTACK8
   1466                  osal_memcpy(&cmd->zlbsC_manu, &s_clientInfo->zlclC_manu, sizeof(uint16));
   \   00008A                ; Setup parameters for call to function osal_memcpy
   \   00008A   90....       MOV     DPTR,#s_clientInfo
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   2402         ADD     A,#0x2
   \   000090   F5..         MOV     ?V0 + 4,A
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   3400         ADDC    A,#0x0
   \   000096   F5..         MOV     ?V0 + 5,A
   \   000098   78..         MOV     R0,#?V0 + 4
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00009D   7C02         MOV     R4,#0x2
   \   00009F   7D00         MOV     R5,#0x0
   \   0000A1   E5..         MOV     A,?V0 + 0
   \   0000A3   2402         ADD     A,#0x2
   \   0000A5   FA           MOV     R2,A
   \   0000A6   E5..         MOV     A,?V0 + 1
   \   0000A8   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   1467                  osal_memcpy(&cmd->zlbsC_prod, &s_clientInfo->zlclC_prod, sizeof(uint16));
   \   0000AE                ; Setup parameters for call to function osal_memcpy
   \   0000AE   90....       MOV     DPTR,#s_clientInfo
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   2404         ADD     A,#0x4
   \   0000B4   F5..         MOV     ?V0 + 4,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   3400         ADDC    A,#0x0
   \   0000BA   F5..         MOV     ?V0 + 5,A
   \   0000BC   78..         MOV     R0,#?V0 + 4
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000C1   7C02         MOV     R4,#0x2
   \   0000C3   7D00         MOV     R5,#0x0
   \   0000C5   E5..         MOV     A,?V0 + 0
   \   0000C7   2404         ADD     A,#0x4
   \   0000C9   FA           MOV     R2,A
   \   0000CA   E5..         MOV     A,?V0 + 1
   \   0000CC   12....       LCALL   ??Subroutine43_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   0000CF   12....       LCALL   ?DEALLOC_XSTACK8
   1468                  cmd->zlbsC_sessionID = s_SessionID;
   \   0000D2   90....       MOV     DPTR,#s_SessionID
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   85..82       MOV     DPL,?V0 + 0
   \   0000D9   85..83       MOV     DPH,?V0 + 1
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   A3           INC     DPTR
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   12....       LCALL   ?Subroutine9 & 0xFFFF
   1469                  s_NextPacket         = 0;
   1470          
   1471                  // populate session ID element in the Send data payload
   1472                  s_sdcpayload->zlsdC_sessionID = s_SessionID;
   \                     ??CrossCallReturnLabel_16:
   \   0000E5   90....       MOV     DPTR,#s_SessionID
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   C0E0         PUSH    A
   \   0000EB   90....       MOV     DPTR,#s_sdcpayload
   \   0000EE   12....       LCALL   ??Subroutine35_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000F1   A3           INC     DPTR
   \   0000F2   D0E0         POP     A
   \   0000F4   12....       LCALL   ?Subroutine3 & 0xFFFF
   1473          
   1474                  // set up SD command header
   1475                  s_sdcmd->zlhdr_msgid  = ZLMSGID_SEND_DATA;
   \                     ??CrossCallReturnLabel_2:
   \   0000F7   7406         MOV     A,#0x6
   \   0000F9   12....       LCALL   ?Subroutine3 & 0xFFFF
   1476                  s_sdcmd->zlhdr_msglen = sizeof(zlsdC_t);
   \                     ??CrossCallReturnLabel_3:
   \   0000FC   A3           INC     DPTR
   \   0000FD   A3           INC     DPTR
   \   0000FE   7403         MOV     A,#0x3
   \   000100   F0           MOVX    @DPTR,A
   1477          
   1478          #if defined ZPORT
   1479                  {
   1480                      zahdrin_t *zain = zlBuildInternalInboundSerialMSG((uint8 *)hdr, sizeof(zlmhdr_t) + sizeof(zlbegsessC_t));
   \   000101                ; Setup parameters for call to function zlBuildInternalInboundSerialMSG
   \   000101   790A         MOV     R1,#0xa
   \   000103   EE           MOV     A,R6
   \   000104   FA           MOV     R2,A
   \   000105   EF           MOV     A,R7
   \   000106   FB           MOV     R3,A
   \   000107   12....       LCALL   ??zlBuildInternalInboundSerialMSG?relay
   \   00010A   8A..         MOV     ?V0 + 0,R2
   \   00010C   8B..         MOV     ?V0 + 1,R3
   1481          
   1482                      if (zain)  {
   \   00010E   EA           MOV     A,R2
   \   00010F   45..         ORL     A,?V0 + 1
   \   000111   6003         JZ      ??CrossCallReturnLabel_81
   1483                          zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + sizeof(zlbegsessC_t));
   \   000113                ; Setup parameters for call to function zlSendSerial
   \   000113   12....       LCALL   ?Subroutine22 & 0xFFFF
   1484                          osal_mem_free(zain);
   1485                      }
   1486                  }
   1487          #else
   1488                  if (zlSendCommand(sizeof(zlmhdr_t) + sizeof(zlbegsessC_t), buf))
   1489                  {
   1490                  }
   1491          #endif
   1492          
   1493                  osal_mem_free(buf);
   \                     ??CrossCallReturnLabel_81:
   \   000116                ; Setup parameters for call to function osal_mem_free
   \   000116   EE           MOV     A,R6
   \   000117   FA           MOV     R2,A
   \   000118   EF           MOV     A,R7
   \   000119   FB           MOV     R3,A
   \   00011A   12....       LCALL   ??osal_mem_free?relay
   1494                  DO_EVENT_CALLBACK(ZLCB_EVENT_OADBEGIN_CLIENT);
   \   00011D   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000120   601E         JZ      ??CrossCallReturnLabel_74
   \   000122   90....       MOV     DPTR,#s_eventMask
   \   000125   E0           MOVX    A,@DPTR
   \   000126   A2E0         MOV     C,0xE0 /* A   */.0
   \   000128   5016         JNC     ??CrossCallReturnLabel_74
   \   00012A                ; Setup parameters for indirect call
   \   00012A   7A01         MOV     R2,#0x1
   \   00012C   7B00         MOV     R3,#0x0
   \   00012E   90....       MOV     DPTR,#s_pCallback + 1
   \   000131   E0           MOVX    A,@DPTR
   \   000132   F583         MOV     DPH,A
   \   000134   8882         MOV     DPL,R0
   \   000136   12....       LCALL   ?CALL_IND
   \   000139   8005         SJMP    ??CrossCallReturnLabel_74
   1495              }
   1496          	else  {
   1497          		// we couldn't send the Begin Session command. go back to Idle state.
   1498                  osal_set_event(oad_app_taskId, ZLOAD_RESET_EVT);
   \                     ??zlStartClientSession_0:
   \   00013B                ; Setup parameters for call to function osal_set_event
   \   00013B   7A08         MOV     R2,#0x8
   \   00013D   12....       LCALL   ??Subroutine38_0 & 0xFFFF
   1499          	}
   1500          
   1501              return;
   \                     ??CrossCallReturnLabel_74:
   \   000140   7408         MOV     A,#0x8
   \   000142   12....       LCALL   ?DEALLOC_XSTACK8
   \   000145   7F07         MOV     R7,#0x7
   \   000147   02....       LJMP    ?BANKED_LEAVE_XDATA
   1502          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#s_sdcmd
   \   000004   12....       LCALL   ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#s_NextPacket
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET
   1503          
   1504          #if !defined ZPORT
   1505          /**************************************************************************************
   1506           * @fn      zlSendCommand
   1507           *
   1508           * @brief   Send command to destination. Can be either over air or to the Host. This
   1509           *          routine takes care of the context.
   1510           *
   1511           * @param   input
   1512           *            length   length of message being sent
   1513           *            buf      pointer to message
   1514           *
   1515           * @return  0: successful send
   1516           *          1: unseccessful send (return code for AF layer)
   1517           */
   1518          static uint8 zlSendCommand(uint8 length, uint8 *buf)
   1519          {
   1520              uint8  rc;
   1521          
   1522              rc = AF_DataRequest( &dstAddr,
   1523                                    afFindEndPointDesc( OAD_epDesc.endPoint ),
   1524                                    OAD_CLUSTERID_CS,
   1525                                    length, buf,
   1526                                   &transId,
   1527                                    AF_DISCV_ROUTE, DEF_NWK_RADIUS );
   1528          
   1529              return rc;
   1530          }
   1531          #endif
   1532          
   1533          /**************************************************************************************
   1534           * @fn      zlResendSDC
   1535           *
   1536           * @brief   Resend the previous Send Data Command because a repply was not received
   1537           *          before a timeout.
   1538           *
   1539           * @param   none
   1540           *
   1541           * @return  none.
   1542           */
   1543          static void zlResendSDC()
   1544          {
   1545              if (s_State != ZLSTATE_CLIENT)  {
   1546                  // late expiration -- don't care
   1547                  return;
   1548              }
   1549          
   1550              if (--s_SDCRetryCount)  {
   1551          #if defined ZPORT
   1552                  s_sdcmd->zlhdr_seqnum = ++s_lastSeqNum;
   1553                  {
   1554                      zahdrin_t *zain = zlBuildInternalInboundSerialMSG((uint8 *)s_sdcmd, sizeof(zlmhdr_t) + sizeof(zlsdC_t));
   1555          
   1556                      if (zain)  {
   1557                          zlSendSerial((uint8 *)zain, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + sizeof(zlsdC_t));
   1558                          osal_mem_free(zain);
   1559                      }
   1560                  }
   1561          #else
   1562                  // the static structure still contains the last packet number to be requested.
   1563                  // the only way the packet number gets bumped is if a reply is received.
   1564                  zlSendCommand(sizeof(zlmhdr_t) + sizeof(zlsdC_t), (uint8 *)s_sdcmd);
   1565          #endif
   1566          
   1567                  if (SUCCESS != osal_start_timerEx(oad_app_taskId, ZLOAD_SDRTIMER_EVT, SDR_WAIT_TO))
   1568                  {
   1569                    osal_set_event(oad_app_taskId, ZLOAD_SDRTIMER_EVT);
   1570                  }
   1571              }
   1572              else  {
   1573                  // too many retries. abandon session.
   1574                  osal_set_event(oad_app_taskId, ZLOAD_XFER_DONE_EVT);
   1575              }
   1576          
   1577              return;
   1578          }
   1579          
   1580          #if !defined ZPORT
   1581          /**************************************************************************************
   1582           * @fn      oadAppRegisterCB
   1583           *
   1584           * @brief   Register a callback to be referenced when OAD events occur.
   1585           *
   1586           * @param   input
   1587           *            pCBFunction  pointer to void function with an unsigned short argument.
   1588           *            eventMask    bit mask of events for which the callback should be invoked.
   1589           *
   1590           *    When the callback is invoked its argument will indicate via the bit mask argument
   1591           *    which event occurred. A null pointer or a null bit mask will have the effect of
   1592           *    deregistration.
   1593           *
   1594           * @return  none.
   1595           */
   1596          void oadAppRegisterCB(void (*pCBFunction)(uint16), uint16 eventMask)
   1597          {
   1598            s_pCallback = pCBFunction;
   1599            s_eventMask = eventMask;
   1600            return;
   1601          }
   1602          #endif
   1603          
   1604          /**************************************************************************************************
   1605           * @fn          zlResetState
   1606           *
   1607           * @brief       This function frees any memory in use and resets the zl state info.
   1608           *
   1609           * input parameters
   1610           *
   1611           * None.
   1612           *
   1613           * output parameters
   1614           *
   1615           * None.
   1616           *
   1617           * @return      None.
   1618           **************************************************************************************************
   1619           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1620          static void zlResetState(void)
   \                     zlResetState:
   1621          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1622            osal_stop_timerEx(oad_app_taskId, ZLOAD_SDRTIMER_EVT);  // kill response timeout check
   \   000004                ; Setup parameters for call to function osal_stop_timerEx
   \   000004   7A10         MOV     R2,#0x10
   \   000006   7B00         MOV     R3,#0x0
   \   000008   90....       MOV     DPTR,#oad_app_taskId
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   12....       LCALL   ??osal_stop_timerEx?relay
   1623          
   1624            if (s_sdreply)
   \   000010   90....       MOV     DPTR,#s_sdreply
   \   000013   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000016   600D         JZ      ??zlResetState_0
   1625            {
   1626              osal_mem_free(s_sdreply);
   \   000018                ; Setup parameters for call to function osal_mem_free
   \   000018   90....       MOV     DPTR,#s_sdreply
   \   00001B   12....       LCALL   ?Subroutine19 & 0xFFFF
   1627              s_sdreply = NULL;
   \                     ??CrossCallReturnLabel_25:
   \   00001E   90....       MOV     DPTR,#s_sdreply
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   1628            }
   1629          
   1630            if (s_clientInfo)
   \                     ??zlResetState_0:
   \   000025   90....       MOV     DPTR,#s_clientInfo
   \   000028   12....       LCALL   ??Subroutine36_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00002B   600D         JZ      ??zlResetState_1
   1631            {
   1632              osal_mem_free(s_clientInfo);
   \   00002D                ; Setup parameters for call to function osal_mem_free
   \   00002D   90....       MOV     DPTR,#s_clientInfo
   \   000030   12....       LCALL   ?Subroutine19 & 0xFFFF
   1633              s_clientInfo = NULL;
   \                     ??CrossCallReturnLabel_26:
   \   000033   90....       MOV     DPTR,#s_clientInfo
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   F0           MOVX    @DPTR,A
   1634            }
   1635          
   1636            s_State = ZLSTATE_IDLE;
   \                     ??zlResetState_1:
   \   00003A   90....       MOV     DPTR,#s_State
   \   00003D   7401         MOV     A,#0x1
   \   00003F   12....       LCALL   ?Subroutine9 & 0xFFFF
   1637            s_NextPacket      = 0;
   1638            s_NumPktGet       = 0;
   \                     ??CrossCallReturnLabel_17:
   \   000042   90....       MOV     DPTR,#s_NumPktGet
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   F0           MOVX    @DPTR,A
   1639          }
   \   000048   D083         POP     DPH
   \   00004A   D082         POP     DPL
   \   00004C   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??osal_mem_free?relay
   \   000008   22           RET
   1640          
   1641          #if defined ZPORT
   1642          /*********************************************************************
   1643           * @fn      ZLOADApp_SerialMSGCB
   1644           *
   1645           * @brief   Message from Host application. It's a command, a reply,
   1646           *          or a proxy command. Send it on appropriately
   1647           *
   1648           * @param   input
   1649           *            inMsg  pointer to incoming message
   1650           *
   1651           * @return  none
   1652           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1653          static void ZLOADApp_SerialMessageMSGCB(zahdrout_t *zaout)
   \                     ZLOADApp_SerialMessageMSGCB:
   1654          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1655              zlmhdr_t *zlhdr = (zlmhdr_t *)zaout->zaproxy_payload;
   \   00000E   EE           MOV     A,R6
   \   00000F   2406         ADD     A,#0x6
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018   AC..         MOV     R4,?V0 + 0
   \   00001A   FD           MOV     R5,A
   1656          
   1657              // is this for me?
   1658              if (zaout->zaproxy_nwkAddr == s_myNwkAddr)  {
   \   00001B   8E82         MOV     DPL,R6
   \   00001D   8F83         MOV     DPH,R7
   \   00001F   12....       LCALL   ??Subroutine37_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000022   90....       MOV     DPTR,#s_myNwkAddr
   \   000025   E0           MOVX    A,@DPTR
   \   000026   68           XRL     A,R0
   \   000027   7003         JNZ     ??ZLOADApp_SerialMessageMSGCB_0
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   69           XRL     A,R1
   \                     ??ZLOADApp_SerialMessageMSGCB_0:
   \   00002C   7019         JNZ     ??ZLOADApp_SerialMessageMSGCB_1
   1659                // is this a reply?
   1660                if (zlhdr->zlhdr_msgid & ZLMSGID_REPLY_BIT)  {
   \   00002E   8C82         MOV     DPL,R4
   \   000030   8D83         MOV     DPH,R5
   \   000032   E0           MOVX    A,@DPTR
   \   000033   A2E7         MOV     C,0xE0 /* A   */.7
   \   000035   7A00         MOV     R2,#0x0
   \   000037   7B00         MOV     R3,#0x0
   \   000039   5006         JNC     ??ZLOADApp_SerialMessageMSGCB_2
   1661                    ZLOADApp_handleReply(NULL, zlhdr);
   \   00003B                ; Setup parameters for call to function ZLOADApp_handleReply
   \   00003B   12....       LCALL   ??ZLOADApp_handleReply?relay
   \   00003E   02....       LJMP    ??ZLOADApp_SerialMessageMSGCB_3 & 0xFFFF
   1662                }
   1663                else  {
   1664                    ZLOADApp_handleCommand(NULL, zlhdr);
   \                     ??ZLOADApp_SerialMessageMSGCB_2:
   \   000041                ; Setup parameters for call to function ZLOADApp_handleCommand
   \   000041   12....       LCALL   ??ZLOADApp_handleCommand?relay
   \   000044   02....       LJMP    ??ZLOADApp_SerialMessageMSGCB_3 & 0xFFFF
   1665                }
   1666              }
   1667              else  {
   1668                  // it's a proxy command
   1669                  zlZArchitectProxyMsg(zaout);
   \                     ??ZLOADApp_SerialMessageMSGCB_1:
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   24FE         ADD     A,#-0x2
   \   000054   7003         JNZ     $+5
   \   000056   02....       LJMP    ??ZLOADApp_SerialMessageMSGCB_3 & 0xFFFF
   \   000059   14           DEC     A
   \   00005A   7003         JNZ     $+5
   \   00005C   02....       LJMP    ??ZLOADApp_SerialMessageMSGCB_3 & 0xFFFF
   \   00005F   24FD         ADD     A,#-0x3
   \   000061   7003         JNZ     $+5
   \   000063   02....       LJMP    ??ZLOADApp_SerialMessageMSGCB_3 & 0xFFFF
   \   000066   7408         MOV     A,#0x8
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   7402         MOV     A,#0x2
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   EE           MOV     A,R6
   \   00006F   2402         ADD     A,#0x2
   \   000071   F8           MOV     R0,A
   \   000072   EF           MOV     A,R7
   \   000073   3400         ADDC    A,#0x0
   \   000075   F9           MOV     R1,A
   \   000076   8882         MOV     DPL,R0
   \   000078   8983         MOV     DPH,R1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   C0E0         PUSH    A
   \   00007D   7409         MOV     A,#0x9
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   D0E0         POP     A
   \   000084   12....       LCALL   ?Subroutine30 & 0xFFFF
   1670              }
   \                     ??CrossCallReturnLabel_48:
   \   000087   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00008A   85..82       MOV     DPL,?XSP + 0
   \   00008D   85..83       MOV     DPH,?XSP + 1
   \   000090   EA           MOV     A,R2
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A3           INC     DPTR
   \   000093   EB           MOV     A,R3
   \   000094   F0           MOVX    @DPTR,A
   \   000095                ; Setup parameters for call to function afFindEndPointDesc
   \   000095   8882         MOV     DPL,R0
   \   000097   8983         MOV     DPH,R1
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   F9           MOV     R1,A
   \   00009B   12....       LCALL   ??afFindEndPointDesc?relay
   \   00009E   8A..         MOV     ?V0 + 2,R2
   \   0000A0   8B..         MOV     ?V0 + 3,R3
   \   0000A2   AC..         MOV     R4,?V0 + 2
   \   0000A4   AD..         MOV     R5,?V0 + 3
   \   0000A6                ; Setup parameters for call to function AF_DataRequest
   \   0000A6   75..1E       MOV     ?V0 + 2,#0x1e
   \   0000A9   78..         MOV     R0,#?V0 + 2
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AE   75....       MOV     ?V0 + 2,#transId & 0xff
   \   0000B1   75....       MOV     ?V0 + 3,#(transId >> 8) & 0xff
   \   0000B4   78..         MOV     R0,#?V0 + 2
   \   0000B6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B9   78..         MOV     R0,#?V0 + 0
   \   0000BB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BE   8E82         MOV     DPL,R6
   \   0000C0   8F83         MOV     DPH,R7
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F5..         MOV     ?V0 + 0,A
   \   0000CA   75..00       MOV     ?V0 + 1,#0x0
   \   0000CD   78..         MOV     R0,#?V0 + 0
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D2   8E82         MOV     DPL,R6
   \   0000D4   8F83         MOV     DPH,R7
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000DC   7900         MOV     R1,#0x0
   \   0000DE   7409         MOV     A,#0x9
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   AA82         MOV     R2,DPL
   \   0000E5   AB83         MOV     R3,DPH
   \   0000E7   12....       LCALL   ??Subroutine42_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0000EA   12....       LCALL   ?DEALLOC_XSTACK8
   1671              return;
   \                     ??ZLOADApp_SerialMessageMSGCB_3:
   \   0000ED   740C         MOV     A,#0xc
   \   0000EF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F2   7F04         MOV     R7,#0x4
   \   0000F4   02....       LJMP    ?BANKED_LEAVE_XDATA
   1672          }
   1673          
   1674          /*********************************************************************
   1675           * @fn      zlSendSerial
   1676           *
   1677           * @brief   Prepare message outgoing over serial port.
   1678           *          malloc and copy to add serial encapsulation.
   1679           *
   1680           * @param   input
   1681           *            buf  pointer to ougoing message buffer
   1682           *            len  length of message
   1683           *
   1684           * @return  none
   1685           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1686          static void zlSendSerial(uint8 *buf, uint8 len)
   \                     zlSendSerial:
   1687          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   89..         MOV     ?V0 + 4,R1
   1688              uint8 *nbuf;
   1689          
   1690              if ((nbuf=osal_mem_alloc(len+1)))  {
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E9           MOV     A,R1
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   E4           CLR     A
   \   000010   3400         ADDC    A,#0x0
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   ??osal_mem_alloc?relay
   \   000016   8A..         MOV     ?V0 + 2,R2
   \   000018   8B..         MOV     ?V0 + 3,R3
   \   00001A   AE..         MOV     R6,?V0 + 2
   \   00001C   AF..         MOV     R7,?V0 + 3
   \   00001E   EE           MOV     A,R6
   \   00001F   4F           ORL     A,R7
   \   000020   6038         JZ      ??zlSendSerial_0
   1691                  osal_memcpy(nbuf+1, buf, len);
   \   000022                ; Setup parameters for call to function osal_memcpy
   \   000022   75..00       MOV     ?V0 + 2,#0x0
   \   000025   78..         MOV     R0,#?V0 + 0
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00002A   85....       MOV     ?V0 + 0,?V0 + 4
   \   00002D   AC..         MOV     R4,?V0 + 0
   \   00002F   7D00         MOV     R5,#0x0
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   1692                  *nbuf = OAD_ENDPOINT;
   \   000040   8E82         MOV     DPL,R6
   \   000042   8F83         MOV     DPH,R7
   \   000044   74C8         MOV     A,#-0x38
   \   000046   F0           MOVX    @DPTR,A
   1693          #if !defined(ZTOOL_SUPPORT)
   1694                  MTProcessAppRspMsg(nbuf, len + 1);
   \   000047                ; Setup parameters for call to function MTProcessAppRspMsg
   \   000047   7401         MOV     A,#0x1
   \   000049   25..         ADD     A,?V0 + 4
   \   00004B   F9           MOV     R1,A
   \   00004C   EE           MOV     A,R6
   \   00004D   FA           MOV     R2,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FB           MOV     R3,A
   \   000050   12....       LCALL   ??MTProcessAppRspMsg?relay
   1695          #else
   1696                  // ZTool expects an 81 byte message
   1697                  MTProcessAppRspMsg(nbuf, 81);
   1698          #endif
   1699                  osal_mem_free(nbuf);
   \   000053                ; Setup parameters for call to function osal_mem_free
   \   000053   EE           MOV     A,R6
   \   000054   FA           MOV     R2,A
   \   000055   EF           MOV     A,R7
   \   000056   FB           MOV     R3,A
   \   000057   12....       LCALL   ??osal_mem_free?relay
   1700              }
   1701              return;
   \                     ??zlSendSerial_0:
   \   00005A   7F05         MOV     R7,#0x5
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1702          }
   1703          
   1704          /****************************************************************************
   1705           * @fn      zlZArchitectProxyCommand
   1706           *
   1707           * @brief   Send command to target device on behalf of ZArchitect Host App
   1708           *
   1709           * @param   input
   1710           *            info  pointer to ZArchitect proxy message
   1711           *
   1712           * @return  none
   1713           */
   1714          static void zlZArchitectProxyMsg(zahdrout_t *info)
   1715          {
   1716              afAddrType_t taddr;
   1717              zlmhdr_t     *zlhdr = (zlmhdr_t *)info->zaproxy_payload;
   1718          
   1719              // only certain outgoing messages are valid proxy commands
   1720              switch (zlhdr->zlhdr_msgid)  {
   1721                  case ZLMSGID_SESSION_START:
   1722                  case ZLMSGID_SESSION_TERM:
   1723                  case ZLMSGID_SEND_DATA:
   1724                      return;
   1725              }
   1726          
   1727              // fill in address info
   1728              taddr.addrMode       = afAddr16Bit;
   1729              taddr.endPoint       = info->zaproxy_endp;
   1730              taddr.addr.shortAddr = info->zaproxy_nwkAddr;
   1731          
   1732              AF_DataRequest( &taddr,
   1733                               afFindEndPointDesc( info->zaproxy_endp ),
   1734                               info->zaproxy_ClusterID,
   1735                               info->zaproxy_msglen, info->zaproxy_payload,
   1736                              &transId,
   1737                               AF_TX_OPTIONS_NONE, DEF_NWK_RADIUS );
   1738          }
   1739          
   1740          // start a session with the host on behalf of the client from which
   1741          // the start session was received. do this by sending self a client
   1742          // command using the start session parameters. ZLOAD will think it
   1743          // is a client message coming from the host asking it to come get
   1744          // the image being requested by the real client.
   1745          static uint8 zlPassOnStartSessionOK(uint8 *msg)
   1746          {
   1747              zahdrin_t *zamsgin;
   1748          
   1749              // forward the Begin Session command
   1750              zamsgin = zlBuildExternalInboundSerialMSG(&s_PTClientInfo, msg, sizeof(zlmhdr_t) + sizeof(zlbegsessC_t));
   1751          
   1752              if (!zamsgin)  {
   1753                return 0;
   1754              }
   1755          
   1756              zlSendSerial((uint8 *)zamsgin, SIZEOF_ZAIN_HDR + sizeof(zlmhdr_t) + sizeof(zlbegsessC_t));
   1757          
   1758              osal_mem_free(zamsgin);
   1759          
   1760              return 1;
   1761          }
   1762          
   1763          // inbound messages can be built from address information gleaned from the client
   1764          // during a pass-through session setup. but there can also be inbound messages
   1765          // such as status replies that are not part of any ongoing client session. in this
   1766          // case the address information comes from the AF message. in either case this
   1767          // information is requried to populate the header for for the host.

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   7D00         MOV     R5,#0x0
   \   000002   EA           MOV     A,R2
   \   000003   2406         ADD     A,#0x6
   \   000005   FA           MOV     R2,A
   \   000006   EB           MOV     A,R3
   \   000007                REQUIRE ??Subroutine43_0
   \   000007                ; // Fall through to label ??Subroutine43_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1768          static zahdrin_t *zlBuildExternalInboundSerialMSG(afIncomingMSGPacket_t *addressInfo, uint8 *zlmsg, uint8 len)
   \                     zlBuildExternalInboundSerialMSG:
   1769          {
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   89..         MOV     ?V0 + 6,R1
   1770              zahdrin_t *zamsgin;
   1771          
   1772              // build message
   1773              zamsgin = (zahdrin_t *)osal_mem_alloc(SIZEOF_ZAIN_HDR + len);
   \   00000F   8982         MOV     DPL,R1
   \   000011   8582..       MOV     ?V0 + 4,DPL
   \   000014                ; Setup parameters for call to function osal_mem_alloc
   \   000014   12....       LCALL   ?Subroutine24 & 0xFFFF
   1774          
   1775              if (!zamsgin)  {
   \                     ??CrossCallReturnLabel_33:
   \   000017   7006         JNZ     ??zlBuildExternalInboundSerialMSG_0
   1776                return 0;
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7B00         MOV     R3,#0x0
   \   00001D   804E         SJMP    ??zlBuildExternalInboundSerialMSG_1
   1777              }
   1778          
   1779              zamsgin->zaproxy_nwkAddr   = addressInfo->srcAddr.addr.shortAddr;
   \                     ??zlBuildExternalInboundSerialMSG_0:
   \   00001F   85..82       MOV     DPL,?V0 + 2
   \   000022   85..83       MOV     DPH,?V0 + 3
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00002A   E8           MOV     A,R0
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   E9           MOV     A,R1
   \   00002E   F0           MOVX    @DPTR,A
   1780              zamsgin->zaproxy_endp      = addressInfo->endPoint;
   \   00002F   E5..         MOV     A,?V0 + 2
   \   000031   2414         ADD     A,#0x14
   \   000033   F582         MOV     DPL,A
   \   000035   E5..         MOV     A,?V0 + 3
   \   000037   3400         ADDC    A,#0x0
   \   000039   F583         MOV     DPH,A
   \   00003B   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
   1781              zamsgin->zaproxy_ClusterID = addressInfo->clusterId;
   \   000040   85..82       MOV     DPL,?V0 + 2
   \   000043   85..83       MOV     DPH,?V0 + 3
   \   000046   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   12....       LCALL   ?Subroutine6 & 0xFFFF
   1782              zamsgin->zaproxy_msglen    = len;
   \                     ??CrossCallReturnLabel_9:
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   E5..         MOV     A,?V0 + 6
   \   000054   F0           MOVX    @DPTR,A
   1783          
   1784              osal_memcpy(zamsgin->zaproxy_payload, zlmsg, len);
   \   000055                ; Setup parameters for call to function osal_memcpy
   \   000055   8E..         MOV     ?V0 + 8,R6
   \   000057   8F..         MOV     ?V0 + 9,R7
   \   000059   75..00       MOV     ?V0 + 10,#0x0
   \   00005C   78..         MOV     R0,#?V0 + 8
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000061   AC..         MOV     R4,?V0 + 4
   \   000063   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000066   12....       LCALL   ?DEALLOC_XSTACK8
   1785          
   1786              return zamsgin;
   \   000069   AA..         MOV     R2,?V0 + 0
   \   00006B   AB..         MOV     R3,?V0 + 1
   \                     ??zlBuildExternalInboundSerialMSG_1:
   \   00006D   7F0B         MOV     R7,#0xb
   \   00006F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1787          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine45_0
   \   000004                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E9           MOV     A,R1
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   E4           CLR     A
   \   000005   3400         ADDC    A,#0x0
   \   000007   FB           MOV     R3,A
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   EA           MOV     A,R2
   \   000010   45..         ORL     A,?V0 + 1
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000007   22           RET
   1788          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1789          static zahdrin_t *zlBuildInternalInboundSerialMSG(uint8 *zlmsg, uint8 len)
   \                     zlBuildInternalInboundSerialMSG:
   1790          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 7,R1
   1791              zahdrin_t *zamsgin;
   1792          
   1793              // build message
   1794              zamsgin = (zahdrin_t *)osal_mem_alloc(SIZEOF_ZAIN_HDR + len);
   \   00000B   8982         MOV     DPL,R1
   \   00000D   8582..       MOV     ?V0 + 2,DPL
   \   000010                ; Setup parameters for call to function osal_mem_alloc
   \   000010   12....       LCALL   ?Subroutine24 & 0xFFFF
   1795          
   1796              if (!zamsgin)  {
   \                     ??CrossCallReturnLabel_34:
   \   000013   7006         JNZ     ??zlBuildInternalInboundSerialMSG_0
   1797                return 0;
   \   000015   7A00         MOV     R2,#0x0
   \   000017   7B00         MOV     R3,#0x0
   \   000019   8033         SJMP    ??zlBuildInternalInboundSerialMSG_1
   1798              }
   1799          
   1800              zamsgin->zaproxy_nwkAddr   = s_myNwkAddr;
   \                     ??zlBuildInternalInboundSerialMSG_0:
   \   00001B   90....       MOV     DPTR,#s_myNwkAddr
   \   00001E   12....       LCALL   ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000021   12....       LCALL   ?Subroutine6 & 0xFFFF
   1801              zamsgin->zaproxy_endp      = OAD_ENDPOINT;
   \                     ??CrossCallReturnLabel_10:
   \   000024   74C8         MOV     A,#-0x38
   \   000026   12....       LCALL   ?Subroutine8 & 0xFFFF
   1802              zamsgin->zaproxy_ClusterID = OAD_CLUSTERID_CS;
   \                     ??CrossCallReturnLabel_14:
   \   000029   7401         MOV     A,#0x1
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   E4           CLR     A
   \   00002E   12....       LCALL   ?Subroutine8 & 0xFFFF
   1803              zamsgin->zaproxy_msglen    = len;
   \                     ??CrossCallReturnLabel_15:
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E5..         MOV     A,?V0 + 7
   \   000035   F0           MOVX    @DPTR,A
   1804          
   1805              osal_memcpy(zamsgin->zaproxy_payload, zlmsg, len);
   \   000036                ; Setup parameters for call to function osal_memcpy
   \   000036   8E..         MOV     ?V0 + 4,R6
   \   000038   8F..         MOV     ?V0 + 5,R7
   \   00003A   75..00       MOV     ?V0 + 6,#0x0
   \   00003D   78..         MOV     R0,#?V0 + 4
   \   00003F   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000042   AC..         MOV     R4,?V0 + 2
   \   000044   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   1806          
   1807              return zamsgin;
   \   00004A   AA..         MOV     R2,?V0 + 0
   \   00004C   AB..         MOV     R3,?V0 + 1
   \                     ??zlBuildInternalInboundSerialMSG_1:
   \   00004E   02....       LJMP    ?Subroutine1 & 0xFFFF
   1808          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for s_myNwkAddr>`:
   \   000000   FEFF         DW 65534

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3a801:
   \   000000   01A80300     DD 239617

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??oadAppInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    oadAppInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??oadAppEvt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    oadAppEvt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??procSysEvtMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    procSysEvtMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZLOADApp_handleCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZLOADApp_handleCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZLOADApp_handleReply?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZLOADApp_handleReply

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zlRequestNextDataPacket?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zlRequestNextDataPacket

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zlStartClientSession?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zlStartClientSession

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zlResetState?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zlResetState

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZLOADApp_SerialMessageMSGCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZLOADApp_SerialMessageMSGCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zlSendSerial?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zlSendSerial

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zlBuildExternalInboundSerialMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zlBuildExternalInboundSerialMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zlBuildInternalInboundSerialMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zlBuildInternalInboundSerialMSG
   1809          
   1810          /*********************************************************************
   1811           * @fn      zlHandleKeys
   1812           *
   1813           * @brief   Handles all key events for this device.
   1814           *
   1815           * @param   shift - true if in shift/alt.
   1816           * @param   keys - bit field for key events. Valid entries:
   1817           *                 EVAL_SW4
   1818           *                 EVAL_SW3
   1819           *                 EVAL_SW2
   1820           *                 EVAL_SW1
   1821           *
   1822           * @return  none
   1823           */
   1824          static void zlHandleKeys(uint8 shift, uint8 keys)
   1825          {
   1826            // Shift is used to make each button/switch dual purpose.
   1827            if ( shift )
   1828            {
   1829              if ( keys & HAL_KEY_SW_1 )
   1830              {
   1831              }
   1832              if ( keys & HAL_KEY_SW_2 )
   1833              {
   1834              }
   1835              if ( keys & HAL_KEY_SW_3 )
   1836              {
   1837              }
   1838              if ( keys & HAL_KEY_SW_4 )
   1839              {
   1840              }
   1841            }
   1842            else
   1843            {
   1844              if ( keys & HAL_KEY_SW_1 )
   1845              {
   1846                mtxMode = TRUE;
   1847              }
   1848              if ( keys & HAL_KEY_SW_2 )
   1849              {
   1850              }
   1851              if ( keys & HAL_KEY_SW_3 )
   1852              {
   1853                mtxMode = FALSE;
   1854              }
   1855              if ( keys & HAL_KEY_SW_4 )
   1856              {
   1857              }
   1858            }
   1859          }
   1860          #else
   1861          #if (HAL_OAD_XNV_IS_INT && ((HAL_OAD_DL_OSET % HAL_FLASH_PAGE_SIZE) != 0))
   1862          // Bug 2946 - HalXNVWrite() only triggers a page erase when the first byte of a page
   1863          // boundary is written, so when dividing the available internal flash in half results in a
   1864          // page being split in half, this remedial measure is necessary.
   1865          static Status_t zlEraseHalfPage(void)
   1866          {
   1867            const uint16 hPgSz = HAL_FLASH_PAGE_SIZE / 2;
   1868            // HalXNVRead/Write routines add HAL_OAD_DL_OSET to the 'addr' parameter, so pass in a 'negative'.
   1869            const uint32 addr = 0L - hPgSz;
   1870            uint8 *pBuf = osal_mem_alloc(hPgSz);
   1871          
   1872            if (NULL == pBuf)
   1873            {
   1874              return FAILURE;
   1875            }
   1876          
   1877            HalXNVRead(addr, pBuf, hPgSz);
   1878            // This triggers the full page erase and restores the lower half.
   1879            HalXNVWrite(addr, pBuf, hPgSz);
   1880            osal_mem_free(pBuf);
   1881            return SUCCESS;
   1882          }
   1883          #endif
   1884          #endif
   1885          #pragma diag_default=Pa039

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     ZLOADApp_SerialMessageMSGCB        1      0     43
       -> ZLOADApp_handleReply          0      0     48
       -> ZLOADApp_handleCommand        0      0     48
       -> afFindEndPointDesc            0      0     48
       -> AF_DataRequest                0      0     66
     ZLOADApp_handleCommand             1      0     70
       -> osal_mem_alloc                0      0     74
       -> osal_memcpy                   0      0     80
       -> osal_nv_read                  0      0     82
       -> osal_memcpy                   0      0     80
       -> osal_memset                   0      0     74
       -> osal_memcpy                   0      0     86
       -> osal_memcpy                   0      0     80
       -> zlBuildExternalInboundSerialMSG
                                        0      0     74
       -> zlSendSerial                  0      0     74
       -> osal_mem_free                 0      0     74
       -> zlBuildExternalInboundSerialMSG
                                        0      0     74
       -> osal_start_timerEx            0      0     74
       -> osal_set_event                0      0     74
       -> zlSendSerial                  0      0     74
       -> osal_mem_free                 0      0     74
       -> osal_memcmp                   0      0     80
       -> osal_mem_alloc                0      0     74
       -> osal_memcpy                   0      0     80
       -> osal_memcpy                   0      0     80
       -> osal_set_event                0      0     74
       -> osal_nv_read                  0      0     82
       -> memcmp                        0      0     78
       -> zlBuildExternalInboundSerialMSG
                                        0      0     74
       -> zlSendSerial                  0      0     74
       -> osal_mem_free                 0      0     74
       -> osal_set_event                0      0     74
       -> afFindEndPointDesc            0      0     74
       -> AF_DataRequest                0      0     92
       -> zlBuildInternalInboundSerialMSG
                                        0      0     74
       -> zlSendSerial                  0      0     74
       -> osal_mem_free                 0      0     74
     ZLOADApp_handleReply               2      0     51
       -> zlBuildExternalInboundSerialMSG
                                        0      0     36
       -> zlSendSerial                  0      0     36
       -> osal_mem_free                 0      0     36
       -> afFindEndPointDesc            0      0     36
       -> AF_DataRequest                0      0     54
       -> osal_set_event                0      0     36
       -> osal_set_event                0      0     36
       -> zlRequestNextDataPacket       0      0     36
       -> afFindEndPointDesc            0      0     36
       -> AF_DataRequest                0      0     54
       -> osal_memcpy                   0      0     42
       -> zlRequestNextDataPacket       0      0     36
       -> afFindEndPointDesc            0      0     36
       -> AF_DataRequest                0      0     54
     oadAppEvt                          1      0     16
       -> procSysEvtMsg                 0      0     32
       -> zlStartClientSession          0      0     32
       -> osal_mem_alloc                0      0     32
       -> zlBuildInternalInboundSerialMSG
                                        0      0     32
       -> zlSendSerial                  0      0     32
       -> osal_mem_free                 0      0     32
       -> osal_mem_free                 0      0     32
       -> zlResetState                  0      0     32
       -> zlResetState                  0      0     32
       -> zlBuildInternalInboundSerialMSG
                                        0      0     32
       -> zlSendSerial                  0      0     32
       -> osal_mem_free                 0      0     32
       -> osal_start_timerEx            0      0     32
       -> osal_set_event                0      0     32
       -> osal_set_event                0      0     32
     oadAppInit                         1      0     13
       -> afRegister                    0      0     22
       -> osal_nv_item_init             0      0     26
       -> RegisterForKeys               0      0     22
     procSysEvtMsg                      0      0     26
       -> MT_X_FakeNwkJoinCnf           0      0     20
       -> osal_msg_deallocate           0      0     20
       -> osal_msg_receive              0      0     20
       -> ZLOADApp_SerialMessageMSGCB
                                        0      0     20
       -> ZLOADApp_handleReply          0      0     20
       -> ZLOADApp_handleCommand        0      0     20
     zlBuildExternalInboundSerialMSG
                                        1      0     59
       -> osal_mem_alloc                0      0     38
       -> osal_memcpy                   0      0     44
     zlBuildInternalInboundSerialMSG
                                        1      0     56
       -> osal_mem_alloc                0      0     32
       -> osal_memcpy                   0      0     38
     zlRequestNextDataPacket            2      0     28
       -> osal_set_event                0      0     20
       -> osal_stop_timerEx             0      0     20
       -> zlBuildInternalInboundSerialMSG
                                        0      0     20
       -> zlSendSerial                  0      0     20
       -> osal_mem_free                 0      0     20
       -> osal_start_timerEx            0      0     20
       -> osal_set_event                0      0     20
     zlResetState                       2      0     16
       -> osal_stop_timerEx             4      0      0
       -> osal_mem_free                 4      0      0
       -> osal_mem_free                 4      0      0
     zlSendSerial                       0      0     53
       -> osal_mem_alloc                0      0     26
       -> osal_memcpy                   0      0     32
       -> MTProcessAppRspMsg            0      0     26
       -> osal_mem_free                 0      0     26
     zlStartClientSession               1      0     42
       -> osal_mem_alloc                0      0     46
       -> ZMacGetReq                    0      0     46
       -> osal_memcpy                   0      0     52
       -> osal_memcpy                   0      0     52
       -> osal_memcpy                   0      0     52
       -> zlBuildInternalInboundSerialMSG
                                        0      0     46
       -> zlSendSerial                  0      0     46
       -> osal_mem_free                 0      0     46
       -> osal_mem_free                 0      0     46
       -> osal_set_event                0      0     46


   Segment part sizes:

     Function/Label                          Bytes
     --------------                          -----
     _A_IEN0                                    1
     WDCTL                                      1
     oad_app_taskId                             1
     transId                                    1
     dstAddr                                   12
     s_clientInfo                               2
     s_State                                    1
     s_SessionID                                1
     s_blkSize                                  1
     s_NextPacket                               2
     s_NumPktGet                                2
     s_SDCRetryCount                            2
     s_sdcmd                                    2
     s_sdcpayload                               2
     s_sdreply                                  2
     s_pCallback                                2
     s_eventMask                                2
     s_lastTxSeqNum                             1
     s_serialMsg                                1
     s_lastSeqNum                               2
     s_myNwkAddr                                2
     s_PTSeqNum                                 1
     s_PTClientInfo                            35
     OAD_ClusterList                            4
     OAD_SimpleDesc                            12
     OAD_epDesc                                 6
     oadAppInit                                88
     ?Subroutine0                               5
     oadAppEvt                                328
     ?Subroutine1                               5
     ?Subroutine17                              6
     ??Subroutine34_0                          12
     ?Subroutine14                              3
     ??Subroutine35_0                           5
     ?Subroutine11                              3
     ??Subroutine36_0                           6
     ?Subroutine18                              7
     ?Subroutine32                              6
     ??Subroutine38_0                           2
     ??Subroutine39_0                           9
     ?Subroutine5                              12
     ?Subroutine33                              9
     ?Subroutine2                              15
     ?Subroutine31                              9
     procSysEvtMsg                            178
     ?Subroutine20                              6
     ?Subroutine30                              6
     ?Subroutine7                               5
     ZLOADApp_handleCommand                  1287
     ?Subroutine27                              7
     ?Subroutine26                             19
     ?Subroutine16                             19
     ?Subroutine4                              16
     ??Subroutine37_0                           4
     ?Subroutine13                              2
     ??Subroutine40_0                          19
     ?Subroutine22                              2
     ??Subroutine41_0                          11
     ??Subroutine42_0                           6
     ??Subroutine43_0                           3
     ??Subroutine44_0                           6
     ?Subroutine29                              8
     buf                                        2
     ZLOADApp_handleReply                     564
     ?Subroutine21                              3
     ?Subroutine10                              3
     ?Subroutine23                             11
     ?Subroutine12                             16
     ?Subroutine28                              6
     zlRequestNextDataPacket                  101
     zlStartClientSession                     330
     ?Subroutine3                               8
     ?Subroutine9                               9
     zlResetState                              79
     ?Subroutine19                              9
     ZLOADApp_SerialMessageMSGCB              247
     zlSendSerial                              95
     ?Subroutine25                              7
     zlBuildExternalInboundSerialMSG
                                              114
     ?Subroutine15                              4
     ??Subroutine45_0                           8
     ?Subroutine24                             19
     ?Subroutine6                               8
     zlBuildInternalInboundSerialMSG
                                               81
     ?Subroutine8                               5
     ?<Initializer for s_myNwkAddr>             2
     __Constant_3a801                           4
     ??oadAppInit?relay                         6
     ??oadAppEvt?relay                          6
     ??procSysEvtMsg?relay                      6
     ??ZLOADApp_handleCommand?relay             6
     ??ZLOADApp_handleReply?relay               6
     ??zlRequestNextDataPacket?relay            6
     ??zlStartClientSession?relay               6
     ??zlResetState?relay                       6
     ??ZLOADApp_SerialMessageMSGCB?relay        6
     ??zlSendSerial?relay                       6
     ??zlBuildExternalInboundSerialMSG?relay    6
     ??zlBuildInternalInboundSerialMSG?relay    6

 
 3 861 bytes in segment BANKED_CODE
    72 bytes in segment BANK_RELAYS
     2 bytes in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
    26 bytes in segment XDATA_ROM_C
    77 bytes in segment XDATA_Z
 
 3 935 bytes of CODE  memory
    22 bytes of CONST memory (+ 4 bytes shared)
     0 bytes of DATA  memory (+ 2 bytes shared)
    79 bytes of XDATA memory

Errors: none
Warnings: none
