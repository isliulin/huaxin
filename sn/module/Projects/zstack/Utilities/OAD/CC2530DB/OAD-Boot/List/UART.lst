###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             26/Jun/2013  20:05:15 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\UART.c                      #
#    Command line       =  E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\UART.c -D                   #
#                          HAL_OAD_BOOT_CODE -lC E:\workplace\NewStep\Rf\Can_ #
#                          Rf\CanMstOsal\Projects\zstack\Utilities\OAD\CC2530 #
#                          DB\OAD-Boot\List\ -lA E:\workplace\NewStep\Rf\Can_ #
#                          Rf\CanMstOsal\Projects\zstack\Utilities\OAD\CC2530 #
#                          DB\OAD-Boot\List\ --remarks -o                     #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\Obj\ -e    #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large --code_model=near   #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 16 -I     #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\ -I                 #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\SOURCE\ -I          #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\..\..\..\Tools\CC25 #
#                          30DB\ -I E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal #
#                          \Projects\zstack\Utilities\OAD\CC2530DB\..\..\..\Z #
#                          MAIN\TI2530DB\ -I E:\workplace\NewStep\Rf\Can_Rf\C #
#                          anMstOsal\Projects\zstack\Utilities\OAD\CC2530DB\. #
#                          .\..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I           #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\INCLUDE\ -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 5.4\8051\INC\" -I       #
#                          "D:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.4\8051\INC\CLIB\" -Ohz --mfc                     #
#                          --discard_unused_publics                           #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\hal_flash.c                 #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\hal_oad.c                   #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\hal_uart.c                  #
#    List file          =  E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\List\UART. #
#                          lst                                                #
#    Object file        =  E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\Obj\UART.r #
#                          51                                                 #
#                                                                             #
#                                                                             #
###############################################################################

E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Components\hal\target\CC2530EB\UART.c
      1          //-----------串口通讯 接收电脑发数据并发回电脑---------//
      2          /*                  Creat By ES                       */
      3          /*           http://shop101811732.taobao.com          */
      4          /******************************************************
      5          使用串口0， 波特率设定为115200
      6          实验内容：
      7          模块一上电向电脑发送 Hello，Welcome to ES
      8          当接收到电脑的数据（abc#方式发送，#为结束符），把接收到的
      9          数据发回电脑
     10          
     11          注意：使用串口调试助手请将波特率设定为115200，并选择合适
     12          串口号，不要勾选HEX显示。测试本程序首先需要在电脑安装
     13          PL2302 USB转串口驱动，并使用USB线连接模块和电脑
     14          ******************************************************/
     15          
     16          #include <ioCC2530.h>

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc7
   \   unsigned char volatile __sfr MEMCTR
   \                     MEMCTR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf8
   \   union <unnamed> volatile __sfr _A_U1CSR
   \                     _A_U1CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf9
   \   unsigned char volatile __sfr U1DBUF
   \                     U1DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfa
   \   unsigned char volatile __sfr U1BAUD
   \                     U1BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfc
   \   unsigned char volatile __sfr U1GCR
   \                     U1GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     17          #include <string.h>
     18          
     19          #define uint unsigned int
     20          #define uchar unsigned char
     21          
     22          //定义控制LED灯的端口
     23          
     24          #define Blue_LED     P1_4    //P14连接蓝色LED
     25          #define Yellow_LED1  P1_5    //P15连接黄色LED
     26          #define Yellow_LED2  P1_6    //P16连接黄色LED
     27          
     28          #define Bell P2_0	//Bell为P2.0口控制
     29          
     30          //函数声明
     31          void Delayms(uint xms);		//延时函数
     32          void Initial_IO(void);		//初始化端口
     33          void InitUart(void);              //初始化串口
     34          void Uart_Send_String(char *Data,int len);
     35          
     36          char Rxdata[50];
     37          uchar RXTXflag = 1; 
     38          char temp; 
     39          uchar  datanumber = 0;
     40          
     41          /****************************
     42                    延时函数
     43          *****************************/
     44          void Delayms(uint xms)   //i=xms 即延时i毫秒 (16M晶振时候大约数，32M需要修改，系统不修改默认使用内部16M)
     45          {
     46           uint i,j;
     47           for(i=xms;i>0;i--)
     48             for(j=587;j>0;j--);
     49          } 
     50          
     51          
     52          /****************************
     53          //初始化程序
     54          *****************************/
     55          void Initial_IO(void)
     56          {
     57                  P1DIR |= 0xff; //P1定义为输出
     58                  P2DIR |= 0x01;     //P2_0 为输出
     59                  P1=0x00;       //P1口为低，禁止所有LED
     60                  Bell=0;    //禁止蜂鸣器  
     61          }
     62          /**************************************************************** 
     63             串口初始化函数     
     64          ***********************************************************/
     65          void InitUart(void)
     66          {
     67              CLKCONCMD &= ~0x40; // 设置系统时钟源为 32MHZ晶振
     68              while(CLKCONSTA & 0x40);                     // 等待晶振稳定 
     69              CLKCONCMD &= ~0x47;                          // 设置系统主时钟频率为 32MHZ
     70          
     71              PERCFG = 0x00;        //位置1 P0口 
     72              P0SEL = 0x3c;        //P0_2,P0_3,P0_4,P0_5用作串口,第二功能 
     73              P2DIR &= ~0XC0;      //P0 优先作为UART0 ，优先级
     74           
     75              U0CSR |= 0x80;       //UART 方式 
     76              U0GCR |= 11;         //U0GCR与U0BAUD配合     
     77              U0BAUD |= 216;       // 波特率设为115200 
     78              UTX0IF = 0;          //UART0 TX 中断标志初始置位1  （收发时候）
     79              U0CSR |= 0X40;       //允许接收 
     80              IEN0 |= 0x84;        // 开总中断，接收中断    
     81          }
     82          
     83          /**************************************************************** 
     84          串口发送字符串函数    
     85          ****************************************************************/ 
     86          void Uart_Send_String(char *Data,int len) 
     87          {
     88           { 
     89            int j; 
     90            for(j=0;j<len;j++) 
     91            { 
     92              U0DBUF = *Data++; 
     93              while(UTX0IF == 0); //发送完成标志位
     94              UTX0IF = 0; 
     95            } 
     96           }
     97          }
     98          /***************************
     99          //主函数
    100          ***************************/
    101          /*
    102          void main(void)
    103          {
    104            Initial_IO();		//调用初始化函数 
    105            InitUart();
    106            Uart_Send_String("Hello, Welcome to ES  ",22);
    107            while(1)
    108            {
    109               if(RXTXflag == 1)     //接收状态 
    110               { 
    111                  Blue_LED=1;       //接收状态指示 
    112                  if( temp != 0) 
    113                  { 
    114                     if((temp!='#')&&(datanumber<50)) //'＃'被定义为结束字符，最多能接收50个字符           
    115                     Rxdata[datanumber++] = temp; 
    116                     else 
    117                     { 
    118                       RXTXflag = 3;                     //进入发送状态 
    119                       Blue_LED=0;   //关指示灯
    120                      } 
    121                      temp  = 0;
    122                   }
    123                }
    124                if(RXTXflag == 3)     //发送状态 
    125                { 
    126                 Yellow_LED1= 1;                           
    127                 U0CSR &= ~0x40;      //禁止接收 
    128                 Uart_Send_String(Rxdata,datanumber); //发送已记录的字符串。
    129                 U0CSR |= 0x40;      //允许接收 
    130                 RXTXflag = 1;       // 恢复到接收状态 
    131                 datanumber = 0;     //指针归0 
    132                 Yellow_LED1 = 0;       //关发送指示 
    133                }    
    134              }
    135          }
    136          */
    137          /**************************************************************** 
    138          串口接收一个字符: 一旦有数据从串口传至CC2530, 则进入中断，将接收到的数据赋值给变量temp. 
    139          ****************************************************************/ 
    140          /*
    141          #pragma vector = URX0_VECTOR 
    142            __interrupt void UART0_ISR(void) 
    143           { 
    144            URX0IF = 0;    // 清中断标志 
    145            temp = U0DBUF;                           
    146           }
    147          */
                   ^
Remark[Pe001]: last line of file ends without a newline
E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Components\hal\target\CC2530EB\hal_flash.c
      1          /**************************************************************************************************
      2            Filename:       _hal_flash.c
      3            Revised:        $Date:$
      4            Revision:       $Revision:$
      5          
      6            Description: This file contains the interface to the H/W Flash driver.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_board_cfg.h"
     46          #include "hal_dma.h"
     47          #include "hal_flash.h"
     48          #include "hal_types.h"
     49          
     50          /* ------------------------------------------------------------------------------------------------
     51           *                                           Macros
     52           * ------------------------------------------------------------------------------------------------
     53           */
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                          Constants
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          // These values depend on RAM_CODE_FLASH in the .xcl file used.
     61          #if defined CC2530F64     // RemoTI is using 0x01DDD --> pg 3, offset 0x5DD.
     62          #define OSET_OF_RAM_CODE  0x5DD
     63          #define PAGE_OF_RAM_CODE  3
     64          #define SIZE_OF_RAM_CODE  0x23
     65          #elif defined HAL_OAD_BOOT_CODE
     66                                    // OAD boot code is using 0x7E3 --> pg 0, so same as offset 0x7E3.
     67          #define OSET_OF_RAM_CODE  0x7E3
     68          #define PAGE_OF_RAM_CODE  0
     69          #define SIZE_OF_RAM_CODE  0x1D
     70          #elif defined HAL_USB_BOOT_CODE
     71                                    // USB boot code is using 0x7DD --> pg 0, so same as offset 0x7DD.
     72          #define OSET_OF_RAM_CODE  0x7DD
     73          #define PAGE_OF_RAM_CODE  0
     74          #define SIZE_OF_RAM_CODE  0x23
     75          #else                     // Z-Stack is using 0x39EDD --> pg 51, offset 0x6DD.
     76          #define OSET_OF_RAM_CODE  0x6DD
     77          #define PAGE_OF_RAM_CODE  51
     78          #define SIZE_OF_RAM_CODE  0x23
     79          #endif
     80          
     81          /* ------------------------------------------------------------------------------------------------
     82           *                                          Typedefs
     83           * ------------------------------------------------------------------------------------------------
     84           */
     85          
     86          /* ------------------------------------------------------------------------------------------------
     87           *                                       Global Variables
     88           * ------------------------------------------------------------------------------------------------
     89           */
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                       Global Functions
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          
     96          /* ------------------------------------------------------------------------------------------------
     97           *                                       Local Variables
     98           * ------------------------------------------------------------------------------------------------
     99           */
    100          
    101          #pragma location="RAM_CODE_XDATA"

   \                                 In  segment RAM_CODE_XDATA, align 1
    102          static __no_init uint8 ramCode[SIZE_OF_RAM_CODE];
   \                     ??ramCode:
   \   000000                DS 29
    103          
    104          /* ------------------------------------------------------------------------------------------------
    105           *                                       Local Functions
    106           * ------------------------------------------------------------------------------------------------
    107           */
    108          
    109          #pragma location="RAM_CODE_FLASH"
    110          #if defined HAL_OAD_BOOT_CODE
    111          static void HalFlashWriteTrigger(void);
    112          #else
    113          static __monitor void HalFlashWriteTrigger(void);
    114          #endif
    115          
    116          /**************************************************************************************************
    117           * @fn          HalFlashInit
    118           *
    119           * @brief       This function initializes the environment for this module.
    120           *
    121           * input parameters
    122           *
    123           * None.
    124           *
    125           * output parameters
    126           *
    127           * None.
    128           *
    129           * @return      None.
    130           **************************************************************************************************
    131           */
    132          void HalFlashInit(void)
    133          {
    134            // Load the code to run from RAM into its reserved area of RAM once at startup.
    135            HalFlashRead(PAGE_OF_RAM_CODE, OSET_OF_RAM_CODE, ramCode, SIZE_OF_RAM_CODE);
    136          }
    137          
    138          /**************************************************************************************************
    139           * @fn          HalFlashRead
    140           *
    141           * @brief       This function reads 'cnt' bytes from the internal flash.
    142           *
    143           * input parameters
    144           *
    145           * @param       pg - A valid flash page number.
    146           * @param       offset - A valid offset into the page.
    147           * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
    148           * @param       cnt - A valid number of bytes to read.
    149           *
    150           * output parameters
    151           *
    152           * None.
    153           *
    154           * @return      None.
    155           **************************************************************************************************
    156           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    157          void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
   \                     HalFlashRead:
    158          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   740B         MOV     A,#0xb
   \   000009   12....       LCALL   ?XSTACK_DISP0_8
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   FE           MOV     R6,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FF           MOV     R7,A
    159            // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
    160            uint8 *ptr = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
    161                         ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
   \   000011   740F         MOV     A,#0xf
   \   000013   55..         ANL     A,?V0 + 0
   \   000015   F5..         MOV     ?V0 + 2,A
   \   000017   75..00       MOV     ?V0 + 3,#0x0
   \   00001A   740B         MOV     A,#0xb
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?S_SHL
   \   000021   2A           ADD     A,R2
   \   000022   F8           MOV     R0,A
   \   000023   7480         MOV     A,#-0x80
   \   000025   3B           ADDC    A,R3
   \   000026   F9           MOV     R1,A
   \   000027   E4           CLR     A
   \   000028   28           ADD     A,R0
   \   000029   E5..         MOV     A,?V0 + 3
   \   00002B   39           ADDC    A,R1
   \   00002C   F9           MOV     R1,A
    162            uint8 memctr = MEMCTR;  // Save to restore.
   \   00002D   E5C7         MOV     A,0xc7
   \   00002F   F5..         MOV     ?V0 + 1,A
    163          
    164          #if !defined HAL_OAD_BOOT_CODE
    165            halIntState_t is;
    166          #endif
    167          
    168            pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
    169          
    170          #if !defined HAL_OAD_BOOT_CODE
    171            HAL_ENTER_CRITICAL_SECTION(is);
    172          #endif
    173          
    174            // Calculate and map the containing flash bank into XDATA.
    175            MEMCTR = (MEMCTR & 0xF8) | pg;
   \   000031   E5..         MOV     A,?V0 + 0
   \   000033   C4           SWAP    A
   \   000034   540F         ANL     A,#0xf
   \   000036   C0E0         PUSH    A
   \   000038   74F8         MOV     A,#-0x8
   \   00003A   55C7         ANL     A,0xc7
   \   00003C   FA           MOV     R2,A
   \   00003D   D0E0         POP     A
   \   00003F   4A           ORL     A,R2
   \   000040   F5C7         MOV     0xc7,A
   \   000042   801C         SJMP    ??HalFlashRead_0
    176          
    177            while (cnt--)
    178            {
    179              *buf++ = *ptr++;
   \                     ??HalFlashRead_1:
   \   000044   8882         MOV     DPL,R0
   \   000046   8983         MOV     DPH,R1
   \   000048   E0           MOVX    A,@DPTR
   \   000049   8C82         MOV     DPL,R4
   \   00004B   8D83         MOV     DPH,R5
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   8882         MOV     DPL,R0
   \   000050   8983         MOV     DPH,R1
   \   000052   A3           INC     DPTR
   \   000053   A882         MOV     R0,DPL
   \   000055   A983         MOV     R1,DPH
   \   000057   8C82         MOV     DPL,R4
   \   000059   8D83         MOV     DPH,R5
   \   00005B   A3           INC     DPTR
   \   00005C   AC82         MOV     R4,DPL
   \   00005E   AD83         MOV     R5,DPH
    180            }
   \                     ??HalFlashRead_0:
   \   000060   EE           MOV     A,R6
   \   000061   FA           MOV     R2,A
   \   000062   EF           MOV     A,R7
   \   000063   FB           MOV     R3,A
   \   000064   74FF         MOV     A,#-0x1
   \   000066   2A           ADD     A,R2
   \   000067   1E           DEC     R6
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   3B           ADDC    A,R3
   \   00006B   FF           MOV     R7,A
   \   00006C   EA           MOV     A,R2
   \   00006D   7001         JNZ     ??HalFlashRead_2
   \   00006F   EB           MOV     A,R3
   \                     ??HalFlashRead_2:
   \   000070   70D2         JNZ     ??HalFlashRead_1
    181          
    182            MEMCTR = memctr;
   \   000072   85..C7       MOV     0xc7,?V0 + 1
    183          
    184          #if !defined HAL_OAD_BOOT_CODE
    185            HAL_EXIT_CRITICAL_SECTION(is);
    186          #endif
    187          }
   \   000075   7F04         MOV     R7,#0x4
   \   000077   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   00007A                REQUIRE MEMCTR
    188          
    189          /**************************************************************************************************
    190           * @fn          HalFlashWrite
    191           *
    192           * @brief       This function writes 'cnt' bytes to the internal flash.
    193           *
    194           * input parameters
    195           *
    196           * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
    197           * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
    198           * @param       cnt - Number of 4-byte blocks to write.
    199           *
    200           * output parameters
    201           *
    202           * None.
    203           *
    204           * @return      None.
    205           **************************************************************************************************
    206           */
    207           #if HAL_DMA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    208          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
   \                     HalFlashWrite:
    209          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V0 + 0,A
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 1,A
    210            halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
    211          
    212            HAL_DMA_SET_SOURCE(ch, buf);
   \   000011   ED           MOV     A,R5
   \   000012   90....       MOV     DPTR,#dmaCh0
   \   000015   F0           MOVX    @DPTR,A
   \   000016   EC           MOV     A,R4
   \   000017   90....       MOV     DPTR,#(dmaCh0 + 1)
   \   00001A   F0           MOVX    @DPTR,A
    213            HAL_DMA_SET_DEST(ch, &FWDATA);
   \   00001B   7462         MOV     A,#0x62
   \   00001D   90....       MOV     DPTR,#(dmaCh0 + 2)
   \   000020   F0           MOVX    @DPTR,A
   \   000021   7473         MOV     A,#0x73
   \   000023   90....       MOV     DPTR,#(dmaCh0 + 3)
   \   000026   F0           MOVX    @DPTR,A
    214            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
   \   000027   90....       MOV     DPTR,#(dmaCh0 + 4)
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   541F         ANL     A,#0x1f
   \   00002D   F0           MOVX    @DPTR,A
    215            HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   33           RLC     A
   \   000031   33           RLC     A
   \   000032   54FC         ANL     A,#0xfc
   \   000034   90....       MOV     DPTR,#(dmaCh0 + 5)
   \   000037   F0           MOVX    @DPTR,A
   \   000038   7406         MOV     A,#0x6
   \   00003A   78..         MOV     R0,#?V0 + 0
   \   00003C   12....       LCALL   ?US_SHR
   \   00003F   E5..         MOV     A,?V0 + 0
   \   000041   90....       MOV     DPTR,#(dmaCh0 + 4)
   \   000044   F0           MOVX    @DPTR,A
    216            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    217            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    218            HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
   \   000045   7412         MOV     A,#0x12
   \   000047   90....       MOV     DPTR,#(dmaCh0 + 6)
   \   00004A   F0           MOVX    @DPTR,A
    219            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
    220            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
    221            // The DMA is to be polled and shall not issue an IRQ upon completion.
    222            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
    223            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
    224            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
   \   00004B   7442         MOV     A,#0x42
   \   00004D   90....       MOV     DPTR,#(dmaCh0 + 7)
   \   000050   F0           MOVX    @DPTR,A
    225            HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
   \   000051   53D1FE       ANL     0xd1,#0xfe
    226            HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
   \   000054   75D601       MOV     0xd6,#0x1
    227          
    228            FADDRL = (uint8)addr;
   \   000057   EA           MOV     A,R2
   \   000058   906271       MOV     DPTR,#0x6271
   \   00005B   F0           MOVX    @DPTR,A
    229            FADDRH = (uint8)(addr >> 8);
   \   00005C   EB           MOV     A,R3
   \   00005D   906272       MOV     DPTR,#0x6272
   \   000060   F0           MOVX    @DPTR,A
    230            HalFlashWriteTrigger();
   \   000061                ; Setup parameters for call to function HalFlashWriteTrigger
   \   000061   12....       LCALL   ??HalFlashWriteTrigger
    231          }
   \   000064   7F02         MOV     R7,#0x2
   \   000066   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000069                REQUIRE DMAIRQ
   \   000069                REQUIRE DMAARM
    232          #else
    233          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
    234          {
    235            return;
    236          }
    237           #endif
    238          
    239          /**************************************************************************************************
    240           * @fn          HalFlashErase
    241           *
    242           * @brief       This function erases the specified page of the internal flash.
    243           *
    244           * input parameters
    245           *
    246           * @param       pg - A valid flash page number to erase.
    247           *
    248           * output parameters
    249           *
    250           * None.
    251           *
    252           * @return      None.
    253           **************************************************************************************************
    254           */
    255          void HalFlashErase(uint8 pg)
    256          {
    257            FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
    258            FCTL |= 0x01;
    259          }
    260          
    261          /**************************************************************************************************
    262           * @fn          HalFlashWriteTrigger
    263           *
    264           * @brief       This function must be copied to RAM before running because it triggers and then
    265           *              awaits completion of Flash write, which can only be done from RAM.
    266           *
    267           * input parameters
    268           *
    269           * None.
    270           *
    271           * output parameters
    272           *
    273           * None.
    274           *
    275           * @return      None.
    276           **************************************************************************************************
    277           */
    278          #if defined HAL_OAD_BOOT_CODE
    279          #pragma optimize=medium

   \                                 In  segment RAM_CODE_FLASH, align 1, keep-with-next
    280          static void HalFlashWriteTrigger(void)
   \                     ??HalFlashWriteTrigger:
    281          #else
    282          static __monitor void HalFlashWriteTrigger(void)
    283          #endif
    284          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    285            MEMCTR |= 0x08;       // Start the Memory Arbiter running CODE from RAM.
   \   000004   43C708       ORL     0xc7,#0x8
    286            FCTL |= 0x02;         // Trigger the DMA writes.
   \   000007   906270       MOV     DPTR,#0x6270
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   D2E1         SETB    0xE0 /* A   */.1
   \   00000D   F0           MOVX    @DPTR,A
    287            while (FCTL & 0x80);  // Wait until writing is done.
   \                     ??HalFlashWriteTrigger_1:
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000011   40FB         JC      ??HalFlashWriteTrigger_1
    288            MEMCTR &= ~0x08;      // Stop the Memory Arbiter.
   \   000013   53C7F7       ANL     0xc7,#0xf7
    289          }
   \   000016   D083         POP     DPH
   \   000018   D082         POP     DPL
   \   00001A   22           RET
   \   00001B                REQUIRE MEMCTR
    290          
    291          /**************************************************************************************************
    292          */
E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Components\hal\target\CC2530EB\hal_oad.c
      1          /**************************************************************************************************
      2            Filename:       _hal_oad.c
      3            Revised:        $Date: 2008-01-17 12:32:06 -0800 (Thu, 17 Jan 2008) $
      4            Revision:       $Revision: 16224 $
      5          
      6            Description:    This module contains optionally-compiled Boot Code to support OAD.
      7                            The rest of the functionality is the H/W specific drivers to read/write
      8                            the flash/NV containing the ACTIVE and the DOWNLOADED images.
      9            Notes:          This version targets the Texas Instruments CC2x3x family of processors.
     10          
     11          
     12            Copyright 2008-2009 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com.
     41          **************************************************************************************************/
     42          
     43          /* ------------------------------------------------------------------------------------------------
     44           *                                          Includes
     45           * ------------------------------------------------------------------------------------------------
     46           */
     47          
     48          #include "comdef.h"
     49          #include "hal_board_cfg.h"
     50          #include "hal_dma.h"
     51          #include "hal_flash.h"
     52          #include "hal_oad.h"
     53          #include "hal_types.h"
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                           Macros
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          /* ------------------------------------------------------------------------------------------------
     61           *                                          Constants
     62           * ------------------------------------------------------------------------------------------------
     63           */
     64          
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                          Typedefs
     67           * ------------------------------------------------------------------------------------------------
     68           */
     69          
     70          /* ------------------------------------------------------------------------------------------------
     71           *                                       Global Variables
     72           * ------------------------------------------------------------------------------------------------
     73           */
     74          
     75          /* ------------------------------------------------------------------------------------------------
     76           *                                       Global Functions
     77           * ------------------------------------------------------------------------------------------------
     78           */
     79          
     80          /* ------------------------------------------------------------------------------------------------
     81           *                                       Local Variables
     82           * ------------------------------------------------------------------------------------------------
     83           */
     84          
     85          #if HAL_OAD_BOOT_CODE

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     86          halDMADesc_t dmaCh0;
   \                     dmaCh0:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
     87          #endif
     88          
     89          /* ------------------------------------------------------------------------------------------------
     90           *                                       Local Functions
     91           * ------------------------------------------------------------------------------------------------
     92           */
     93          
     94          static uint16 runPoly(uint16 crc, uint8 val);
     95          #if HAL_OAD_XNV_IS_SPI
     96          static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len);
     97          static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len);
     98          #endif
     99          
    100          #if HAL_OAD_BOOT_CODE
    101          static void dl2rc(void);
    102          static uint16 crcCalc(void);
    103          extern void InitUart(void);
    104          extern void Uart_Send_String(char *Data,int len);
    105          
    106          /**************************************************************************************************
    107           * @fn          main
    108           *
    109           * @brief       ISR for the reset vector.
    110           *
    111           * input parameters
    112           *
    113           * None.
    114           *
    115           * output parameters
    116           *
    117           * None.
    118           *
    119           * @return      None.
    120           **************************************************************************************************
    121           */
    122          #pragma location="NEAR_CODE"

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    123          void main(void)
   \                     main:
    124          {
   \   000000                ; Auto size: 4
   \   000000   74FC         MOV     A,#-0x4
   \   000002   12....       LCALL   ?ALLOC_XSTACK8
    125            uint16 crc[2];
    126          
    127            HAL_BOARD_INIT();
   \   000005   53BEFB       ANL     0xbe,#0xfb
   \                     ??main_0:
   \   000008   E59D         MOV     A,0x9d
   \   00000A   A2E6         MOV     C,0xE0 /* A   */.6
   \   00000C   50FA         JNC     ??main_0
   \   00000E   00           NOP
   \   00000F   78F8         MOV     R0,#-0x8
   \   000011   7901         MOV     R1,#0x1
   \                     ??main_1:
   \   000013   00           NOP
   \   000014   E8           MOV     A,R0
   \   000015   24FF         ADD     A,#-0x1
   \   000017   18           DEC     R0
   \   000018   E9           MOV     A,R1
   \   000019   34FF         ADDC    A,#-0x1
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   7001         JNZ     ??main_2
   \   00001F   E9           MOV     A,R1
   \                     ??main_2:
   \   000020   70F1         JNZ     ??main_1
   \   000022   75C600       MOV     0xc6,#0x0
   \                     ??main_3:
   \   000025   E59E         MOV     A,0x9e
   \   000027   70FC         JNZ     ??main_3
   \   000029   43BE04       ORL     0xbe,#0x4
   \   00002C   7408         MOV     A,#0x8
   \   00002E   906270       MOV     DPTR,#0x6270
   \   000031   F0           MOVX    @DPTR,A
   \   000032   43FE01       ORL     0xfe,#0x1
   \   000035   43FE02       ORL     0xfe,#0x2
   \   000038   43FE10       ORL     0xfe,#0x10
   \   00003B   438F01       ORL     0x8f,#0x1
    128          #if HAL_OAD_XNV_IS_SPI
    129            XNV_SPI_INIT();
   \   00003E   75F800       MOV     0xf8,#0x0
   \   000041   75FC0B       MOV     0xfc,#0xb
   \   000044   75FAD8       MOV     0xfa,#-0x28
   \   000047   43FC20       ORL     0xfc,#0x20
   \   00004A   43F102       ORL     0xf1,#0x2
   \   00004D   43F4E0       ORL     0xf4,#0xe0
   \   000050   E5F4         MOV     A,0xf4
   \   000052   53F4F1       ANL     0xf4,#0xf1
   \   000055   E5F4         MOV     A,0xf4
   \   000057   43900E       ORL     0x90,#0xe
   \   00005A   E590         MOV     A,0x90
   \   00005C   C291         CLR     0x90.1
   \   00005E   43FE0E       ORL     0xfe,#0xe
   \   000061   E5FE         MOV     A,0xfe
   \   000063   53F5DF       ANL     0xf5,#0xdf
   \   000066   D2FE         SETB    0xf8.6
   \   000068   D291         SETB    0x90.1
    130          #endif
    131            /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
    132             * descriptors in addition to just Channel 0.
    133             */
    134            HAL_DMA_SET_ADDR_DESC0( &dmaCh0 );
   \   00006A   74..         MOV     A,#((dmaCh0 >> 8) & 0xff)
   \   00006C   F5D5         MOV     0xd5,A
   \   00006E   75D4..       MOV     0xd4,#(dmaCh0 & 0xff)
    135            HalFlashInit();
   \   000071                ; Setup parameters for call to function HalFlashRead
   \   000071   75..1D       MOV     ?V0 + 0,#0x1d
   \   000074   75..00       MOV     ?V0 + 1,#0x0
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   7C..         MOV     R4,#(??ramCode & 0xff)
   \   00007E   7D..         MOV     R5,#((??ramCode >> 8) & 0xff)
   \   000080   7AE3         MOV     R2,#-0x1d
   \   000082   7B07         MOV     R3,#0x7
   \   000084   7900         MOV     R1,#0x0
   \   000086   12....       LCALL   HalFlashRead
   \   000089   7402         MOV     A,#0x2
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
    136          
    137            HalFlashRead(HAL_OAD_CRC_ADDR / HAL_FLASH_PAGE_SIZE,
    138                         HAL_OAD_CRC_ADDR % HAL_FLASH_PAGE_SIZE,
    139                         (uint8 *)crc, sizeof(crc));
   \   00008E                ; Setup parameters for call to function HalFlashRead
   \   00008E   75..04       MOV     ?V0 + 0,#0x4
   \   000091   78..         MOV     R0,#?V0 + 0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   7402         MOV     A,#0x2
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   AC82         MOV     R4,DPL
   \   00009D   AD83         MOV     R5,DPH
   \   00009F   7A88         MOV     R2,#-0x78
   \   0000A1   7B00         MOV     R3,#0x0
   \   0000A3   7901         MOV     R1,#0x1
   \   0000A5   12....       LCALL   HalFlashRead
   \   0000A8   7402         MOV     A,#0x2
   \   0000AA   12....       LCALL   ?DEALLOC_XSTACK8
    140          
    141            if (crc[0] != crc[1])
   \   0000AD   85..82       MOV     DPL,?XSP + 0
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   F8           MOV     R0,A
   \   0000B2   A3           INC     DPTR
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   F9           MOV     R1,A
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   68           XRL     A,R0
   \   0000BC   7003         JNZ     ??main_4
   \   0000BE   A3           INC     DPTR
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   69           XRL     A,R1
   \                     ??main_4:
   \   0000C1   6061         JZ      ??main_5
    142            {
    143              // If the CRC is erased or the RC code fails a sanity check, instantiate the DL code (again).
    144              if ((crc[0] == 0) || (crc[0] != crcCalc()))
   \   0000C3   85..82       MOV     DPL,?XSP + 0
   \   0000C6   85..83       MOV     DPH,?XSP + 1
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   7002         JNZ     ??main_6
   \   0000CC   A3           INC     DPTR
   \   0000CD   E0           MOVX    A,@DPTR
   \                     ??main_6:
   \   0000CE   601A         JZ      ??main_7
   \   0000D0                ; Setup parameters for call to function crcCalc
   \   0000D0   12....       LCALL   ??crcCalc
   \   0000D3   8A..         MOV     ?V0 + 0,R2
   \   0000D5   8B..         MOV     ?V0 + 1,R3
   \   0000D7   A8..         MOV     R0,?V0 + 0
   \   0000D9   A9..         MOV     R1,?V0 + 1
   \   0000DB   85..82       MOV     DPL,?XSP + 0
   \   0000DE   85..83       MOV     DPH,?XSP + 1
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   68           XRL     A,R0
   \   0000E3   7003         JNZ     ??main_8
   \   0000E5   A3           INC     DPTR
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   69           XRL     A,R1
   \                     ??main_8:
   \   0000E8   6005         JZ      ??main_9
    145              {
    146                dl2rc();
   \                     ??main_7:
   \   0000EA                ; Setup parameters for call to function dl2rc
   \   0000EA   12....       LCALL   ??dl2rc
   \   0000ED   8035         SJMP    ??main_5
    147          
    148                /* If dl2rc() fails, a flawed image is allowed to run - 
    149                 * maybe the damage is not fatal to OTA ops?
    150                 */
    151              }
    152              else
    153              {
    154                crc[1] = crc[0];
   \                     ??main_9:
   \   0000EF   85..82       MOV     DPL,?XSP + 0
   \   0000F2   85..83       MOV     DPH,?XSP + 1
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   F8           MOV     R0,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   F9           MOV     R1,A
   \   0000FA   7402         MOV     A,#0x2
   \   0000FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FF   E8           MOV     A,R0
   \   000100   F0           MOVX    @DPTR,A
   \   000101   A3           INC     DPTR
   \   000102   E9           MOV     A,R1
   \   000103   F0           MOVX    @DPTR,A
    155                HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
   \   000104                ; Setup parameters for call to function HalFlashWrite
   \   000104   75..01       MOV     ?V0 + 0,#0x1
   \   000107   75..00       MOV     ?V0 + 1,#0x0
   \   00010A   78..         MOV     R0,#?V0 + 0
   \   00010C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010F   7402         MOV     A,#0x2
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   AC82         MOV     R4,DPL
   \   000116   AD83         MOV     R5,DPH
   \   000118   7A22         MOV     R2,#0x22
   \   00011A   7B02         MOV     R3,#0x2
   \   00011C   12....       LCALL   HalFlashWrite
   \   00011F   7402         MOV     A,#0x2
   \   000121   12....       LCALL   ?DEALLOC_XSTACK8
    156              }
    157            }
    158          
    159          
    160            // Simulate a reset for the Application code by an absolute jump to location 0x0800.
    161            asm("LJMP 0x800\n");
   \                     ??main_5:
   \   000124   020800       LJMP 0x800
    162          }
   \   000127   7404         MOV     A,#0x4
   \   000129   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012C   22           RET
   \   00012D                REQUIRE SLEEPCMD
   \   00012D                REQUIRE CLKCONCMD
   \   00012D                REQUIRE DMA0CFGL
   \   00012D                REQUIRE DMA0CFGH
   \   00012D                REQUIRE PERCFG
   \   00012D                REQUIRE P1SEL
   \   00012D                REQUIRE P2SEL
   \   00012D                REQUIRE _A_U1CSR
   \   00012D                REQUIRE U1BAUD
   \   00012D                REQUIRE U1GCR
   \   00012D                REQUIRE P1DIR
   \   00012D                REQUIRE P0INP
   \   00012D                REQUIRE _A_P1
   \   00012D                REQUIRE SLEEPSTA
   \   00012D                REQUIRE CLKCONSTA
    163          
    164          /*********************************************************************
    165           * @fn      dl2rc
    166           *
    167           * @brief   Copy the DL image to the RC image location.
    168           *
    169           *  NOTE:   Assumes that DL image ends on a flash word boundary.
    170           *
    171           * @param   None.
    172           *
    173           * @return  None.
    174           *********************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    175          static void dl2rc(void)
   \                     ??dl2rc:
    176          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    177            preamble_t preamble;
    178            uint32 oset;
    179            uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   7F02         MOV     R7,#0x2
    180            uint8 buf[4];
    181          
    182            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
   \   00000E                ; Setup parameters for call to function HalOADRead
   \   00000E   75..0C       MOV     ?V0 + 0,#0xc
   \   000011   8E..         MOV     ?V0 + 1,R6
   \   000013   78..         MOV     R0,#?V0 + 0
   \   000015   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000018   7406         MOV     A,#0x6
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   8582..       MOV     ?V0 + 0,DPL
   \   000020   8583..       MOV     ?V0 + 1,DPH
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7901         MOV     R1,#0x1
   \   00002A   90....       MOV     DPTR,#__Constant_8c
   \   00002D   78..         MOV     R0,#?V0 + 0
   \   00002F   12....       LCALL   ?L_MOV_X
   \   000032   AA..         MOV     R2,?V0 + 0
   \   000034   AB..         MOV     R3,?V0 + 1
   \   000036   AC..         MOV     R4,?V0 + 2
   \   000038   AD..         MOV     R5,?V0 + 3
   \   00003A   12....       LCALL   ??Subroutine2_0
   \                     ??CrossCallReturnLabel_2:
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
    183          
    184            for (oset = 0; oset < preamble.len; oset += HAL_FLASH_WORD_SIZE)
   \   000040   90....       MOV     DPTR,#__Constant_0
   \   000043   78..         MOV     R0,#?V0 + 4
   \   000045   12....       LCALL   ?L_MOV_X
   \   000048   807B         SJMP    ??dl2rc_1
    185            {
    186              HalOADRead(oset, buf, HAL_FLASH_WORD_SIZE, HAL_OAD_DL);
   \                     ??dl2rc_2:
   \   00004A                ; Setup parameters for call to function HalOADRead
   \   00004A   75..04       MOV     ?V0 + 0,#0x4
   \   00004D   75..00       MOV     ?V0 + 1,#0x0
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   7402         MOV     A,#0x2
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   8582..       MOV     ?V0 + 0,DPL
   \   00005D   8583..       MOV     ?V0 + 1,DPH
   \   000060   78..         MOV     R0,#?V0 + 0
   \   000062   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000065   7901         MOV     R1,#0x1
   \   000067   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   00006A   12....       LCALL   ?DEALLOC_XSTACK8
    187              if ((addr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
   \   00006D   74FF         MOV     A,#-0x1
   \   00006F   5E           ANL     A,R6
   \   000070   F8           MOV     R0,A
   \   000071   7401         MOV     A,#0x1
   \   000073   5F           ANL     A,R7
   \   000074   F9           MOV     R1,A
   \   000075   E8           MOV     A,R0
   \   000076   7001         JNZ     ??dl2rc_3
   \   000078   E9           MOV     A,R1
   \                     ??dl2rc_3:
   \   000079   701A         JNZ     ??dl2rc_4
    188              {
    189                HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
   \   00007B   8E..         MOV     ?V0 + 0,R6
   \   00007D   8F..         MOV     ?V0 + 1,R7
   \   00007F   7409         MOV     A,#0x9
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   12....       LCALL   ?US_SHR
   \   000086   E5..         MOV     A,?V0 + 0
   \   000088   C3           CLR     C
   \   000089   33           RLC     A
   \   00008A   906272       MOV     DPTR,#0x6272
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   906270       MOV     DPTR,#0x6270
   \   000091   E0           MOVX    A,@DPTR
   \   000092   D2E0         SETB    0xE0 /* A   */.0
   \   000094   F0           MOVX    @DPTR,A
    190              }
    191              HalFlashWrite(addr++, buf, 1);
   \                     ??dl2rc_4:
   \   000095                ; Setup parameters for call to function HalFlashWrite
   \   000095   75..01       MOV     ?V0 + 0,#0x1
   \   000098   75..00       MOV     ?V0 + 1,#0x0
   \   00009B   78..         MOV     R0,#?V0 + 0
   \   00009D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A0   7402         MOV     A,#0x2
   \   0000A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A5   AC82         MOV     R4,DPL
   \   0000A7   AD83         MOV     R5,DPH
   \   0000A9   EE           MOV     A,R6
   \   0000AA   FA           MOV     R2,A
   \   0000AB   EF           MOV     A,R7
   \   0000AC   FB           MOV     R3,A
   \   0000AD   12....       LCALL   HalFlashWrite
   \   0000B0   7402         MOV     A,#0x2
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5   EE           MOV     A,R6
   \   0000B6   2401         ADD     A,#0x1
   \   0000B8   0E           INC     R6
   \   0000B9   EF           MOV     A,R7
   \   0000BA   3400         ADDC    A,#0x0
   \   0000BC   FF           MOV     R7,A
    192            }
   \   0000BD   90....       MOV     DPTR,#__Constant_4
   \   0000C0   78..         MOV     R0,#?V0 + 4
   \   0000C2   12....       LCALL   ?L_ADD_X
   \                     ??dl2rc_1:
   \   0000C5   7406         MOV     A,#0x6
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   78..         MOV     R0,#?V0 + 0
   \   0000CC   12....       LCALL   ?L_MOV_X
   \   0000CF   78..         MOV     R0,#?V0 + 0
   \   0000D1   79..         MOV     R1,#?V0 + 4
   \   0000D3   12....       LCALL   ?UL_GT
   \   0000D6   5003         JNC     $+5
   \   0000D8   02....       LJMP    ??dl2rc_2
    193          }
   \   0000DB   7410         MOV     A,#0x10
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0                REQUIRE ?Subroutine0
   \   0000E0                ; // Fall through to label ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   AA..         MOV     R2,?V0 + 4
   \   000002   AB..         MOV     R3,?V0 + 5
   \   000004   AC..         MOV     R4,?V0 + 6
   \   000006   AD..         MOV     R5,?V0 + 7
   \   000008                REQUIRE ??Subroutine2_0
   \   000008                ; // Fall through to label ??Subroutine2_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   12....       LCALL   HalOADRead
   \   000003   7404         MOV     A,#0x4
   \   000005   22           RET
    194          
    195          /*********************************************************************
    196           * @fn      crcCalc
    197           *
    198           * @brief   Run the CRC16 Polynomial calculation over the RC image.
    199           *
    200           * @param   None.
    201           *
    202           * @return  The CRC16 calculated.
    203           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    204          static uint16 crcCalc(void)
   \                     ??crcCalc:
    205          {
   \   000000   74E9         MOV     A,#-0x17
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 23
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    206            preamble_t preamble;
    207            uint32 oset;
    208            uint16 crc = 0;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   \   00000D   75..00       MOV     ?V0 + 1,#0x0
    209          
    210            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
   \   000010                ; Setup parameters for call to function HalOADRead
   \   000010   75..0C       MOV     ?V0 + 2,#0xc
   \   000013   75..00       MOV     ?V0 + 3,#0x0
   \   000016   78..         MOV     R0,#?V0 + 2
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   8582..       MOV     ?V0 + 2,DPL
   \   000023   8583..       MOV     ?V0 + 3,DPH
   \   000026   78..         MOV     R0,#?V0 + 2
   \   000028   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002B   7900         MOV     R1,#0x0
   \   00002D   90....       MOV     DPTR,#__Constant_8c
   \   000030   78..         MOV     R0,#?V0 + 4
   \   000032   12....       LCALL   ?L_MOV_X
   \   000035   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   000038   12....       LCALL   ?DEALLOC_XSTACK8
    211          
    212            // Run the CRC calculation over the active body of code.
    213            for (oset = 0; oset < preamble.len; oset++)
   \   00003B   90....       MOV     DPTR,#__Constant_0
   \   00003E   78..         MOV     R0,#?V0 + 8
   \   000040   12....       LCALL   ?L_MOV_X
   \   000043   806B         SJMP    ??crcCalc_1
    214            {
    215              if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
   \                     ??crcCalc_2:
   \   000045   85....       MOV     ?V0 + 4,?V0 + 8
   \   000048   85....       MOV     ?V0 + 5,?V0 + 9
   \   00004B   85....       MOV     ?V0 + 6,?V0 + 10
   \   00004E   85....       MOV     ?V0 + 7,?V0 + 11
   \   000051   90....       MOV     DPTR,#__Constant_ffffff78
   \   000054   78..         MOV     R0,#?V0 + 4
   \   000056   12....       LCALL   ?L_ADD_X
   \   000059   90....       MOV     DPTR,#__Constant_4
   \   00005C   78..         MOV     R0,#?V0 + 12
   \   00005E   12....       LCALL   ?L_MOV_X
   \   000061   78..         MOV     R0,#?V0 + 12
   \   000063   79..         MOV     R1,#?V0 + 4
   \   000065   12....       LCALL   ?UL_GT
   \   000068   403E         JC      ??crcCalc_3
    216              {
    217                uint8 buf;
    218                HalOADRead(oset, &buf, 1, HAL_OAD_RC);
   \   00006A                ; Setup parameters for call to function HalOADRead
   \   00006A   75..01       MOV     ?V0 + 2,#0x1
   \   00006D   75..00       MOV     ?V0 + 3,#0x0
   \   000070   78..         MOV     R0,#?V0 + 2
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   7402         MOV     A,#0x2
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   8582..       MOV     ?V0 + 2,DPL
   \   00007D   8583..       MOV     ?V0 + 3,DPH
   \   000080   78..         MOV     R0,#?V0 + 2
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   7900         MOV     R1,#0x0
   \   000087   AA..         MOV     R2,?V0 + 8
   \   000089   AB..         MOV     R3,?V0 + 9
   \   00008B   AC..         MOV     R4,?V0 + 10
   \   00008D   AD..         MOV     R5,?V0 + 11
   \   00008F   12....       LCALL   ??Subroutine2_0
   \                     ??CrossCallReturnLabel_3:
   \   000092   12....       LCALL   ?DEALLOC_XSTACK8
    219                crc = runPoly(crc, buf);
   \   000095                ; Setup parameters for call to function runPoly
   \   000095   85..82       MOV     DPL,?XSP + 0
   \   000098   85..83       MOV     DPH,?XSP + 1
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   F9           MOV     R1,A
   \   00009D   AA..         MOV     R2,?V0 + 0
   \   00009F   AB..         MOV     R3,?V0 + 1
   \   0000A1   12....       LCALL   ??runPoly
   \   0000A4   8A..         MOV     ?V0 + 0,R2
   \   0000A6   8B..         MOV     ?V0 + 1,R3
    220              }
    221            }
   \                     ??crcCalc_3:
   \   0000A8   90....       MOV     DPTR,#__Constant_1
   \   0000AB   78..         MOV     R0,#?V0 + 8
   \   0000AD   12....       LCALL   ?L_ADD_X
   \                     ??crcCalc_1:
   \   0000B0   7403         MOV     A,#0x3
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   78..         MOV     R0,#?V0 + 4
   \   0000B7   12....       LCALL   ?L_MOV_X
   \   0000BA   78..         MOV     R0,#?V0 + 4
   \   0000BC   79..         MOV     R1,#?V0 + 8
   \   0000BE   12....       LCALL   ?UL_GT
   \   0000C1   4082         JC      ??crcCalc_2
    222          
    223            // IAR note explains that poly must be run with value zero for each byte of crc.
    224            crc = runPoly(crc, 0);
    225            crc = runPoly(crc, 0);
    226          
    227            return crc;
   \   0000C3                ; Setup parameters for call to function runPoly
   \   0000C3                ; Setup parameters for call to function runPoly
   \   0000C3   7900         MOV     R1,#0x0
   \   0000C5   AA..         MOV     R2,?V0 + 0
   \   0000C7   AB..         MOV     R3,?V0 + 1
   \   0000C9   12....       LCALL   ??runPoly
   \   0000CC   7900         MOV     R1,#0x0
   \   0000CE   12....       LCALL   ??runPoly
   \   0000D1   740D         MOV     A,#0xd
   \   0000D3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D6   7F10         MOV     R7,#0x10
   \   0000D8   02....       LJMP    ?FUNC_LEAVE_XDATA
    228          }
    229          #endif
    230          
    231          /*********************************************************************
    232           * @fn      runPoly
    233           *
    234           * @brief   Run the CRC16 Polynomial calculation over the byte parameter.
    235           *
    236           * @param   crc - Running CRC calculated so far.
    237           * @param   val - Value on which to run the CRC16.
    238           *
    239           * @return  crc - Updated for the run.
    240           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    241          static uint16 runPoly(uint16 crc, uint8 val)
   \                     ??runPoly:
    242          {
   \   000000   EE           MOV     A,R6
   \   000001   C0E0         PUSH    A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
    243            const uint16 poly = 0x1021;
    244            uint8 cnt;
    245          
    246            for (cnt = 0; cnt < 8; cnt++, val <<= 1)
   \   000003   7E08         MOV     R6,#0x8
    247            {
    248              uint8 msb = (crc & 0x8000) ? 1 : 0;
   \                     ??runPoly_1:
   \   000005   7480         MOV     A,#-0x80
   \   000007   5B           ANL     A,R3
   \   000008   FD           MOV     R5,A
   \   000009   E4           CLR     A
   \   00000A   7001         JNZ     ??runPoly_2
   \   00000C   ED           MOV     A,R5
   \                     ??runPoly_2:
   \   00000D   6004         JZ      ??runPoly_3
   \   00000F   D2F0         SETB    B.0
   \   000011   8002         SJMP    ??runPoly_4
   \                     ??runPoly_3:
   \   000013   C2F0         CLR     B.0
   \                     ??runPoly_4:
   \   000015   A2F0         MOV     C,B.0
   \   000017   E4           CLR     A
   \   000018   92E0         MOV     0xE0 /* A   */.0,C
   \   00001A   FC           MOV     R4,A
    249          
    250              crc <<= 1;
   \   00001B   EA           MOV     A,R2
   \   00001C   C3           CLR     C
   \   00001D   33           RLC     A
   \   00001E   FA           MOV     R2,A
   \   00001F   EB           MOV     A,R3
   \   000020   33           RLC     A
   \   000021   FB           MOV     R3,A
    251              if (val & 0x80)  crc |= 0x0001;
   \   000022   E9           MOV     A,R1
   \   000023   A2E7         MOV     C,0xE0 /* A   */.7
   \   000025   5004         JNC     ??runPoly_5
   \   000027   7401         MOV     A,#0x1
   \   000029   4A           ORL     A,R2
   \   00002A   FA           MOV     R2,A
    252              if (msb)         crc ^= poly;
   \                     ??runPoly_5:
   \   00002B   EC           MOV     A,R4
   \   00002C   6008         JZ      ??runPoly_6
   \   00002E   7421         MOV     A,#0x21
   \   000030   6A           XRL     A,R2
   \   000031   FA           MOV     R2,A
   \   000032   7410         MOV     A,#0x10
   \   000034   6B           XRL     A,R3
   \   000035   FB           MOV     R3,A
    253            }
   \                     ??runPoly_6:
   \   000036   E9           MOV     A,R1
   \   000037   C3           CLR     C
   \   000038   33           RLC     A
   \   000039   F9           MOV     R1,A
   \   00003A   1E           DEC     R6
   \   00003B   EE           MOV     A,R6
   \   00003C   70C7         JNZ     ??runPoly_1
    254          
    255            return crc;
   \   00003E   D0E0         POP     A
   \   000040   FE           MOV     R6,A
   \   000041   22           RET
    256          }
    257          
    258          /*********************************************************************
    259           * @fn      HalOADChkDL
    260           *
    261           * @brief   Run the CRC16 Polynomial calculation over the DL image.
    262           *
    263           * @param   dlImagePreambleOffset - Offset into the monolithic DL image to read the preamble.
    264           *
    265           * @return  SUCCESS or FAILURE.
    266           *********************************************************************/
    267          uint8 HalOADChkDL(uint8 dlImagePreambleOffset)
    268          {
    269            preamble_t preamble;
    270            uint32 oset;
    271            uint16 crc = 0, crc2;
    272          
    273            HalOADRead(dlImagePreambleOffset, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
    274          
    275            // Run the CRC calculation over the downloaded image.
    276            for (oset = 0; oset < preamble.len; oset++)
    277            {
    278              if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
    279              {
    280                uint8 buf;
    281                HalOADRead(oset, &buf, 1, HAL_OAD_DL);
    282                crc = runPoly(crc, buf);
    283              }
    284            }
    285          
    286            // IAR note explains that poly must be run with value zero for each byte of crc.
    287            crc = runPoly(crc, 0);
    288            crc = runPoly(crc, 0);
    289          
    290            HalOADRead(HAL_OAD_CRC_OSET, (uint8 *)&crc2, sizeof(crc2), HAL_OAD_DL);
    291            return (crc2 == crc) ? SUCCESS : FAILURE;
    292          }
    293          
    294          /*********************************************************************
    295           * @fn      HalOADInvRC
    296           *
    297           * @brief   Invalidate the active image so that the boot code will instantiate the DL image on the
    298           *          next reset.
    299           *
    300           * @param   None.
    301           *
    302           * @return  None.
    303           *********************************************************************/
    304          void HalOADInvRC(void)
    305          {
    306            uint16 crc[2] = {0,0xFFFF};
    307            HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
    308          }
    309          
    310          /*********************************************************************
    311           * @fn      HalOADRead
    312           *
    313           * @brief   Read from the storage medium according to image type.
    314           *
    315           * @param   oset - Offset into the monolithic image.
    316           * @param   pBuf - Pointer to the buffer in which to copy the bytes read.
    317           * @param   len - Number of bytes to read.
    318           * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
    319           *
    320           * @return  None.
    321           *********************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    322          void HalOADRead(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
   \                     HalOADRead:
    323          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   E9           MOV     A,R1
   \   00000E   FE           MOV     R6,A
   \   00000F   740F         MOV     A,#0xf
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 4,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V0 + 5,A
   \   00001B   7411         MOV     A,#0x11
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 6,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 7,A
    324            if (HAL_OAD_RC != type)
   \   000027   EE           MOV     A,R6
   \   000028   6014         JZ      ??HalOADRead_0
    325            {
    326          #if HAL_OAD_XNV_IS_INT
    327              preamble_t preamble;
    328          
    329              HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    330              //oset += HAL_OAD_RC_START + preamble.len;
    331              oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
    332          #elif HAL_OAD_XNV_IS_SPI
    333              oset += HAL_OAD_DL_OSET;
    334              HalSPIRead(oset, pBuf, len);
   \   00002A                ; Setup parameters for call to function HalSPIRead
   \   00002A   78..         MOV     R0,#?V0 + 6
   \   00002C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002F   78..         MOV     R0,#?V0 + 4
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   12....       LCALL   ??HalSPIRead
   \   000037   7404         MOV     A,#0x4
   \   000039   12....       LCALL   ?DEALLOC_XSTACK8
    335              return;
   \   00003C   8032         SJMP    ??HalOADRead_1
    336          #endif
    337            }
    338            else
    339            {
    340              oset += HAL_OAD_RC_START;
   \                     ??HalOADRead_0:
   \   00003E   90....       MOV     DPTR,#__Constant_800
   \   000041   78..         MOV     R0,#?V0 + 0
   \   000043   12....       LCALL   ?L_ADD_X
    341            }
    342          
    343            HalFlashRead(oset / HAL_FLASH_PAGE_SIZE, oset % HAL_FLASH_PAGE_SIZE, pBuf, len);
   \   000046                ; Setup parameters for call to function HalFlashRead
   \   000046   78..         MOV     R0,#?V0 + 6
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   AC..         MOV     R4,?V0 + 4
   \   00004D   AD..         MOV     R5,?V0 + 5
   \   00004F   85....       MOV     ?V0 + 4,?V0 + 0
   \   000052   85....       MOV     ?V0 + 5,?V0 + 1
   \   000055   74FF         MOV     A,#-0x1
   \   000057   55..         ANL     A,?V0 + 4
   \   000059   FA           MOV     R2,A
   \   00005A   7407         MOV     A,#0x7
   \   00005C   55..         ANL     A,?V0 + 5
   \   00005E   FB           MOV     R3,A
   \   00005F   740B         MOV     A,#0xb
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?UL_SHR
   \   000066   A9..         MOV     R1,?V0 + 0
   \   000068   12....       LCALL   HalFlashRead
   \   00006B   7402         MOV     A,#0x2
   \   00006D   12....       LCALL   ?DEALLOC_XSTACK8
    344          }
   \                     ??HalOADRead_1:
   \   000070   02....       LJMP    ?Subroutine0
    345          
    346          /*********************************************************************
    347           * @fn      HalOADWrite
    348           *
    349           * @brief   Write to the storage medium according to the image type.
    350           *
    351           *  NOTE:   Destructive write on page boundary! When writing to the first flash word
    352           *          of a page boundary, the page is erased without saving/restoring the bytes not written.
    353           *          Writes anywhere else on a page assume that the location written to has been erased.
    354           *
    355           * @param   oset - Offset into the monolithic image, aligned to HAL_FLASH_WORD_SIZE.
    356           * @param   pBuf - Pointer to the buffer in from which to write.
    357           * @param   len - Number of bytes to write. If not an even multiple of HAL_FLASH_WORD_SIZE,
    358           *                remainder bytes are overwritten with garbage.
    359           * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
    360           *
    361           * @return  None.
    362           *********************************************************************/
    363          void HalOADWrite(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
    364          {
    365            if (HAL_OAD_RC != type)
    366            {
    367          #if HAL_OAD_XNV_IS_INT
    368              preamble_t preamble;
    369          
    370              HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    371              //oset += HAL_OAD_RC_START + preamble.len;
    372              oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
    373          #elif HAL_OAD_XNV_IS_SPI
    374              oset += HAL_OAD_DL_OSET;
    375              HalSPIWrite(oset, pBuf, len);
    376              return;
    377          #endif
    378            }
    379            else
    380            {
    381              oset += HAL_OAD_RC_START;
    382            }
    383          
    384            if ((oset % HAL_FLASH_PAGE_SIZE) == 0)
    385            {
    386              HalFlashErase(oset / HAL_FLASH_PAGE_SIZE);
    387            }
    388          
    389            HalFlashWrite(oset / HAL_FLASH_WORD_SIZE, pBuf, len / HAL_FLASH_WORD_SIZE);
    390          }
    391          
    392          #if HAL_OAD_XNV_IS_INT
    393          /*********************************************************************
    394           * @fn      HalOADAvail
    395           *
    396           * @brief   Determine the space available for downloading an image.
    397           *
    398           * @param   None.
    399           *
    400           * @return  Number of bytes available for storing an OAD image.
    401           *********************************************************************/
    402          uint32 HalOADAvail(void)
    403          {
    404            /*
    405            preamble_t preamble;
    406          
    407            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    408            return HAL_OAD_DL_MAX - preamble.len;
    409             */
    410            return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
    411          }
    412          
    413          #elif HAL_OAD_XNV_IS_SPI
    414          
    415          /*********************************************************************
    416           * CONSTANTS
    417           */
    418          
    419          #define XNV_STAT_CMD  0x05
    420          #define XNV_WREN_CMD  0x06
    421          #define XNV_WRPG_CMD  0x0A
    422          #define XNV_READ_CMD  0x0B
    423          
    424          #define XNV_STAT_WIP  0x01
    425          
    426          /*********************************************************************
    427           * @fn      xnvSPIWrite
    428           *
    429           * @brief   SPI write sequence for code size savings.
    430           *
    431           * @param   ch - The byte to write to the SPI.
    432           *
    433           * @return  None.
    434           *********************************************************************/
    435          static void xnvSPIWrite(uint8 ch);

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    436          static void xnvSPIWrite(uint8 ch)
   \                     ??xnvSPIWrite:
    437          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    438            XNV_SPI_TX(ch);
   \   000000   C2F9         CLR     0xf8.1
   \   000002   89F9         MOV     0xf9,R1
    439            XNV_SPI_WAIT_RXRDY();
   \                     ??xnvSPIWrite_1:
   \   000004   A2F9         MOV     C,0xf8.1
   \   000006   50FC         JNC     ??xnvSPIWrite_1
    440          }
   \   000008   22           RET
   \   000009                REQUIRE _A_U1CSR
   \   000009                REQUIRE U1DBUF
    441          
    442          /*********************************************************************
    443           * @fn      HalOADAvail
    444           *
    445           * @brief   Determine the space available for downloading an image.
    446           *
    447           * @param   None.
    448           *
    449           * @return  Number of bytes available for storing an OAD image.
    450           *********************************************************************/
    451          uint32 HalOADAvail(void)
    452          {
    453            return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
    454          }
    455          
    456          /*********************************************************************
    457           * @fn      HalSPIRead
    458           *
    459           * @brief   Read from the external NV storage via SPI.
    460           *
    461           * @param   addr - Offset into the external NV.
    462           * @param   pBuf - Pointer to the buffer in which to copy the bytes read from external NV.
    463           * @param   len - Number of bytes to read from external NV.
    464           *
    465           * @return  None.
    466           *********************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    467          static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len)
   \                     ??HalSPIRead:
    468          {
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 4,R2
   \   000007   8B..         MOV     ?V0 + 5,R3
   \   000009   8C..         MOV     ?V0 + 6,R4
   \   00000B   8D..         MOV     ?V0 + 7,R5
   \   00000D   7413         MOV     A,#0x13
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
   \   000017   7415         MOV     A,#0x15
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 2,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 3,A
    469          #if !HAL_OAD_BOOT_CODE
    470            uint8 shdw = P1DIR;
    471            halIntState_t his;
    472            HAL_ENTER_CRITICAL_SECTION(his);
    473            P1DIR |= BV(3);
    474          #endif
    475          
    476            XNV_SPI_BEGIN();
   \   000023   C293         CLR     0x90.3
    477            do {
    478              xnvSPIWrite(XNV_STAT_CMD);
   \                     ??HalSPIRead_1:
   \   000025                ; Setup parameters for call to function xnvSPIWrite
   \   000025   7905         MOV     R1,#0x5
   \   000027   12....       LCALL   ??xnvSPIWrite
    479            } while (XNV_SPI_RX() & XNV_STAT_WIP);
   \   00002A   E5F9         MOV     A,0xf9
   \   00002C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002E   40F5         JC      ??HalSPIRead_1
    480            XNV_SPI_END();
   \   000030   D293         SETB    0x90.3
    481            asm("NOP"); asm("NOP");
   \   000032   00           NOP
   \   000033   00           NOP
    482          
    483            XNV_SPI_BEGIN();
   \   000034   C293         CLR     0x90.3
    484            xnvSPIWrite(XNV_READ_CMD);
   \   000036                ; Setup parameters for call to function xnvSPIWrite
   \   000036   790B         MOV     R1,#0xb
   \   000038   12....       LCALL   ??xnvSPIWrite
    485            xnvSPIWrite(addr >> 16);
   \   00003B                ; Setup parameters for call to function xnvSPIWrite
   \   00003B   85....       MOV     ?V0 + 8,?V0 + 4
   \   00003E   85....       MOV     ?V0 + 9,?V0 + 5
   \   000041   85....       MOV     ?V0 + 10,?V0 + 6
   \   000044   85....       MOV     ?V0 + 11,?V0 + 7
   \   000047   7410         MOV     A,#0x10
   \   000049   78..         MOV     R0,#?V0 + 8
   \   00004B   12....       LCALL   ?UL_SHR
   \   00004E   85....       MOV     ?V0 + 0,?V0 + 8
   \   000051   A9..         MOV     R1,?V0 + 0
   \   000053   12....       LCALL   ??xnvSPIWrite
    486            xnvSPIWrite(addr >> 8);
   \   000056                ; Setup parameters for call to function xnvSPIWrite
   \   000056   85....       MOV     ?V0 + 1,?V0 + 5
   \   000059   A9..         MOV     R1,?V0 + 1
   \   00005B   12....       LCALL   ??xnvSPIWrite
    487            xnvSPIWrite(addr);
   \   00005E                ; Setup parameters for call to function xnvSPIWrite
   \   00005E   85....       MOV     ?V0 + 0,?V0 + 4
   \   000061   A9..         MOV     R1,?V0 + 0
   \   000063   12....       LCALL   ??xnvSPIWrite
    488            xnvSPIWrite(0);
   \   000066                ; Setup parameters for call to function xnvSPIWrite
   \   000066   7900         MOV     R1,#0x0
   \   000068   12....       LCALL   ??xnvSPIWrite
   \   00006B   8011         SJMP    ??HalSPIRead_2
    489          
    490            while (len--)
    491            {
    492              xnvSPIWrite(0);
   \                     ??HalSPIRead_3:
   \   00006D                ; Setup parameters for call to function xnvSPIWrite
   \   00006D   7900         MOV     R1,#0x0
   \   00006F   12....       LCALL   ??xnvSPIWrite
    493              *pBuf++ = XNV_SPI_RX();
   \   000072   E5F9         MOV     A,0xf9
   \   000074   8E82         MOV     DPL,R6
   \   000076   8F83         MOV     DPH,R7
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   AE82         MOV     R6,DPL
   \   00007C   AF83         MOV     R7,DPH
    494            }
   \                     ??HalSPIRead_2:
   \   00007E   A8..         MOV     R0,?V0 + 2
   \   000080   A9..         MOV     R1,?V0 + 3
   \   000082   74FF         MOV     A,#-0x1
   \   000084   28           ADD     A,R0
   \   000085   F5..         MOV     ?V0 + 2,A
   \   000087   74FF         MOV     A,#-0x1
   \   000089   39           ADDC    A,R1
   \   00008A   F5..         MOV     ?V0 + 3,A
   \   00008C   E8           MOV     A,R0
   \   00008D   7001         JNZ     ??HalSPIRead_4
   \   00008F   E9           MOV     A,R1
   \                     ??HalSPIRead_4:
   \   000090   70DB         JNZ     ??HalSPIRead_3
    495            XNV_SPI_END();
   \   000092   D293         SETB    0x90.3
    496          
    497          #if !HAL_OAD_BOOT_CODE
    498            P1DIR = shdw;
    499            HAL_EXIT_CRITICAL_SECTION(his);
    500          #endif
    501          }
   \   000094   7F0C         MOV     R7,#0xc
   \   000096   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000099                REQUIRE U1DBUF
   \   000099                REQUIRE _A_P1

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_8c:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_8c>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_8c>`:
   \   000000   8C000000     DD 140

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_4:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_4>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_4>`:
   \   000000   04000000     DD 4

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffffff78:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffffff78>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffffff78>`:
   \   000000   78FFFFFF     DD 4294967160

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_1:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_1>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_1>`:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_800:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_800>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_800>`:
   \   000000   00080000     DD 2048
    502          
    503          /*********************************************************************
    504           * @fn      HalSPIWrite
    505           *
    506           * @brief   Write to the external NV storage via SPI.
    507           *
    508           * @param   addr - Offset into the external NV.
    509           * @param   pBuf - Pointer to the buffer in from which to write bytes to external NV.
    510           * @param   len - Number of bytes to write to external NV.
    511           *
    512           * @return  None.
    513           *********************************************************************/
    514          static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len)
    515          {
    516            uint8 cnt;
    517          #if !HAL_OAD_BOOT_CODE
    518            uint8 shdw = P1DIR;
    519            halIntState_t his;
    520            HAL_ENTER_CRITICAL_SECTION(his);
    521            P1DIR |= BV(3);
    522          #endif
    523          
    524            while (len)
    525            {
    526              XNV_SPI_BEGIN();
    527              do {
    528                xnvSPIWrite(XNV_STAT_CMD);
    529              } while (XNV_SPI_RX() & XNV_STAT_WIP);
    530              XNV_SPI_END();
    531              asm("NOP"); asm("NOP");
    532          
    533              XNV_SPI_BEGIN();
    534              xnvSPIWrite(XNV_WREN_CMD);
    535              XNV_SPI_END();
    536              asm("NOP"); asm("NOP");
    537          
    538              XNV_SPI_BEGIN();
    539              xnvSPIWrite(XNV_WRPG_CMD);
    540              xnvSPIWrite(addr >> 16);
    541              xnvSPIWrite(addr >> 8);
    542              xnvSPIWrite(addr);
    543          
    544              // Can only write within any one page boundary, so prepare for next page write if bytes remain.
    545              cnt = 0 - (uint8)addr;
    546              if (cnt)
    547              {
    548                addr += cnt;
    549              }
    550              else
    551              {
    552                addr += 256;
    553              }
    554          
    555              do
    556              {
    557                xnvSPIWrite(*pBuf++);
    558                cnt--;
    559                len--;
    560              } while (len && cnt);
    561              XNV_SPI_END();
    562            }
    563          
    564          #if !HAL_OAD_BOOT_CODE
    565            P1DIR = shdw;
    566            HAL_EXIT_CRITICAL_SECTION(his);
    567          #endif
    568          }
    569          #else
    570          #error Invalid Xtra-NV for OAD.
    571          #endif
    572          
    573          /**************************************************************************************************
    574          */
E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Components\hal\target\CC2530EB\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart.c
      3            Revised:        $Date: 2009-06-12 09:16:43 -0700 (Fri, 12 Jun 2009) $
      4            Revision:       $Revision: 20142 $
      5          
      6            Description: This file contains the interface to the H/W UART driver.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_board_cfg.h"
     45          #include "hal_defs.h"
     46          #include "hal_types.h"
     47          #include "hal_uart.h"
     48          
     49          /*********************************************************************
     50           * MACROS
     51           */
     52          
     53          /*********************************************************************
     54           * TYPEDEFS
     55           */
     56          
     57          /*********************************************************************
     58           * CONSTANTS
     59           */
     60          
     61          /*********************************************************************
     62           * GLOBAL VARIABLES
     63           */
     64          
     65          /*********************************************************************
     66           * GLOBAL FUNCTIONS
     67           */
     68          
     69          /*********************************************************************
     70           * LOCAL VARIABLES
     71           */
     72          
     73          /*********************************************************************
     74           * LOCAL FUNCTIONS
     75           */
     76          
     77          #if HAL_UART_DMA
     78          #include "_hal_uart_dma.c"
     79          #endif
     80          #if HAL_UART_ISR
     81          #include "_hal_uart_isr.c"
     82          #endif
     83          #if HAL_UART_USB
     84          #include "_hal_uart_usb.c"
     85          #endif
     86          
     87          /******************************************************************************
     88           * @fn      HalUARTInit
     89           *
     90           * @brief   Initialize the UART
     91           *
     92           * @param   none
     93           *
     94           * @return  none
     95           *****************************************************************************/
     96          void HalUARTInit(void)
     97          {
     98          #if HAL_UART_DMA
     99            HalUARTInitDMA();
    100          #endif
    101          #if HAL_UART_ISR
    102            HalUARTInitISR();
    103          #endif
    104          #if HAL_UART_USB
    105            HalUARTInitUSB();
    106          #endif
    107          }
    108          
    109          /******************************************************************************
    110           * @fn      HalUARTOpen
    111           *
    112           * @brief   Open a port according tp the configuration specified by parameter.
    113           *
    114           * @param   port   - UART port
    115           *          config - contains configuration information
    116           *
    117           * @return  Status of the function call
    118           *****************************************************************************/
    119          uint8 HalUARTOpen(uint8 port, halUARTCfg_t *config)
    120          {
    121            (void)port;
    122            (void)config;
    123          
    124          #if (HAL_UART_DMA == 1)
    125            if (port == HAL_UART_PORT_0)  HalUARTOpenDMA(config);
    126          #endif
    127          #if (HAL_UART_DMA == 2)
    128            if (port == HAL_UART_PORT_1)  HalUARTOpenDMA(config);
    129          #endif
    130          #if (HAL_UART_ISR == 1)
    131            if (port == HAL_UART_PORT_0)  HalUARTOpenISR(config);
    132          #endif
    133          #if (HAL_UART_ISR == 2)
    134            if (port == HAL_UART_PORT_1)  HalUARTOpenISR(config);
    135          #endif
    136          #if (HAL_UART_USB)
    137            HalUARTOpenUSB(config);
    138          #endif
    139            
    140            return HAL_UART_SUCCESS;
    141          }
    142          
    143          /*****************************************************************************
    144           * @fn      HalUARTRead
    145           *
    146           * @brief   Read a buffer from the UART
    147           *
    148           * @param   port - USART module designation
    149           *          buf  - valid data buffer at least 'len' bytes in size
    150           *          len  - max length number of bytes to copy to 'buf'
    151           *
    152           * @return  length of buffer that was read
    153           *****************************************************************************/
    154          uint16 HalUARTRead(uint8 port, uint8 *buf, uint16 len)
    155          {
    156            (void)port;
    157            (void)buf;
    158            (void)len;
    159          
    160          #if (HAL_UART_DMA == 1)
    161            if (port == HAL_UART_PORT_0)  return HalUARTReadDMA(buf, len);
    162          #endif
    163          #if (HAL_UART_DMA == 2)
    164            if (port == HAL_UART_PORT_1)  return HalUARTReadDMA(buf, len);
    165          #endif
    166          #if (HAL_UART_ISR == 1)
    167            if (port == HAL_UART_PORT_0)  return HalUARTReadISR(buf, len);
    168          #endif
    169          #if (HAL_UART_ISR == 2)
    170            if (port == HAL_UART_PORT_1)  return HalUARTReadISR(buf, len);
    171          #endif
    172          
    173          #if HAL_UART_USB
    174            return HalUARTRx(buf, len);
    175          #else
    176            return 0;
    177          #endif
    178          }
    179          
    180          /******************************************************************************
    181           * @fn      HalUARTWrite
    182           *
    183           * @brief   Write a buffer to the UART.
    184           *
    185           * @param   port - UART port
    186           *          buf  - pointer to the buffer that will be written, not freed
    187           *          len  - length of
    188           *
    189           * @return  length of the buffer that was sent
    190           *****************************************************************************/
    191          uint16 HalUARTWrite(uint8 port, uint8 *buf, uint16 len)
    192          {
    193            (void)port;
    194            (void)buf;
    195            (void)len;
    196          
    197          #if (HAL_UART_DMA == 1)
    198            if (port == HAL_UART_PORT_0)  return HalUARTWriteDMA(buf, len);
    199          #endif
    200          #if (HAL_UART_DMA == 2)
    201            if (port == HAL_UART_PORT_1)  return HalUARTWriteDMA(buf, len);
    202          #endif
    203          #if (HAL_UART_ISR == 1)
    204            if (port == HAL_UART_PORT_0)  return HalUARTWriteISR(buf, len);
    205          #endif
    206          #if (HAL_UART_ISR == 2)
    207            if (port == HAL_UART_PORT_1)  return HalUARTWriteISR(buf, len);
    208          #endif
    209          
    210          #if HAL_UART_USB
    211            HalUARTTx(buf, len);
    212            return len;
    213          #else
    214            return 0;
    215          #endif
    216          }
    217          
    218          /******************************************************************************
    219           * @fn      HalUARTSuspend
    220           *
    221           * @brief   Suspend UART hardware before entering PM mode 1, 2 or 3.
    222           *
    223           * @param   None
    224           *
    225           * @return  None
    226           *****************************************************************************/
    227          void HalUARTSuspend( void )
    228          {
    229          #if HAL_UART_DMA
    230            HalUARTSuspendDMA();
    231          #endif
    232          #if HAL_UART_ISR
    233            HalUARTSuspendISR();
    234          #endif
    235          }
    236          
    237          /******************************************************************************
    238           * @fn      HalUARTResume
    239           *
    240           * @brief   Resume UART hardware after exiting PM mode 1, 2 or 3.
    241           *
    242           * @param   None
    243           *
    244           * @return  None
    245           *****************************************************************************/
    246          void HalUARTResume( void )
    247          {
    248          #if HAL_UART_DMA
    249            HalUARTResumeDMA();
    250          #endif
    251          #if HAL_UART_ISR
    252            HalUARTResumeISR();
    253          #endif
    254          }
    255          
    256          /***************************************************************************************************
    257           * @fn      HalUARTPoll
    258           *
    259           * @brief   Poll the UART.
    260           *
    261           * @param   none
    262           *
    263           * @return  none
    264           *****************************************************************************/
    265          void HalUARTPoll(void)
    266          {
    267          #if HAL_UART_DMA
    268            HalUARTPollDMA();
    269          #endif
    270          #if HAL_UART_ISR
    271            HalUARTPollISR();
    272          #endif
    273          #if HAL_UART_USB
    274            HalUARTPollUSB();
    275          #endif
    276          }
    277          
    278          /**************************************************************************************************
    279           * @fn      Hal_UART_RxBufLen()
    280           *
    281           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    282           *
    283           * @param   port - UART port
    284           *
    285           * @return  length of current Rx Buffer
    286           **************************************************************************************************/
    287          uint16 Hal_UART_RxBufLen( uint8 port )
    288          {
    289            (void)port;
    290          
    291          #if (HAL_UART_DMA == 1)
    292            if (port == HAL_UART_PORT_0)  return HalUARTRxAvailDMA();
    293          #endif
    294          #if (HAL_UART_DMA == 2)
    295            if (port == HAL_UART_PORT_1)  return HalUARTRxAvailDMA();
    296          #endif
    297          #if (HAL_UART_ISR == 1)
    298            if (port == HAL_UART_PORT_0)  return HalUARTRxAvailISR();
    299          #endif
    300          #if (HAL_UART_ISR == 2)
    301            if (port == HAL_UART_PORT_1)  return HalUARTRxAvailISR();
    302          #endif
    303          #if HAL_UART_USB
    304            return HalUARTRxAvailUSB();
    305          #else
    306            return 0;
    307          #endif
    308          }
    309          
    310          /******************************************************************************
    311          ******************************************************************************/

   Maximum stack usage in bytes:

     Function                  ISTACK PSTACK XSTACK
     --------                  ------ ------ ------
     HalFlashRead                  1      0     28
     HalFlashWrite                 0      0     42
       -> HalFlashWriteTrigger     0      0     18
     HalFlashWriteTrigger          2      0      9
     HalOADRead                    0      0     59
       -> HalSPIRead               0      0     38
       -> HalFlashRead             0      0     34
     HalSPIRead                    1      0     38
       -> xnvSPIWrite              0      0     38
       -> xnvSPIWrite              0      0     38
       -> xnvSPIWrite              0      0     38
       -> xnvSPIWrite              0      0     38
       -> xnvSPIWrite              0      0     38
       -> xnvSPIWrite              0      0     38
       -> xnvSPIWrite              0      0     38
     crcCalc                       0      0     44
       -> HalOADRead               0      0     80
       -> HalOADRead               0      0     80
       -> runPoly                  0      0     72
       -> runPoly                  0      0     72
       -> runPoly                  0      0     72
     dl2rc                         0      0     39
       -> HalOADRead               0      0     70
       -> HalOADRead               0      0     70
       -> HalFlashWrite            0      0     66
     main                          0      0      6
       -> HalFlashRead             0      0     12
       -> HalFlashRead             0      0     12
       -> crcCalc                  0      0      8
       -> dl2rc                    0      0      8
       -> HalFlashWrite            0      0     12
     runPoly                       1      0     36
     xnvSPIWrite                   0      0     19


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     P0INP                                     1
     _A_P1                                     1
     SLEEPSTA                                  1
     CLKCONSTA                                 1
     SLEEPCMD                                  1
     CLKCONCMD                                 1
     MEMCTR                                    1
     DMAIRQ                                    1
     DMA0CFGL                                  1
     DMA0CFGH                                  1
     DMAARM                                    1
     PERCFG                                    1
     P1SEL                                     1
     P2SEL                                     1
     _A_U1CSR                                  1
     U1DBUF                                    1
     U1BAUD                                    1
     U1GCR                                     1
     P1DIR                                     1
     ramCode                                  29
     HalFlashRead                            122
     HalFlashWrite                           105
     HalFlashWriteTrigger                     27
     dmaCh0                                    8
     main                                    301
     dl2rc                                   224
     ?Subroutine0                              5
     ?Subroutine1                              8
     ??Subroutine2_0                           6
     crcCalc                                 219
     runPoly                                  66
     HalOADRead                              115
     xnvSPIWrite                               9
     HalSPIRead                              153
     __Constant_8c                             4
     ?<Initializer for __Constant_8c>          4
     __Constant_0                              4
     ?<Initializer for __Constant_0>           4
     __Constant_4                              4
     ?<Initializer for __Constant_4>           4
     __Constant_ffffff78                       4
     ?<Initializer for __Constant_ffffff78>    4
     __Constant_1                              4
     ?<Initializer for __Constant_1>           4
     __Constant_800                            4
     ?<Initializer for __Constant_800>         4

 
 1 333 bytes in segment NEAR_CODE
    27 bytes in segment RAM_CODE_FLASH
    29 bytes in segment RAM_CODE_XDATA
    19 bytes in segment SFR_AN
    24 bytes in segment XDATA_I
    24 bytes in segment XDATA_ID
     8 bytes in segment XDATA_Z
 
 1 360 bytes of CODE  memory (+ 24 bytes shared)
     0 bytes of DATA  memory (+ 19 bytes shared)
    37 bytes of XDATA memory (+ 24 bytes shared)

Errors: none
Warnings: none
