///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.4.40412/W32 for 8051        19/Jun/2016  18:59:08 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  near                                              /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Users\freeman\Documents\work\SN\module\Compone /
//                          nts\hal\target\CC2530EB\hal_flash.c               /
//    Command line       =  C:\Users\freeman\Documents\work\SN\module\Compone /
//                          nts\hal\target\CC2530EB\hal_flash.c -D            /
//                          HAL_OAD_BOOT_CODE -lC C:\Users\freeman\Documents\ /
//                          work\SN\module\Projects\zstack\Utilities\OAD\CC25 /
//                          30DB\OAD-Boot\List\ -lA                           /
//                          C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\OAD-Boot\List\    /
//                          --remarks -o C:\Users\freeman\Documents\work\SN\m /
//                          odule\Projects\zstack\Utilities\OAD\CC2530DB\OAD- /
//                          Boot\Obj\ -e --debug --core=plain --dptr=16,1     /
//                          --data_model=large --code_model=near              /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data --nr_virtual_regs 16 -I    /
//                          C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\ -I               /
//                          C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\SOURCE\ -I        /
//                          C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\..\..\..\Tools\CC /
//                          2530DB\ -I C:\Users\freeman\Documents\work\SN\mod /
//                          ule\Projects\zstack\Utilities\OAD\CC2530DB\..\..\ /
//                          ..\ZMAIN\TI2530DB\ -I C:\Users\freeman\Documents\ /
//                          work\SN\module\Projects\zstack\Utilities\OAD\CC25 /
//                          30DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I    /
//                          C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\CO /
//                          MPONENTS\OSAL\INCLUDE\ -I                         /
//                          C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\CO /
//                          MPONENTS\hal\common\ -I                           /
//                          C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\CO /
//                          MPONENTS\HAL\TARGET\CC2530EB\ -Ohz                /
//                          --require_prototypes --mfc                        /
//                          --discard_unused_publics                          /
//                          C:\Users\freeman\Documents\work\SN\module\Compone /
//                          nts\hal\target\CC2530EB\hal_oad.c                 /
//                          C:\Users\freeman\Documents\work\SN\module\Compone /
//                          nts\hal\target\CC2530EB\hal_uart.c                /
//    List file          =  C:\Users\freeman\Documents\work\SN\module\Project /
//                          s\zstack\Utilities\OAD\CC2530DB\OAD-Boot\List\hal /
//                          _flash.s51                                        /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME hal_flash

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "near"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?L_ADD_X
        EXTERN ?L_EQ_X
        EXTERN ?L_MOV_X
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?UL_GE_X
        EXTERN ?UL_GT_X
        EXTERN ?UL_SHR
        EXTERN ?US_SHR
        EXTERN ?V0
        EXTERN ?XLOAD_R2345
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTORE_R2345
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        FUNCTION ??HalFlashWriteTrigger,0203H
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION ??MemReadRam,0203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        FUNCTION ??Message_Rcv,021203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        FUNCTION ??Message_Send,021203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        FUNCTION ??RcvData,0203H
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION ??SendData,0203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCTION ??crcCalc,021203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 32, STACK
        FUNCTION ??dl2rc,021203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 35, STACK
        FUNCTION ??halAesEncrDecr,0203H
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 17, STACK
        FUNCTION ??putsDialog,021203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION ??runPoly,0203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBWEAK CLKCONCMD
        PUBWEAK CLKCONSTA
        PUBWEAK DMA0CFGH
        PUBWEAK DMA0CFGL
        PUBWEAK DMAARM
        PUBWEAK DMAIRQ
        PUBWEAK ENCCS
        PUBWEAK ENCDI
        PUBWEAK ENCDO
        PUBLIC HalFlashErase
        FUNCTION HalFlashErase,0203H
        ARGFRAME XSTACK, 31, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC HalFlashRead
        FUNCTION HalFlashRead,0203H
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC HalFlashWrite
        FUNCTION HalFlashWrite,021203H
        ARGFRAME XSTACK, 33, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBLIC HalOADRead
        FUNCTION HalOADRead,021203H
        ARGFRAME XSTACK, 35, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 15, STACK
        PUBWEAK MEMCTR
        PUBWEAK P0DIR
        PUBWEAK P0SEL
        PUBWEAK P1DIR
        PUBWEAK PERCFG
        PUBWEAK SLEEPCMD
        PUBWEAK SLEEPSTA
        PUBWEAK U0BAUD
        PUBWEAK U0CSR
        PUBWEAK U0DBUF
        PUBWEAK U0GCR
        PUBWEAK _A_IRCON2
        PUBWEAK _A_P0
        PUBWEAK _A_P1
        PUBWEAK _A_TCON
        PUBWEAK __Constant_0
        PUBWEAK __Constant_1
        PUBWEAK __Constant_20000
        PUBWEAK __Constant_20001
        PUBWEAK __Constant_3a4d3254
        PUBWEAK __Constant_4
        PUBWEAK __Constant_8c
        PUBWEAK __Constant_f8900a6
        PUBWEAK __Constant_ffffff78
        PUBLIC dmaCh0
        PUBLIC main
        FUNCTION main,0a1a03H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 22, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:16, ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
// C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_flash.c
//    1 /**************************************************************************************************
//    2   Filename:       _hal_flash.c
//    3   Revised:        $Date:$
//    4   Revision:       $Revision:$
//    5 
//    6   Description: This file contains the interface to the H/W Flash driver.
//    7 
//    8 
//    9   Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 #include "hal_board_cfg.h"

        ASEGN SFR_AN:DATA:NOROOT,080H
// union <unnamed> volatile __sfr _A_P0
_A_P0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,086H
// unsigned char volatile __sfr U0CSR
U0CSR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,088H
// union <unnamed> volatile __sfr _A_TCON
_A_TCON:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,090H
// union <unnamed> volatile __sfr _A_P1
_A_P1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09dH
// unsigned char volatile __sfr SLEEPSTA
SLEEPSTA:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09eH
// unsigned char volatile __sfr CLKCONSTA
CLKCONSTA:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b1H
// unsigned char volatile __sfr ENCDI
ENCDI:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b2H
// unsigned char volatile __sfr ENCDO
ENCDO:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b3H
// unsigned char volatile __sfr ENCCS
ENCCS:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0beH
// unsigned char volatile __sfr SLEEPCMD
SLEEPCMD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c1H
// unsigned char volatile __sfr U0DBUF
U0DBUF:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c2H
// unsigned char volatile __sfr U0BAUD
U0BAUD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c5H
// unsigned char volatile __sfr U0GCR
U0GCR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c6H
// unsigned char volatile __sfr CLKCONCMD
CLKCONCMD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c7H
// unsigned char volatile __sfr MEMCTR
MEMCTR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d1H
// unsigned char volatile __sfr DMAIRQ
DMAIRQ:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d4H
// unsigned char volatile __sfr DMA0CFGL
DMA0CFGL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d5H
// unsigned char volatile __sfr DMA0CFGH
DMA0CFGH:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d6H
// unsigned char volatile __sfr DMAARM
DMAARM:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e8H
// union <unnamed> volatile __sfr _A_IRCON2
_A_IRCON2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f1H
// unsigned char volatile __sfr PERCFG
PERCFG:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f3H
// unsigned char volatile __sfr P0SEL
P0SEL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0fdH
// unsigned char volatile __sfr P0DIR
P0DIR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0feH
// unsigned char volatile __sfr P1DIR
P1DIR:
        DATA8
        DS 1
//   46 #include "hal_dma.h"
//   47 #include "hal_flash.h"
//   48 #include "hal_types.h"
//   49 
//   50 /* ------------------------------------------------------------------------------------------------
//   51  *                                           Macros
//   52  * ------------------------------------------------------------------------------------------------
//   53  */
//   54 
//   55 /* ------------------------------------------------------------------------------------------------
//   56  *                                          Constants
//   57  * ------------------------------------------------------------------------------------------------
//   58  */
//   59 
//   60 // These values depend on RAM_CODE_FLASH in the .xcl file used.
//   61 #if defined CC2530F64     // RemoTI is using 0x01DDD --> pg 3, offset 0x5DD.
//   62 #define OSET_OF_RAM_CODE  0x5DD
//   63 #define PAGE_OF_RAM_CODE  3
//   64 #define SIZE_OF_RAM_CODE  0x23
//   65 #elif defined HAL_OAD_BOOT_CODE
//   66                           // OAD boot code is using 0x7E3 --> pg 0, so same as offset 0x7E3.
//   67 #define OSET_OF_RAM_CODE  0x7E3
//   68 #define PAGE_OF_RAM_CODE  0
//   69 #define SIZE_OF_RAM_CODE  0x1D
//   70 #elif defined HAL_USB_BOOT_CODE
//   71                           // USB boot code is using 0x7DD --> pg 0, so same as offset 0x7DD.
//   72 #define OSET_OF_RAM_CODE  0x7DD
//   73 #define PAGE_OF_RAM_CODE  0
//   74 #define SIZE_OF_RAM_CODE  0x23
//   75 #else                     // Z-Stack is using 0x39EDD --> pg 51, offset 0x6DD.
//   76 #define OSET_OF_RAM_CODE  0x6DD
//   77 #define PAGE_OF_RAM_CODE  51
//   78 #define SIZE_OF_RAM_CODE  0x23
//   79 #endif
//   80 
//   81 /* ------------------------------------------------------------------------------------------------
//   82  *                                          Typedefs
//   83  * ------------------------------------------------------------------------------------------------
//   84  */
//   85 
//   86 /* ------------------------------------------------------------------------------------------------
//   87  *                                       Global Variables
//   88  * ------------------------------------------------------------------------------------------------
//   89  */
//   90 
//   91 /* ------------------------------------------------------------------------------------------------
//   92  *                                       Global Functions
//   93  * ------------------------------------------------------------------------------------------------
//   94  */
//   95 
//   96 /* ------------------------------------------------------------------------------------------------
//   97  *                                       Local Variables
//   98  * ------------------------------------------------------------------------------------------------
//   99  */
//  100 
//  101 #pragma location="RAM_CODE_XDATA"

        RSEG RAM_CODE_XDATA:XDATA:REORDER:NOROOT(0)
        DATA8
//  102 static __no_init uint8 ramCode[SIZE_OF_RAM_CODE];
??ramCode:
        DS 29
//  103 
//  104 /* ------------------------------------------------------------------------------------------------
//  105  *                                       Local Functions
//  106  * ------------------------------------------------------------------------------------------------
//  107  */
//  108 
//  109 #pragma location="RAM_CODE_FLASH"
//  110 #if defined HAL_OAD_BOOT_CODE
//  111 static void HalFlashWriteTrigger(void);
//  112 #else
//  113 static __monitor void HalFlashWriteTrigger(void);
//  114 #endif
//  115 
//  116 /**************************************************************************************************
//  117  * @fn          HalFlashInit
//  118  *
//  119  * @brief       This function initializes the environment for this module.
//  120  *
//  121  * input parameters
//  122  *
//  123  * None.
//  124  *
//  125  * output parameters
//  126  *
//  127  * None.
//  128  *
//  129  * @return      None.
//  130  **************************************************************************************************
//  131  */
//  132 void HalFlashInit(void)
//  133 {
//  134   // Load the code to run from RAM into its reserved area of RAM once at startup.
//  135   HalFlashRead(PAGE_OF_RAM_CODE, OSET_OF_RAM_CODE, ramCode, SIZE_OF_RAM_CODE);
//  136 }
//  137 
//  138 
//  139 /**************************************************************************************************
//  140  * @fn          HalFlashRead
//  141  *
//  142  * @brief       This function reads 'cnt' bytes from the internal flash.
//  143  *
//  144  * input parameters
//  145  *
//  146  * @param       pg - A valid flash page number.
//  147  * @param       offset - A valid offset into the page.
//  148  * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
//  149  * @param       cnt - A valid number of bytes to read.
//  150  *
//  151  * output parameters
//  152  *
//  153  * None.
//  154  *
//  155  * @return      None.
//  156  **************************************************************************************************
//  157  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  158 void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
HalFlashRead:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function HalFlashRead
        CODE
//  159 {
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  160   // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
//  161   uint8 *ptr = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
//  162                ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
        MOV     A,#0xf
        ANL     A,?V0 + 0
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,#0x0
        MOV     A,#0xb
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,R2
        ADD     A,#0x0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,#-0x80
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x0
        MOV     A,R1
        ADDC    A,?V0 + 3
        MOV     R1,A
//  163   uint8 memctr = MEMCTR;  // Save to restore.
        MOV     A,0xc7
        MOV     ?V0 + 1,A
//  164 
//  165 #if !defined HAL_OAD_BOOT_CODE
//  166   halIntState_t is;
//  167 #endif
//  168 
//  169   pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
//  170 
//  171 #if !defined HAL_OAD_BOOT_CODE
//  172   HAL_ENTER_CRITICAL_SECTION(is);
//  173 #endif
//  174 
//  175   // Calculate and map the containing flash bank into XDATA.
//  176   MEMCTR = (MEMCTR & 0xF8) | pg;
        MOV     A,?V0 + 0
        SWAP    A
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,0xc7
        ANL     A,#0xf8
        ORL     A,R2
        MOV     0xc7,A
        SJMP    ??HalFlashRead_0
//  177 
//  178   while (cnt--)
//  179   {
//  180     *buf++ = *ptr++;
??HalFlashRead_1:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  181   }
??HalFlashRead_0:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     A,R2
        ADD     A,#-0x1
        DEC     R6
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R7,A
        MOV     A,R2
        ORL     A,R3
        JNZ     ??HalFlashRead_1
//  182 
//  183   MEMCTR = memctr;
        MOV     0xc7,?V0 + 1
//  184 
//  185 #if !defined HAL_OAD_BOOT_CODE
//  186   HAL_EXIT_CRITICAL_SECTION(is);
//  187 #endif
//  188 }
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock0
        REQUIRE MEMCTR
//  189 
//  190 /**************************************************************************************************
//  191  * @fn          HalFlashWrite
//  192  *
//  193  * @brief       This function writes 'cnt' bytes to the internal flash.
//  194  *
//  195  * input parameters
//  196  *
//  197  * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
//  198  * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
//  199  * @param       cnt - Number of 4-byte blocks to write.
//  200  *
//  201  * output parameters
//  202  *
//  203  * None.
//  204  *
//  205  * @return      None.
//  206  **************************************************************************************************
//  207  */
//  208  #if HAL_DMA

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  209 void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
HalFlashWrite:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function HalFlashWrite
        CODE
//  210 {
        FUNCALL HalFlashWrite, ??HalFlashWriteTrigger
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
//  211   halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
//  212 
//  213   HAL_DMA_SET_SOURCE(ch, buf);
        MOV     A,R5
        MOV     DPTR,#dmaCh0
        MOVX    @DPTR,A
        MOV     A,R4
        INC     DPTR
        MOVX    @DPTR,A
//  214   HAL_DMA_SET_DEST(ch, &FWDATA);
        INC     DPTR
        MOV     A,#0x62
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x73
        MOVX    @DPTR,A
//  215   HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
//  216   HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
        MOV     A,?V0 + 0
        RLC     A
        RLC     A
        ANL     A,#0xfc
        INC     DPTR
        MOVX    @DPTR,A
        MOV     A,#0x6
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
        MOV     A,?V0 + 0
        MOV     DPTR,#dmaCh0 + 4
        MOVX    @DPTR,A
//  217   HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
//  218   HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
//  219   HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
        MOV     DPTR,#dmaCh0 + 6
        MOV     A,#0x12
        MOVX    @DPTR,A
//  220   HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
//  221   HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
//  222   // The DMA is to be polled and shall not issue an IRQ upon completion.
//  223   HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
//  224   HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
//  225   HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
        INC     DPTR
        MOV     A,#0x42
        MOVX    @DPTR,A
//  226   HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
        ANL     0xd1,#0xfe
//  227   HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
        MOV     0xd6,#0x1
//  228 
//  229   FADDRL = (uint8)addr;
        MOV     A,R2
        MOV     DPTR,#0x6271
        MOVX    @DPTR,A
//  230   FADDRH = (uint8)(addr >> 8);
        MOV     A,R3
        INC     DPTR
        MOVX    @DPTR,A
//  231   HalFlashWriteTrigger();
        ; Setup parameters for call to function HalFlashWriteTrigger
        LCALL   ??HalFlashWriteTrigger
        CFI EndBlock cfiBlock1
//  232 }
        REQUIRE ?Subroutine0
        REQUIRE DMAIRQ
        REQUIRE DMAARM
        ; // Fall through to label ?Subroutine0

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock2
//  233 #else
//  234 void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
//  235 {
//  236   return;
//  237 }
//  238  #endif
//  239 
//  240 /**************************************************************************************************
//  241  * @fn          HalFlashErase
//  242  *
//  243  * @brief       This function erases the specified page of the internal flash.
//  244  *
//  245  * input parameters
//  246  *
//  247  * @param       pg - A valid flash page number to erase.
//  248  *
//  249  * output parameters
//  250  *
//  251  * None.
//  252  *
//  253  * @return      None.
//  254  **************************************************************************************************
//  255  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  256 void HalFlashErase(uint8 pg)
HalFlashErase:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function HalFlashErase
        CODE
//  257 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
//  258   FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
        MOV     A,R1
        CLR     C
        RLC     A
        MOV     DPTR,#0x6272
        MOVX    @DPTR,A
//  259   FCTL |= 0x01;
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
//  260 }
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock3
//  261 
//  262 /**************************************************************************************************
//  263  * @fn          HalFlashWriteTrigger
//  264  *
//  265  * @brief       This function must be copied to RAM before running because it triggers and then
//  266  *              awaits completion of Flash write, which can only be done from RAM.
//  267  *
//  268  * input parameters
//  269  *
//  270  * None.
//  271  *
//  272  * output parameters
//  273  *
//  274  * None.
//  275  *
//  276  * @return      None.
//  277  **************************************************************************************************
//  278  */
//  279 #if defined HAL_OAD_BOOT_CODE
//  280 #pragma optimize=medium

        RSEG RAM_CODE_FLASH:CODE:NOROOT(0)
//  281 static void HalFlashWriteTrigger(void)
??HalFlashWriteTrigger:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function ??HalFlashWriteTrigger
        CODE
//  282 #else
//  283 static __monitor void HalFlashWriteTrigger(void)
//  284 #endif
//  285 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
//  286   MEMCTR |= 0x08;       // Start the Memory Arbiter running CODE from RAM.
        ORL     0xc7,#0x8
//  287   FCTL |= 0x02;         // Trigger the DMA writes.
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
//  288   while (FCTL & 0x80);  // Wait until writing is done.
??HalFlashWriteTrigger_1:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.7
        JC      ??HalFlashWriteTrigger_1
//  289   MEMCTR &= ~0x08;      // Stop the Memory Arbiter.
        ANL     0xc7,#0xf7
//  290 }
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-3
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-2
        RET
        CFI EndBlock cfiBlock4
        REQUIRE MEMCTR
//  291 
//  292 /**************************************************************************************************
//  293 */
// C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_oad.c
//    1 /**************************************************************************************************
//    2   Filename:       _hal_oad.c
//    3   Revised:        $Date: 2008-01-17 12:32:06 -0800 (Thu, 17 Jan 2008) $
//    4   Revision:       $Revision: 16224 $
//    5 
//    6   Description:    This module contains optionally-compiled Boot Code to support OAD.
//    7                   The rest of the functionality is the H/W specific drivers to read/write
//    8                   the flash/NV containing the ACTIVE and the DOWNLOADED images.
//    9   Notes:          This version targets the Texas Instruments CC2x3x family of processors.
//   10 
//   11 
//   12   Copyright 2008-2009 Texas Instruments Incorporated. All rights reserved.
//   13 
//   14   IMPORTANT: Your use of this Software is limited to those specific rights
//   15   granted under the terms of a software license agreement between the user
//   16   who downloaded the software, his/her employer (which must be your employer)
//   17   and Texas Instruments Incorporated (the "License").  You may not use this
//   18   Software unless you agree to abide by the terms of the License. The License
//   19   limits your use, and you acknowledge, that the Software may not be modified,
//   20   copied or distributed unless embedded on a Texas Instruments microcontroller
//   21   or used solely and exclusively in conjunction with a Texas Instruments radio
//   22   frequency transceiver, which is integrated into your product.  Other than for
//   23   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   24   works of, modify, distribute, perform, display or sell this Software and/or
//   25   its documentation for any purpose.
//   26 
//   27   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   28   PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   29   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   30   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   31   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   32   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   33   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   34   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   35   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   36   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   37   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   38 
//   39   Should you have any questions regarding your right to use this Software,
//   40   contact Texas Instruments Incorporated at www.TI.com.
//   41 **************************************************************************************************/
//   42 
//   43 /* ------------------------------------------------------------------------------------------------
//   44  *                                          Includes
//   45  * ------------------------------------------------------------------------------------------------
//   46  */
//   47 #include <ioCC2530.h>
//   48 #include "comdef.h"
//   49 #include "hal_board_cfg.h"
//   50 #include "hal_dma.h"
//   51 #include "hal_flash.h"
//   52 #include "hal_oad.h"
//   53 #include "hal_types.h"
//   54 //#include "stdio.h"
//   55 //#include "hal_aes.h"
//   56 
//   57 /* ------------------------------------------------------------------------------------------------
//   58  *                                           Macros
//   59  * ------------------------------------------------------------------------------------------------
//   60  */
//   61 
//   62 /* ------------------------------------------------------------------------------------------------
//   63  *                                          Constants
//   64  * ------------------------------------------------------------------------------------------------
//   65  */
//   66 
//   67 /* ------------------------------------------------------------------------------------------------
//   68  *                                          Typedefs
//   69  * ------------------------------------------------------------------------------------------------
//   70  */
//   71 
//   72 /* ------------------------------------------------------------------------------------------------
//   73  *                                       Global Variables
//   74  * ------------------------------------------------------------------------------------------------
//   75  */
//   76 
//   77 /* ------------------------------------------------------------------------------------------------
//   78  *                                       Global Functions
//   79  * ------------------------------------------------------------------------------------------------
//   80  */
//   81 
//   82 /* ------------------------------------------------------------------------------------------------
//   83  *                                       Local Variables
//   84  * ------------------------------------------------------------------------------------------------
//   85  */
//   86 
//   87 #if HAL_OAD_BOOT_CODE

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   88 halDMADesc_t dmaCh0;
dmaCh0:
        DS 8
        REQUIRE __INIT_XDATA_Z
//   89 #endif
//   90 
//   91 /* ------------------------------------------------------------------------------------------------
//   92  *                                       Local Functions
//   93  * ------------------------------------------------------------------------------------------------
//   94  */
//   95 
//   96 static uint16 runPoly(uint16 crc, uint8 val);
//   97 
//   98 #define	 ucLDR_Security_F	(*(unsigned char *)0x100)	
//   99 #define	 start_flag	(*(unsigned char *)0x101)	
//  100 #define	 ucLDR_Ret	(*(unsigned char *)0x102)
//  101 #define	 ucLDR_Message	(*(Uart_message *)0x110)
//  102 #define	 stCommand	(*(union  u_stCommand *)0x1E0)	
//  103 #define	 ucLDR_WorkRam	(*(unsigned char *)0x200)
//  104 //#define 	 dmaCh0		(*(halDMADesc_t*)0x201)
//  105 
//  106 #define LED_1 P1_3
//  107 #define LED_2 P1_4
//  108 
//  109 #define OAD_AES_VERI
//  110 
//  111 // _mode_ is one of
//  112 #define CBC         0x00
//  113 #define CFB         0x10
//  114 #define OFB         0x20
//  115 #define CTR         0x30
//  116 #define ECB         0x40
//  117 #define CBC_MAC     0x50
//  118 
//  119 #define AES_BUSY    0x08
//  120 #define ENCRYPT     0x00
//  121 #define DECRYPT     0x01
//  122 
//  123 // Macro for starting or stopping encryption or decryption
//  124 #define AES_SET_ENCR_DECR_KEY_IV(mode) \ 
//  125    do {                                \ 
//  126     ENCCS = (ENCCS & ~0x07) | mode     \ 
//  127    } while(0)
//  128 
//  129 // Where _mode_ is one of
//  130 #define AES_ENCRYPT     0x00;
//  131 #define AES_DECRYPT     0x02;
//  132 #define AES_LOAD_KEY    0x04;
//  133 #define AES_LOAD_IV     0x06;
//  134 
//  135 #define LENGTH_IV  16
//  136 #define LENGTH_KEY 16
//  137 
//  138 #define STRING_LENGTH       16
//  139 
//  140 #define VALID_INIT_SN				(978137684)
//  141 #define VALID_START_SN				(260636838)
//  142 
//  143 
//  144 // Macro for setting the mode of the AES operation
//  145 #define AES_SETMODE(mode) do { ENCCS &= ~0x70; ENCCS |= mode; } while (0)
//  146 
//  147 // Macro for starting the AES module for either encryption, decryption,
//  148 // key or initialisation vector loading.
//  149 #define AES_START()     ENCCS |= 0x01
//  150 
//  151 #define DELAY 0x0F
//  152 
//  153 typedef unsigned char       BOOL;
//  154 
//  155 // Data
//  156 typedef unsigned char       BYTE;
//  157 typedef unsigned short      WORD;
//  158 typedef unsigned long       DWORD;
//  159 
//  160 // Unsigned numbers
//  161 typedef unsigned char       UINT8;
//  162 typedef unsigned short      UINT16;
//  163 typedef unsigned long       UINT32;
//  164 
//  165 // Signed numbers
//  166 typedef signed char         INT8;
//  167 typedef signed short        INT16;
//  168 typedef signed long         INT32;
//  169 
//  170 typedef volatile unsigned char XDATA macRam_t;
//  171 #define TI_EXTADDR  PXREG( 0x780C )  /* Pointer to Start of Flash Information Page          */
//  172 
//  173 #if HAL_OAD_XNV_IS_SPI
//  174 static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len);
//  175 static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len);
//  176 static unsigned char RcvData(void);
//  177 static unsigned char Message_Rcv(void);
//  178 static void Message_Send(void);
//  179 static void SendData(char dat);
//  180 static void delay(unsigned int de);
//  181 static void MemReadRam(macRam_t * pRam, uint8 * pData, uint8 len);
//  182 static uint8 OAD_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len );
//  183 static void putsDialog(const char *str);
//  184 //static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr);
//  185 //static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key);
//  186 #ifdef OAD_AES_VERI
//  187 static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key);
//  188 static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr);
//  189 #endif
//  190 
//  191 #endif
//  192 
//  193 #if 0
//  194 const uint8 crcTest[] = {
//  195 0x02,0x1C,0x0E,0x02,0x11,0xE2,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
//  196 0xFF,0xFF,0xFF,0x02,0x12,0xA8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
//  197 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x2B,0xD2,0xFF,0xFF,
//  198 0xFF,0xFF,0xFF,0x02,0x11,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x12,0xFD,0xFF,0xFF,
//  199 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x19,0x07,0xFF,0xFF,
//  200 0xFF,0xFF,0xFF,0x02,0x11,0x22,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x19,0x16,0xFF,0xFF,
//  201 0xFF,0xFF,0xFF,0x02,0x19,0x22,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x2B,0x5B,0xFF,0xFF,
//  202 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
//  203 0xFF,0xFF,0xFF,0x02,0x11,0x70,0xFF,0xFF,0x00,0xF0,0x44,0x7B,0x0F,0xFE,0x00,0x8F,
//  204 0x01,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,
//  205 0x00,0x05,0x00,0x0A,0x00,0x14,0x00,0x28,0x00,0x4F,0x00,0x9E,0x00,0x00,0x00,0x59,
//  206 0x21,0x59,0x21,0x59,0x21,0x2D,0x20,0x27,0x20,0x59,0x21,0x67,0x2C,0x00,0x00,0x00,
//  207 0x00,0x2B,0x2D,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x0C,0x00,0x9C,0x04,0xFF,
//  208 0x01,0x64,0x00,0x02,0x02,0x02,0x07,0x1E,0x02,0x05,0x1E,0x02,0x0A,0x03,0xB8,0x0B,
//  209 0x02,0xF0,0xFF,0x02,0x01,0x17,0x00,0xFF,0x47,0x75,0x30,0x60,0x04,0x01,0xA0,0x04,
//  210 0x01,0xA0,0x04,0x01,0xA0,0x04,0x01,0x00,0x00,0x01,0x00,0x00,0x0F,0x00,0xFF,0x48
//  211 };
//  212 #endif
//  213 
//  214 #if HAL_OAD_BOOT_CODE
//  215 static void dl2rc(void);
//  216 static uint16 crcCalc(void);
//  217 static void InitUart(void);
//  218 //static void Uart_Send_String(char *Data,int len);
//  219 #endif
//  220 
//  221 #ifdef _FORMAT_PRINT_
//  222 static int Printf(const char *fmt, ...);
//  223 #endif
//  224 
//  225 /**************************************************************************************************
//  226  * @fn          main
//  227  *
//  228  * @brief       ISR for the reset vector.
//  229  *
//  230  * input parameters
//  231  *
//  232  * None.
//  233  *
//  234  * output parameters
//  235  *
//  236  * None.
//  237  *
//  238  * @return      None.
//  239  **************************************************************************************************
//  240  */
//  241  
//  242 //#pragma location="RAM_CODE_XDATA"
//  243 
//  244 //unsigned char ucLDR_Security_F;
//  245 //unsigned char start_flag;
//  246 //unsigned char ucLDR_Ret;
//  247 //Uart_message ucLDR_Message;
//  248 //unsigned char ucLDR_WorkRam;
//  249 
//  250  //char *g_decKey = "WorkForYourDream";
//  251  //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//  252 #pragma location="NEAR_CODE"
//  253 
//  254 void main(void)
//  255 {
//  256   uint16 crc[2];
//  257   uint8 veriBuf[16];
//  258   //uint8 g_extAddr[8] = {0x38,0x15,0xC6,0xFE,0xFF,0x17,0x87,0x88};
//  259  // uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;
//  260  uint16 seriAddr = HAL_OAD_CODE_START/HAL_FLASH_WORD_SIZE;
//  261   uint16 oset;
//  262   //uint8 page=HAL_OAD_CODE_START/HAL_FLASH_PAGE_SIZE;
//  263   uint8 page=HAL_OAD_RC_START/HAL_FLASH_PAGE_SIZE;
//  264   char *decKey = "WorkForYourDream";
//  265   uint32 *pVeriFlag;
//  266   //preamble_t *tstPre;
//  267   //uint8 test[12] = {0X0F,0XFE,0XAA,0XBB,0XCC,0XDD,0X00,0X03,0X00,0X03,0X00,0X03};
//  268   //uint8 page=HAL_OAD_RC_START/HAL_FLASH_PAGE_SIZE;
//  269   //uint8 buf[16];
//  270  // char *g_decKey = "WorkForYourDream";
//  271  //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//  272   //uint8 buf[8] = {0};  
//  273 
//  274   HAL_BOARD_INIT();
//  275 #if HAL_OAD_XNV_IS_SPI
//  276   //XNV_SPI_INIT(); 
//  277 #endif
//  278   /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
//  279    * descriptors in addition to just Channel 0.
//  280    */
//  281   HAL_DMA_SET_ADDR_DESC0( &dmaCh0 );
//  282   HalFlashInit();
//  283 
//  284 #if 0
//  285   HalFlashRead(HAL_OAD_CRC_ADDR / HAL_FLASH_PAGE_SIZE,
//  286                HAL_OAD_CRC_ADDR % HAL_FLASH_PAGE_SIZE,
//  287                (uint8 *)crc, sizeof(crc));
//  288 
//  289 
//  290   if (crc[0] != crc[1])
//  291   {
//  292     // If the CRC is erased or the RC code fails a sanity check, instantiate the DL code (again).
//  293     if ((crc[0] == 0) || (crc[0] != crcCalc()))
//  294     {
//  295       dl2rc();
//  296 
//  297       /* If dl2rc() fails, a flawed image is allowed to run - 
//  298        * maybe the damage is not fatal to OTA ops?
//  299        */
//  300     }
//  301     else
//  302     {
//  303       crc[1] = crc[0];
//  304       HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
//  305     }
//  306   }
//  307 #endif
//  308 
//  309   //InitUart();
//  310   //Uart_Send_String("boot",4);
//  311   
//  312   //P1DIR &=( ~0x04);
//  313   //P1DIR |= 0x08;				//P1_3
//  314   //P1DIR |= 0x08;
//  315   //P1DIR |= 0x10;
//  316   //P1DIR |= 0x18;
//  317   //P1_3 = 0;
//  318   //P1_4 = 0;
//  319   P0SEL &= ~0x30;
//  320   P0DIR &= 0xDF;
//  321   //P0DIR |= 0x11;
//  322   P0DIR |= 0x10;
//  323   P0DIR |= 0x80;
//  324   //P1DIR |= 0x82;
//  325   P0_4 = 0;
//  326   P1_7 = 1;
//  327   //P1_0 = 0;
//  328   //P1_1 = 0;//led
//  329   //P0_0 = 0;//led
//  330   //P0 &= ~0x20;
//  331   //P0DIR |= 0x10;
//  332   //P0_4 = 1;
//  333   //P1DIR |= 0x80;
//  334   //P0DIR |= 0x20;					//P05
//  335   InitUart();
//  336 #ifdef OAD_AES_VERI
//  337   AES_SETMODE(ECB);
//  338 #endif
//  339 
//  340   HAL_TURN_OFF_LED2();
//  341   HAL_TURN_OFF_LED1();
//  342   
//  343 #ifdef OAD_AES_VERI
//  344   halAesLoadKeyOrInitVector(decKey, TRUE);
//  345   
//  346   HalFlashRead(CPUID_VERI_ADDR / HAL_FLASH_PAGE_SIZE,
//  347                CPUID_VERI_ADDR % HAL_FLASH_PAGE_SIZE,
//  348                veriBuf, sizeof(veriBuf));
//  349 
//  350   halAesEncrDecr((BYTE *)veriBuf, CPUID_VERI_LEN, (BYTE *)veriBuf/*, ucLDR_Message.com_data*/, DECRYPT); 
//  351   
//  352   pVeriFlag = (uint32*)veriBuf;
//  353   if(VALID_INIT_SN==*pVeriFlag)
//  354   {
//  355   	putsDialog("Initial\r\n");
//  356 
//  357 	
//  358 	//2015/09/13 what's wrong
//  359 	//dl2rc();
//  360 	//HalFlashErase(HAL_OAD_RC_START / HAL_FLASH_PAGE_SIZE );
//  361 	//HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);		//²»ÄÜÅúÁ¿ÉÕÂ¼
//  362 	
//  363   	*pVeriFlag = VALID_START_SN;						//first start 
//  364   	MemReadRam((macRam_t *)TI_EXTADDR, (veriBuf+4), 8);
//  365 	halAesEncrDecr((BYTE *)veriBuf, CPUID_VERI_LEN, (BYTE *)veriBuf/*, ucLDR_Message.com_data*/, ENCRYPT); 
//  366 	HalFlashErase(CPUID_VERI_ADDR / HAL_FLASH_PAGE_SIZE);
//  367 	HalFlashWrite((CPUID_VERI_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)veriBuf, CPUID_VERI_LEN/4);	
//  368   }else if(VALID_START_SN==*pVeriFlag)
//  369   {
//  370   	MemReadRam((macRam_t *)TI_EXTADDR, (veriBuf+12), 8);		//read mac iD
//  371 	if(FALSE==OAD_memcmp((veriBuf+4), (veriBuf+12), 8))
//  372 	{
//  373 		putsDialog("Verified Error");
//  374 		while(1);
//  375 		//asm("LJMP 0x1000\n");
//  376 	}
//  377 	putsDialog("Start\r\n");
//  378   }else
//  379   {
//  380   	putsDialog("Verified Error");
//  381 	while(1);
//  382   }
//  383 #endif
//  384  //tstPre = (preamble_t*)test;
//  385   //SendData(tstPre->len>>24);
//  386  // SendData(tstPre->len>>16);
//  387   //SendData(tstPre->len>>8);
//  388   //SendData(tstPre->len);
//  389 
//  390   //HalFlashWrite((HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE), (uint8 *)crcTest, sizeof(crcTest)/4);
//  391   
//  392  //if(!P1_2)
//  393   if(!P0_5)
//  394   {
//  395 
//  396 	//Uart_Send_String("boot",4);
//  397 	//putsDialog("boot\r\n");
//  398         //P1DIR |= 0x18;
//  399         //P1_4 = 0;
//  400 	
//  401 	while(1)
//  402 	{
//  403 		if(Message_Rcv())
//  404 		{	
//  405 			//P1_3 = !P1_3;
//  406 			ucLDR_Security_F = 0;
//  407 			ucLDR_Ret = 0x00;
//  408 			//Uart_Send_String("rcv",3);
//  409 #if 1
//  410 			switch(ucLDR_Message.protocol_command )
//  411 			{
//  412 
//  413 				case AM1_IAP_READ_64BYTE:
//  414 #if 0
//  415 					//P1_3 = !P1_3;
//  416                                    //     P1_4 = !P1_4;
//  417 				  	for (oset = 0; oset < HAL_FLASH_PAGE_SIZE; oset += 64)
//  418 				  	{
//  419 						HalFlashRead(page,oset,ucLDR_Message.com_data,64);
//  420 						ucLDR_Message.data_length=64;
//  421 						Message_Send();		
//  422 						//Uart_Send_String(buf,4);
//  423 					
//  424 				  	}
//  425 					page++;
//  426 #endif
//  427 				break;
//  428 /*
//  429 				case BOOT_FIRMWARE_VERSION:
//  430 					ucLDR_Message.com_data[0]=1;
//  431 					ucLDR_Message.com_data[1]=0;      
//  432 					ucLDR_Message.com_data[12]=5;	//for AM1_IAP
//  433 					ucLDR_Message.data_length=20;
//  434 					Message_Send();
//  435 					break;
//  436 					
//  437 				case AM1_IAP_READ_64BYTE:
//  438 					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
//  439 					stCommand.Program_Lib.dst_adr	+= 64;
//  440 					if( stCommand.Program_Lib.dst_adr == 0x00 )
//  441 					stCommand.Program_Lib.dst_bank++;	
//  442 					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
//  443 					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
//  444 					ucLDR_Read_64Byte_Ram();
//  445 					ucLDR_Message.data_length=64;
//  446 					Message_Send();
//  447 					break;
//  448 
//  449 						
//  450 				case AM1_IAP_READ_STATUS:
//  451 					stCommand.ReadStatus_Lib.ram_adr = (unsigned char*)&ucLDR_WorkRam;
//  452 					ucLDR_Ret=0;//test
//  453 					ucLDR_ReadStatus_Ram();//test
//  454 					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
//  455 					ucLDR_Message.data_length=2;
//  456 					Message_Send();
//  457 					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
//  458 					stCommand.Program_Lib.dst_bank	= 0;	
//  459 					break;
//  460 
//  461 					  
//  462 				case AM1_IAP_SECURITYCHECK:
//  463 		 			stCommand.Security_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam;
//  464 			 		stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
//  465 					ucLDR_Ret = 0x00;
//  466 					ucLDR_SecurityCheck_Ram();
//  467 					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
//  468 					ucLDR_Message.data_length=2;		
//  469 					Message_Send();
//  470 					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
//  471 					stCommand.Program_Lib.dst_bank	= 0;	
//  472 				      break;
//  473 */
//  474 						
//  475 	//=================================================================================
//  476 				case AM1_IAP_WRITE_PAGE:	
//  477 /*
//  478 					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
//  479 					stCommand.Program_Lib.dst_adr	+= 64;
//  480 					if( stCommand.Program_Lib.dst_adr == 0x00 )
//  481 					stCommand.Program_Lib.dst_bank++;	
//  482 					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
//  483 					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
//  484 					ucLDR_Ret=0x00;//test	
//  485 					ucLDR_Program_Ram();//test
//  486 */
//  487 					halAesEncrDecr((BYTE *)ucLDR_Message.com_data, STRING_LENGTH, (BYTE *)ucLDR_Message.com_data/*, ucLDR_Message.com_data*/, DECRYPT);
//  488 					//Uart_Send_String((BYTE *)buf,16);
//  489 					if ((seriAddr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
//  490 					{
//  491 						HalFlashErase(seriAddr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
//  492 					}
//  493 					//HalFlashWrite(addr++, ucLDR_Message.com_data, 1);
//  494 					HalFlashWrite(seriAddr, ucLDR_Message.com_data, ucLDR_Message.data_length/4);
//  495 					seriAddr+=(ucLDR_Message.data_length/4);
//  496 					delay(1000);
//  497 				    //ucLDR_Read_64Byte_Ram();
//  498 					ucLDR_Message.com_data[0]=0x00;
//  499 					ucLDR_Message.data_length=2;
//  500 					Message_Send();					
//  501 					break;
//  502 
//  503 				case AM1_IAP_ERASE_DEVICE:
//  504 					ucLDR_Message.com_data[0]=0x55;
//  505 					ucLDR_Message.com_data[1]=0x00;
//  506 					ucLDR_Message.data_length=3;
//  507 					Message_Send();	
//  508 				break;
//  509 	//=================================================================================
//  510 /*
//  511 				case AM1_IAP_ERASE_DEVICE:		
//  512 					ucLDR_Security_F = 0;
//  513 					stCommand.ReadStatus_Lib.ram_adr = &ucLDR_WorkRam;
//  514 					ucLDR_Ret=0;//test
//  515 					ucLDR_ReadStatus_Ram();//test
//  516 					if( (ucLDR_Ret&0x01) == 0x01 )
//  517 						{
//  518 						ucLDR_Message.com_data[0]=0x55;// No Key	
//  519 						ucLDR_Security_F=1;
//  520 					     }
//  521 					else
//  522 						{
//  523 						ucLDR_Ret = 0x00;
//  524 			 			stCommand.Security_Lib.ram_adr	= &ucLDR_WorkRam;
//  525 			 			stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
//  526 						ucLDR_SecurityCheck_Ram();
//  527 						if( ucLDR_Ret != 0x00 )
//  528 							{
//  529 							ucLDR_Message.com_data[0]=0xEE;   //Key Verify error
//  530 			
//  531 							}
//  532 						else
//  533 							{
//  534 							 ucLDR_Message.com_data[0]=0xaa ;//Key Verify Pass
//  535 		                                 ucLDR_Security_F=1;
//  536 						       }
//  537 						}
//  538 
//  539 						 if(ucLDR_Security_F==1)
//  540 							{
//  541 								stCommand.Erase_Lib.ram_adr	= &ucLDR_WorkRam;
//  542 								ucLDR_Ret=0x00;//test
//  543 								ucLDR_Erase_Ram();//test
//  544 								ucLDR_Message.com_data[1]= ucLDR_Ret;
//  545 								#if 0
//  546 								if(ucLDR_Ret==0)
//  547 								{
//  548 								stCommand.Secter_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam[0];
//  549 								ucLDR_Ret=0x00;//test
//  550 								ucLDR_BankCheck_Ram();  //test 
//  551 								ucLDR_Message.com_data[2]=ucLDR_Ret;
//  552 								}
//  553 								#endif
//  554 							}
//  555 					delay(60000);		
//  556 					stCommand.Program_Lib.dst_adr	= (unsigned char*)(0x4000-64);	   
//  557 					stCommand.Program_Lib.dst_bank	= 0;
//  558 					Message_Send();	
//  559 					break;
//  560 */
//  561 //=================================================================================
//  562 				  default:
//  563 					//Message_Send();		
//  564 					break;
//  565 				}
//  566 #endif
//  567 		}
//  568 		//start_flag = 0;
//  569 		//InitUart();
//  570 		//Uart_Send_String("test",4);
//  571 		//P1_3 = !P1_3;
//  572 
//  573 	}
//  574   }else
//  575   {
//  576 
//  577 #if 1
//  578   	HalFlashRead(HAL_OAD_CRC_ADDR / HAL_FLASH_PAGE_SIZE,
//  579                HAL_OAD_CRC_ADDR % HAL_FLASH_PAGE_SIZE,
//  580                (uint8 *)crc, sizeof(crc));
//  581 
//  582 	if (crc[0] != crc[1])
//  583 	{
//  584 		SendData(crc[1]>>8);
//  585 		SendData(crc[1]&0xFF);
//  586 		if( crc[1]== crcCalc())
//  587 		{
//  588 			//putsDialog("CRC OK\r\n");
//  589 			dl2rc();
//  590 			//putsDialog("FW OK\r\n");
//  591 			crc[0] = crc[1];
//  592 			//HalFlashErase(HAL_OAD_RC_START / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
//  593 			//HalFlashErase(HAL_OAD_RC_START / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
//  594 			HalFlashErase(HAL_OAD_RC_START / HAL_FLASH_PAGE_SIZE );
//  595 			HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
//  596 		}else
//  597 		{
//  598 			//Add code to avoiding repeat crc process
//  599 			crc[0] = crc[1];
//  600 			HalFlashErase(HAL_OAD_RC_START / HAL_FLASH_PAGE_SIZE );
//  601 			HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
//  602 			//putsDialog("CRC error\r\n");
//  603 			//SendData(crc[0]>>8);
//  604 			//SendData(crc[0]&0xff);
//  605 			//SendData(crc[1]>>8);
//  606 			//SendData(crc[1]&0xff);
//  607 		}
//  608 	}
//  609 
//  610 	HAL_TURN_ON_LED2();
//  611 	HAL_TURN_OFF_LED1();
//  612 #if 0
//  613 	  if (crc[0] != crc[1])
//  614 	{
//  615 		// If the CRC is erased or the RC code fails a sanity check, instantiate the DL code (again).
//  616 		if ((crc[0] == 0) || (crc[0] != crcCalc()))
//  617 		{
//  618 			dl2rc();
//  619 
//  620 			/* If dl2rc() fails, a flawed image is allowed to run - 
//  621 			* maybe the damage is not fatal to OTA ops?
//  622 			*/
//  623 		}
//  624 		else
//  625 		{
//  626 			crc[1] = crc[0];
//  627 			HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
//  628 		}
//  629 	}
//  630 #endif
//  631 #endif
//  632 
//  633 	// Simulate a reset for the Application code by an absolute jump to location 0x0800.
//  634 	//asm("LJMP 0x800\n");
//  635 	//Uart_Send_String("jump",4);
//  636 	//asm("LJMP 0x2000\n");
//  637 	//putsDialog("jump");
//  638 	//asm("LJMP 0x1000\n");
//  639 	asm("LJMP 0x2000\n");
//  640 	//asm("LJMP 0x2000\n");
//  641 	//asm("LJMP 0x1000\n");
//  642 	//asm("LJMP 0x5000\n");
//  643   }
//  644   
//  645 }
//  646 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  647 static void MemReadRam(macRam_t * pRam, uint8 * pData, uint8 len)
??MemReadRam:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function ??MemReadRam
        CODE
//  648 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
        SJMP    ??MemReadRam_1
//  649   while (len)
//  650   {
//  651     len--;
??MemReadRam_2:
        DEC     R1
//  652     *pData = *pRam;
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
//  653     pRam++;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
//  654     pData++;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  655   }
??MemReadRam_1:
        MOV     A,R1
        JNZ     ??MemReadRam_2
//  656 }
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock5
//  657 
//  658 static uint8 OAD_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
//  659 {
//  660   const uint8 GENERIC *pSrc1;
//  661   const uint8 GENERIC *pSrc2;
//  662 
//  663   pSrc1 = src1;
//  664   pSrc2 = src2;
//  665 
//  666   while ( len-- )
//  667   {
//  668     if( *pSrc1++ != *pSrc2++ )
//  669       return FALSE;
//  670   }
//  671   return TRUE;
//  672 }
//  673 
//  674 static void InitUart(void)
//  675 {
//  676     //CLKCONCMD &= ~0x40; // ÉèÖÃÏµÍ³Ê±ÖÓÔ´Îª 32MHZ¾§Õñ
//  677     //while(CLKCONSTA & 0x40);                     // µÈ´ý¾§ÕñÎÈ¶¨ 
//  678     //CLKCONCMD &= ~0x47;                          // ÉèÖÃÏµÍ³Ö÷Ê±ÖÓÆµÂÊÎª 32MHZ
//  679 
//  680     PERCFG &= ~0x01;        //Î»ÖÃ1 P0¿Ú 
//  681     P0SEL |= 0x0c;        //P0_2,P0_3,P0_4,P0_5ÓÃ×÷´®¿Ú,µÚ¶þ¹¦ÄÜ 
//  682     //P0DIR |= 0x04;
//  683    // P0DIR &= ~0x08;
//  684     //P0DIR |= 0x08;
//  685     //P2DIR &= ~0XC0;      //P0 ÓÅÏÈ×÷ÎªUART0 £¬ÓÅÏÈ¼¶
//  686     //PERCFG &= ~(BV(0)); //Ñ¡ÔñP0¶Ë¿Úuart
//  687     //P0SEL |=BV(5)|BV(4)|BV(3)|BV(2);
//  688     //P2DIR &=~(BV(7)|BV(6));
//  689 
//  690     U0CSR |= 0x80;       //UART ·½Ê½ 
//  691     U0GCR = 11;         //U0GCRÓëU0BAUDÅäºÏ     
//  692     U0BAUD = 216;       // ²¨ÌØÂÊÉèÎª115200 
//  693     UTX0IF = 0;          //UART0 TX ÖÐ¶Ï±êÖ¾³õÊ¼ÖÃÎ»1  £¨ÊÕ·¢Ê±ºò£©
//  694     U0CSR |= 0X40;       //ÔÊÐí½ÓÊÕ 
//  695    // IEN0 |= 0x84;        // ¿ª×ÜÖÐ¶Ï£¬½ÓÊÕÖÐ¶Ï    
//  696 
//  697    URX0IF = 0;
//  698 
//  699   // P1_3 = !P1_3;
//  700 }
//  701 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  702 static void SendData(char dat)
??SendData:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function ??SendData
        CODE
//  703 {
        ; Saved register size: 0
        ; Auto size: 0
//  704 	U0DBUF = dat;
        MOV     0xc1,R1
//  705 	while(!UTX0IF);
??SendData_1:
        MOV     C,0xe8.1
        JNC     ??SendData_1
//  706 	UTX0IF = 0; 	
        CLR     0xe8.1
//  707 }
        RET
        CFI EndBlock cfiBlock6
        REQUIRE U0DBUF
        REQUIRE _A_IRCON2
//  708 
//  709 #if 1

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  710 static void putsDialog(const char *str)
??putsDialog:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function ??putsDialog
        CODE
//  711 {
        FUNCALL ??putsDialog, ??SendData
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
        MOV     DPL,R2
        MOV     DPH,R3
        SJMP    ??putsDialog_1
//  712 	 //UartDecode(str);
//  713 	 while(*str != '\0')
//  714 	{
//  715         	SendData(*str++);
??putsDialog_2:
        ; Setup parameters for call to function SendData
        LCALL   ??SendData
        INC     DPTR
//  716     }
??putsDialog_1:
        MOVX    A,@DPTR
        MOV     R1,A
        JNZ     ??putsDialog_2
        CFI EndBlock cfiBlock7
//  717 }
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-4
        CFI DPL0 Frame(CFA_SP, 3)
        CFI DPH0 Frame(CFA_SP, 4)
        POP     DPH
        CFI CFA_SP SP+-3
        CFI DPH0 SameValue
        POP     DPL
        CFI CFA_SP SP+-2
        CFI DPL0 SameValue
        RET
        CFI EndBlock cfiBlock8
//  718 #endif
//  719 
//  720 #ifdef _FORMAT_PRINT_
//  721 
//  722 
//  723 static char *_itoa(long n, int base)
//  724  {
//  725   	char *p;
//  726  	int minus;
//  727  	static char buf[16];
//  728 
//  729 //	puts_("enter _itoa\n");
//  730 //	put_hex(n);
//  731 
//  732  	p = &buf[16];
//  733  	*--p =  0;
//  734  	if (n < 0) 
//  735 	{
//  736   		minus = 1;
//  737   		n = -n;
//  738  	}
//  739  	else
//  740   		minus = 0;
//  741 
//  742 
//  743  	if (n == 0)
//  744 	{
//  745   		*--p = '0';
//  746 	}
//  747  	else
//  748   		while (n > 0) 
//  749 		{  
//  750 	//		puts_("_itoa ");
//  751    			*--p = "0123456789abcdef"[n % base];
//  752 	//		putchar(*p);
//  753    			n /= base;
//  754   		}
//  755 
//  756  	if (minus)
//  757   		*--p = '-';
//  758 
//  759  	return p;
//  760 }
//  761 /*
//  762 int printfDig( long n, int base )
//  763 {
//  764 	return Tprintf( _itoa( n, base ) );
//  765 	put_byte(0x0D);
//  766     put_byte(0x0A);	
//  767 }
//  768 */
//  769 static int Printf(const char *fmt, ...)
//  770 {
//  771 	//int i;
//  772 	const char *s;
//  773  	int d;
//  774 	char buf[16];
//  775 	char *p = buf;
//  776 //	char buf[16];
//  777 //	char *p = buf;
//  778  	va_list ap;
//  779 
//  780     va_start(ap, fmt);
//  781 	//i = 16;
//  782 
//  783     while (*fmt) 
//  784 	{
//  785         if (*fmt != '%') 
//  786 		{
//  787             SendData(*fmt++);
//  788             continue;
//  789         }
//  790 		
//  791 		switch(*++fmt)
//  792 		{
//  793             case 's':
//  794                 s = va_arg(ap, const char *);
//  795                 for ( ; *s; s++) 
//  796 				{
//  797                     SendData(*s);
//  798                 }
//  799                 break;
//  800             case 'd':			
//  801                 d = va_arg(ap, int);
//  802 				//d>>=8;
//  803                 p = _itoa(d, 10);
//  804                 for (s = p; *s; s++) 
//  805 				{
//  806                     SendData(*s);
//  807                 }
//  808 
//  809 				break;
//  810 
//  811             case 'x':
//  812 			case 'X':
//  813                 d = va_arg(ap, int);
//  814                 p = _itoa(d, 16);
//  815                 for (s = p; *s; s++) 
//  816 				{
//  817                     SendData(*s);
//  818                 }
//  819                 break;
//  820              //Add other specifiers here...              
//  821             default:  
//  822                 putsDialog(fmt);
//  823                 break;
//  824         } 
//  825         fmt++;
//  826     }
//  827     va_end(ap);
//  828 
//  829     return 1;   /* Dummy return value */
//  830 } 
//  831 #endif
//  832 
//  833 static void delay(unsigned int de)
//  834 {
//  835 	//while(de--);
//  836 	 uint16 i,j;
//  837 	 for(i=de;i>0;i--)
//  838 	   for(j=587;j>0;j--);
//  839 }
//  840 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  841 static unsigned char RcvData(void)
??RcvData:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function ??RcvData
        CODE
//  842 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
//  843 	unsigned char count1=0;
        MOV     R1,#0x0
//  844 	unsigned char count2=0;
        MOV     R0,#0x0
//  845 
//  846 	while( !URX0IF )
??RcvData_1:
        MOV     C,0x88.3
        JC      ??RcvData_2
//  847 	{
//  848 		count1++;
        INC     R1
//  849 		if(count1==252)
        MOV     A,#-0x4
        XRL     A,R1
        JNZ     ??RcvData_3
//  850 		{
//  851 		count1=0;
        MOV     R1,#0x0
//  852 		count2++;
        INC     R0
//  853 		}
//  854 		if((count2==252)&&(start_flag==1))
??RcvData_3:
        MOV     A,#-0x4
        XRL     A,R0
        JNZ     ??RcvData_1
        MOV     DPTR,#0x101
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??RcvData_1
//  855 		{
//  856 			start_flag=0;
        CLR     A
        MOVX    @DPTR,A
//  857 			
//  858 			return 0;
        MOV     R1,A
        SJMP    ??RcvData_4
//  859 		}
//  860 	}
//  861 	URX0IF = 0;
??RcvData_2:
        CLR     0x88.3
//  862 	return U0DBUF;
        MOV     R1,0xc1
??RcvData_4:
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock9
        REQUIRE _A_TCON
        REQUIRE U0DBUF
//  863 }
//  864 
//  865 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  866 static unsigned char Message_Rcv(void)
??Message_Rcv:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function ??Message_Rcv
        CODE
//  867 {
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  868 	unsigned char	ucdata;
//  869 	unsigned char 	rcvdat;
//  870 	unsigned char	uci;
//  871 	start_flag=0;
        MOV     DPTR,#0x101
        CLR     A
        MOVX    @DPTR,A
//  872 
//  873 	//P1_3 = !P1_3;
//  874 	
//  875      ucdata=RcvData();
//  876 	if(ucdata!=0x7E)
        ; Setup parameters for call to function RcvData
        LCALL   ??RcvData
        MOV     A,R1
        XRL     A,#0x7e
        JZ      ??Message_Rcv_1
//  877 	   return 0;
??Message_Rcv_2:
        MOV     R1,#0x0
        SJMP    ??Message_Rcv_3
//  878 	start_flag=1;
??Message_Rcv_1:
        MOV     A,#0x1
        MOVX    @DPTR,A
//  879 	ucdata=RcvData();
        ; Setup parameters for call to function RcvData
        LCALL   ??RcvData
        MOV     A,R1
//  880 	ucLDR_Message.com_number=  ucdata;
        MOV     DPTR,#0x110
        MOVX    @DPTR,A
//  881 	ucLDR_Message.msg_cks=ucdata;
        MOV     DPTR,#0x164
        LCALL   ??Subroutine13_0
//  882 	
//  883       ucdata=RcvData();
//  884 	if(start_flag==0)
??CrossCallReturnLabel_18:
        JZ      ??Message_Rcv_2
//  885 		return 0;
//  886 	ucLDR_Message.protocol_command=  ucdata;
        MOV     A,R0
        MOV     DPTR,#0x111
        LCALL   ?Subroutine3
//  887 	ucLDR_Message.msg_cks+=ucdata;	
//  888 	
//  889 	ucdata=RcvData();
//  890 	if(start_flag==0)
??CrossCallReturnLabel_16:
        JZ      ??Message_Rcv_2
//  891 		 return 0;
//  892 	ucLDR_Message.no_used=  ucdata;
        MOV     A,R0
        MOV     DPTR,#0x112
        LCALL   ?Subroutine3
//  893 	ucLDR_Message.msg_cks+=ucdata;	
//  894 	
//  895 	ucdata=RcvData();
//  896 	if(start_flag==0)
??CrossCallReturnLabel_17:
        JZ      ??Message_Rcv_2
//  897 		 return 0;
//  898 	ucLDR_Message.data_length=  ucdata;
        MOV     A,R0
        MOV     DPTR,#0x113
        LCALL   ?Subroutine10
//  899 	ucLDR_Message.msg_cks+=ucdata;
??CrossCallReturnLabel_11:
        MOVX    @DPTR,A
//  900 	
//  901 	for( uci=0 ; uci<ucLDR_Message.data_length ; uci++ )
        MOV     R6,#0x0
        SJMP    ??Message_Rcv_4
//  902 	{
//  903 		ucdata = RcvData();
??Message_Rcv_5:
        ; Setup parameters for call to function RcvData
        LCALL   ?Subroutine7
//  904 		if(start_flag==0)
??CrossCallReturnLabel_7:
        JZ      ??Message_Rcv_2
//  905 			 return 0;
//  906 		ucLDR_Message.com_data[uci] = ucdata;
        MOV     ?V0 + 0,R6
        MOV     A,#0x14
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,#0x1
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,R0
        LCALL   ?Subroutine10
//  907 		ucLDR_Message.msg_cks+=ucdata;
//  908 	}
??CrossCallReturnLabel_12:
        MOVX    @DPTR,A
        INC     R6
??Message_Rcv_4:
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        JC      ??Message_Rcv_5
//  909 	ucdata = RcvData();
        ; Setup parameters for call to function RcvData
        LCALL   ?Subroutine7
//  910 	rcvdat = ucLDR_Message.msg_cks;
//  911 	if(start_flag==0)
??CrossCallReturnLabel_8:
        JZ      ??Message_Rcv_2
//  912 		 return 0;
//  913 	//if(ucLDR_Message.msg_cks==ucdata)
//  914 	if(rcvdat==ucdata)
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??Message_Rcv_2
//  915       return 1;
        MOV     R1,#0x1
??Message_Rcv_3:
        LJMP    ?Subroutine0
        CFI EndBlock cfiBlock10
//  916 	else
//  917 	return 0;	
//  918 
//  919 }

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine7:
        CFI Block cfiCond11 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_7
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond12 Using cfiCommon0
        CFI (cfiCond12) NoFunction
        CFI (cfiCond12) Conditional ??CrossCallReturnLabel_8
        CFI (cfiCond12) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond12) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond12) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond12) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond12) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond12) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond12) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond12) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond12) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond12) CFA_SP SP+0
        CFI (cfiCond12) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker13 Using cfiCommon1
        CFI (cfiPicker13) NoFunction
        CFI (cfiPicker13) Picker
        LCALL   ?Subroutine11
??CrossCallReturnLabel_19:
        RET
        CFI EndBlock cfiCond11
        CFI EndBlock cfiCond12
        CFI EndBlock cfiPicker13

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond14 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_16
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond15 Using cfiCommon0
        CFI (cfiCond15) NoFunction
        CFI (cfiCond15) Conditional ??CrossCallReturnLabel_17
        CFI (cfiCond15) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond15) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond15) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond15) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond15) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond15) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond15) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond15) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond15) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond15) CFA_SP SP+0
        CFI (cfiCond15) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker16 Using cfiCommon1
        CFI (cfiPicker16) NoFunction
        CFI (cfiPicker16) Picker
        LCALL   ?Subroutine10
        CFI EndBlock cfiCond14
        CFI EndBlock cfiCond15
        CFI EndBlock cfiPicker16
??CrossCallReturnLabel_13:
        REQUIRE ??Subroutine13_0
        ; // Fall through to label ??Subroutine13_0

        RSEG NEAR_CODE:CODE:NOROOT(0)
??Subroutine13_0:
        CFI Block cfiCond17 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_18
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond18 Using cfiCommon0
        CFI (cfiCond18) NoFunction
        CFI (cfiCond18) Conditional ??CrossCallReturnLabel_16
        CFI (cfiCond18) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond18) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond18) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond18) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond18) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond18) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond18) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond18) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond18) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond18) CFA_SP SP+0
        CFI (cfiCond18) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond19 Using cfiCommon0
        CFI (cfiCond19) NoFunction
        CFI (cfiCond19) Conditional ??CrossCallReturnLabel_17
        CFI (cfiCond19) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond19) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond19) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond19) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond19) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond19) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond19) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond19) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond19) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond19) CFA_SP SP+0
        CFI (cfiCond19) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker20 Using cfiCommon1
        CFI (cfiPicker20) NoFunction
        CFI (cfiPicker20) Picker
        MOVX    @DPTR,A
        ; Setup parameters for call to function RcvData
        ; Setup parameters for call to function RcvData
        ; Setup parameters for call to function RcvData
        LCALL   ?Subroutine11
??CrossCallReturnLabel_20:
        RET
        CFI EndBlock cfiCond17
        CFI EndBlock cfiCond18
        CFI EndBlock cfiCond19
        CFI EndBlock cfiPicker20

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine11:
        CFI Block cfiCond21 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_19, ??CrossCallReturnLabel_7
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond22 Using cfiCommon0
        CFI (cfiCond22) NoFunction
        CFI (cfiCond22) Conditional ??CrossCallReturnLabel_19, ??CrossCallReturnLabel_8
        CFI (cfiCond22) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond22) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond22) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond22) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond22) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond22) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond22) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond22) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond22) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond22) CFA_SP SP+0
        CFI (cfiCond22) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond23 Using cfiCommon0
        CFI (cfiCond23) NoFunction
        CFI (cfiCond23) Conditional ??CrossCallReturnLabel_20, ??CrossCallReturnLabel_16
        CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond23) CFA_SP SP+0
        CFI (cfiCond23) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond24 Using cfiCommon0
        CFI (cfiCond24) NoFunction
        CFI (cfiCond24) Conditional ??CrossCallReturnLabel_20, ??CrossCallReturnLabel_17
        CFI (cfiCond24) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond24) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond24) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond24) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond24) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond24) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond24) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond24) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond24) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond24) CFA_SP SP+0
        CFI (cfiCond24) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond25 Using cfiCommon0
        CFI (cfiCond25) NoFunction
        CFI (cfiCond25) Conditional ??CrossCallReturnLabel_20, ??CrossCallReturnLabel_18
        CFI (cfiCond25) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond25) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond25) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond25) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond25) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond25) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond25) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond25) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond25) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond25) CFA_SP SP+0
        CFI (cfiCond25) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker26 Using cfiCommon1
        CFI (cfiPicker26) NoFunction
        CFI (cfiPicker26) Picker
        LCALL   ??RcvData
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#0x101
        MOVX    A,@DPTR
        RET
        CFI EndBlock cfiCond21
        CFI EndBlock cfiCond22
        CFI EndBlock cfiCond23
        CFI EndBlock cfiCond24
        CFI EndBlock cfiCond25
        CFI EndBlock cfiPicker26

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine10:
        CFI Block cfiCond27 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_11
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond28 Using cfiCommon0
        CFI (cfiCond28) NoFunction
        CFI (cfiCond28) Conditional ??CrossCallReturnLabel_12
        CFI (cfiCond28) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond28) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond28) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond28) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond28) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond28) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond28) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond28) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond28) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond28) CFA_SP SP+0
        CFI (cfiCond28) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond29 Using cfiCommon0
        CFI (cfiCond29) NoFunction
        CFI (cfiCond29) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_16
        CFI (cfiCond29) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond29) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond29) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond29) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond29) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond29) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond29) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond29) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond29) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond29) CFA_SP SP+0
        CFI (cfiCond29) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond30 Using cfiCommon0
        CFI (cfiCond30) NoFunction
        CFI (cfiCond30) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_17
        CFI (cfiCond30) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond30) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond30) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond30) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond30) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond30) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond30) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond30) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond30) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond30) CFA_SP SP+0
        CFI (cfiCond30) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker31 Using cfiCommon1
        CFI (cfiPicker31) NoFunction
        CFI (cfiPicker31) Picker
        MOVX    @DPTR,A
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        ADD     A,R0
        RET
        CFI EndBlock cfiCond27
        CFI EndBlock cfiCond28
        CFI EndBlock cfiCond29
        CFI EndBlock cfiCond30
        CFI EndBlock cfiPicker31
//  920 
//  921 
//  922 /*********************************************************************
//  923  * @fn      dl2rc
//  924  *
//  925  * @brief   Copy the DL image to the RC image location.
//  926  *
//  927  *  NOTE:   Assumes that DL image ends on a flash word boundary.
//  928  *
//  929  * @param   None.
//  930  *
//  931  * @return  None.
//  932  *********************************************************************/
//  933 #if 1

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  934 static void Message_Send(void)
??Message_Send:
        CFI Block cfiBlock32 Using cfiCommon0
        CFI Function ??Message_Send
        CODE
//  935 {
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  936 	unsigned char  uci;
//  937 	
//  938 	SendData(0x7E);
        ; Setup parameters for call to function SendData
        MOV     R1,#0x7e
        LCALL   ??SendData
//  939     
//  940 	ucLDR_Message.msg_cks =ucLDR_Message.com_number;
        MOV     DPTR,#0x110
        MOVX    A,@DPTR
        MOV     DPTR,#0x164
        MOVX    @DPTR,A
//  941     SendData(ucLDR_Message.com_number);
        ; Setup parameters for call to function SendData
        MOV     R1,A
        LCALL   ??SendData
//  942     
//  943     ucLDR_Message.msg_cks+=ucLDR_Message.protocol_command;
        MOV     DPTR,#0x111
        LCALL   ?Subroutine12
//  944 	SendData(ucLDR_Message.protocol_command);  
??CrossCallReturnLabel_14:
        ; Setup parameters for call to function SendData
        MOV     DPTR,#0x111
        LCALL   ?Subroutine4
//  945 	
//  946     ucLDR_Message.msg_cks+=ucLDR_Message.no_used;
//  947 	SendData(ucLDR_Message.no_used); 	
??CrossCallReturnLabel_0:
        ; Setup parameters for call to function SendData
        MOV     DPTR,#0x112
        LCALL   ?Subroutine4
//  948 		
//  949     ucLDR_Message.msg_cks+=ucLDR_Message.data_length;
//  950 	SendData(ucLDR_Message.data_length); 
??CrossCallReturnLabel_1:
        ; Setup parameters for call to function SendData
        MOV     DPTR,#0x113
        LCALL   ?Subroutine5
//  951 		
//  952 
//  953     for(uci =0;uci<ucLDR_Message.data_length;uci++)
??CrossCallReturnLabel_2:
        MOV     R6,#0x0
        SJMP    ??Message_Send_1
//  954     {
//  955        ucLDR_Message.msg_cks+=ucLDR_Message.com_data[uci];  
??Message_Send_2:
        MOV     ?V0 + 0,R6
        MOV     A,#0x14
        ADD     A,?V0 + 0
        MOV     R0,A
        MOV     A,#0x1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        ADD     A,R2
        MOVX    @DPTR,A
//  956        SendData(ucLDR_Message.com_data[uci]); 	
        ; Setup parameters for call to function SendData
        MOV     DPL,R0
        MOV     DPH,R1
        LCALL   ?Subroutine5
//  957 	 }
??CrossCallReturnLabel_3:
        INC     R6
??Message_Send_1:
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        JC      ??Message_Send_2
//  958      ucLDR_Message.msg_cks+=0;
        MOV     DPTR,#0x164
        LCALL   ?Subroutine5
//  959 	 SendData(ucLDR_Message.msg_cks); 		
//  960 }
??CrossCallReturnLabel_4:
        LJMP    ?Subroutine0
        CFI EndBlock cfiBlock32

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond33 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond34 Using cfiCommon0
        CFI (cfiCond34) NoFunction
        CFI (cfiCond34) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond34) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond34) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond34) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond34) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond34) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond34) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond34) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond34) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond34) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond34) CFA_SP SP+0
        CFI (cfiCond34) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond35 Using cfiCommon0
        CFI (cfiCond35) NoFunction
        CFI (cfiCond35) Conditional ??CrossCallReturnLabel_4
        CFI (cfiCond35) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond35) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond35) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond35) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond35) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond35) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond35) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond35) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond35) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond35) CFA_SP SP+0
        CFI (cfiCond35) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker36 Using cfiCommon1
        CFI (cfiPicker36) NoFunction
        CFI (cfiPicker36) Picker
        MOVX    A,@DPTR
        ; Setup parameters for call to function SendData
        MOV     R1,A
        LCALL   ??SendData
        RET
        CFI EndBlock cfiCond33
        CFI EndBlock cfiCond34
        CFI EndBlock cfiCond35
        CFI EndBlock cfiPicker36

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond37 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond38 Using cfiCommon0
        CFI (cfiCond38) NoFunction
        CFI (cfiCond38) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond38) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond38) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond38) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond38) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond38) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond38) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond38) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond38) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond38) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond38) CFA_SP SP+0
        CFI (cfiCond38) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker39 Using cfiCommon1
        CFI (cfiPicker39) NoFunction
        CFI (cfiPicker39) Picker
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??SendData
        INC     DPTR
        LCALL   ?Subroutine12
??CrossCallReturnLabel_15:
        RET
        CFI EndBlock cfiCond37
        CFI EndBlock cfiCond38
        CFI EndBlock cfiPicker39

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine12:
        CFI Block cfiCond40 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_14
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond41 Using cfiCommon0
        CFI (cfiCond41) NoFunction
        CFI (cfiCond41) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_0
        CFI (cfiCond41) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond41) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond41) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond41) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond41) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond41) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond41) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond41) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond41) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond41) CFA_SP SP+0
        CFI (cfiCond41) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond42 Using cfiCommon0
        CFI (cfiCond42) NoFunction
        CFI (cfiCond42) Conditional ??CrossCallReturnLabel_15, ??CrossCallReturnLabel_1
        CFI (cfiCond42) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond42) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond42) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond42) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond42) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond42) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond42) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond42) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond42) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond42) CFA_SP SP+0
        CFI (cfiCond42) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker43 Using cfiCommon1
        CFI (cfiPicker43) NoFunction
        CFI (cfiPicker43) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
        RET
        CFI EndBlock cfiCond40
        CFI EndBlock cfiCond41
        CFI EndBlock cfiCond42
        CFI EndBlock cfiPicker43
//  961 
//  962 #endif
//  963 
//  964 #ifdef OAD_AES_VERI
//  965 static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key)
//  966 {
//  967    UINT8 i;
//  968 
//  969    // Checking whether to load a key or an initialisation vector.
//  970    if(key){
//  971       AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_KEY);
//  972    }
//  973    else {
//  974       AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_IV);
//  975    }
//  976    // Starting loading of key or vector.
//  977    AES_START();
//  978 
//  979    // loading the data (key or vector)
//  980    for(i = 0; i < 16; i++){
//  981       ENCDI = pData[i];
//  982    }
//  983 }
//  984 
//  985 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  986 static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr)
??halAesEncrDecr:
        CFI Block cfiBlock44 Using cfiCommon0
        CFI Function ??halAesEncrDecr
        CODE
//  987 {
        MOV     A,#-0x11
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 17)
        ; Saved register size: 17
        ; Auto size: 0
        MOV     ?V0 + 6,R1
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
//  988    UINT16  i;
//  989    UINT8   j, k;
//  990    BYTE    mode;
//  991    UINT16  nbrOfBlocks;
//  992    UINT16  convertedBlock;
//  993    UINT8   delay;
//  994 
//  995    nbrOfBlocks = length / 16;
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
        MOV     A,#0x4
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
//  996    mode = 0;
//  997 
//  998    if( (length % 16) != 0){
        MOV     A,R4
        ANL     A,#0xf
        JZ      ??halAesEncrDecr_1
//  999       // length not multiplum of 16, convert one block extra with zeropadding
// 1000       nbrOfBlocks++;
        MOV     A,?V0 + 2
        ADD     A,#0x1
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1001    }
// 1002 
// 1003    // Loading the IV.
// 1004    //halAesLoadKeyOrInitVector(pInitVector, FALSE);
// 1005 
// 1006    // Starting either encryption or decryption
// 1007    if(decr){
??halAesEncrDecr_1:
        MOV     A,?V0 + 6
        JZ      ??halAesEncrDecr_2
// 1008       AES_SET_ENCR_DECR_KEY_IV(AES_DECRYPT);
        MOV     A,0xb3
        ANL     A,#0xf8
        ORL     A,#0x2
        MOV     0xb3,A
        SJMP    ??halAesEncrDecr_3
// 1009    } else {
// 1010       AES_SET_ENCR_DECR_KEY_IV(AES_ENCRYPT);
??halAesEncrDecr_2:
        ANL     0xb3,#0xf8
// 1011    }
// 1012 
// 1013    // Getting the operation mode.
// 1014    mode = ENCCS & 0x70;
??halAesEncrDecr_3:
        MOV     A,0xb3
        ANL     A,#0x70
        MOV     ?V0 + 7,A
// 1015 
// 1016    for(convertedBlock = 0; convertedBlock < nbrOfBlocks; convertedBlock++){
        MOV     ?V0 + 0,#0x0
        MOV     ?V0 + 1,#0x0
        SJMP    ??halAesEncrDecr_4
// 1017       // Starting the conversion.
// 1018       AES_START();
// 1019 
// 1020       i = convertedBlock * 16;
// 1021       // Counter, Output Feedback and Cipher Feedback operates on 4 bytes and not 16 bytes.
// 1022       if((mode == CFB) || (mode == OFB) || (mode == CTR))
// 1023 	 {
// 1024 /*
// 1025          for(j = 0; j < 4; j++){
// 1026             // Writing the input data
// 1027             // Zeropadding the remainder of the block
// 1028             for(k = 0; k < 4; k++){
// 1029                ENCDI = ((i + 4*j + k < length) ? pDataIn[i + 4*j + k] : 0x00 );
// 1030             }
// 1031             // wait for data ready
// 1032             delay = DELAY;
// 1033             while(delay--);
// 1034             // Read out data for every 4th byte
// 1035             for(k = 0; k < 4; k++){
// 1036                pDataOut[i + 4*j + k] = ENCDO;
// 1037             }
// 1038          }
// 1039 */
// 1040       }
// 1041       else if(mode == CBC_MAC){/*
// 1042          // Writing the input data
// 1043          // Zeropadding the remainder of the block
// 1044          for(j = 0; j < 16; j++){
// 1045             ENCDI = ((i + j < length) ? pDataIn[i + j] : 0x00 );
// 1046          }
// 1047          // The last block of the CBC-MAC is computed by using CBC mode.
// 1048          if(convertedBlock == nbrOfBlocks - 2){
// 1049             AES_SETMODE(CBC);
// 1050             delay = DELAY;
// 1051             while(delay--);
// 1052          }
// 1053          // The CBC-MAC does not produce an output on the n-1 first blocks
// 1054          // only the last block is read out
// 1055          else if(convertedBlock == nbrOfBlocks - 1){
// 1056             // wait for data ready
// 1057             delay = DELAY;
// 1058             while(delay--);
// 1059             for(j = 0; j < 16; j++){
// 1060                pDataOut[j] = ENCDO;
// 1061             }
// 1062          }*/
// 1063       }
// 1064       else{
// 1065          // Writing the input data
// 1066          // Zeropadding the remainder of the block
// 1067          for(j = 0; j < 16; j++){
// 1068             ENCDI = ((i+j < length) ? pDataIn[i+j] : 0x00 );
??halAesEncrDecr_5:
        CLR     A
??halAesEncrDecr_6:
        MOV     0xb1,A
        INC     ?V0 + 9
        MOV     A,?V0 + 9
        CLR     C
        SUBB    A,#0x10
        JC      ??halAesEncrDecr_7
// 1069          }
// 1070          // wait for data ready
// 1071          delay = DELAY;
        MOV     ?V0 + 4,#0xf
// 1072          while(delay--);
??halAesEncrDecr_8:
        MOV     ?V0 + 8,?V0 + 4
        MOV     A,#-0x1
        ADD     A,?V0 + 8
        MOV     ?V0 + 4,A
        INC     A
        JNZ     ??halAesEncrDecr_8
// 1073          // Read out data
// 1074          for(j = 0; j < 16; j++){
        MOV     ?V0 + 9,#0x0
// 1075             pDataOut[i+j] = ENCDO;
??halAesEncrDecr_9:
        MOV     A,0xb2
        PUSH    A
        CFI CFA_SP SP+-1
        LCALL   ?Subroutine8
// 1076          }
??CrossCallReturnLabel_9:
        MOV     A,R6
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,?V0 + 5
        MOV     DPH,A
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
        INC     ?V0 + 9
        MOV     A,?V0 + 9
        CLR     C
        SUBB    A,#0x10
        JC      ??halAesEncrDecr_9
??halAesEncrDecr_10:
        MOV     A,?V0 + 0
        ADD     A,#0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
??halAesEncrDecr_4:
        CLR     C
        MOV     A,?V0 + 0
        SUBB    A,?V0 + 2
        MOV     A,?V0 + 1
        SUBB    A,?V0 + 3
        JNC     ??halAesEncrDecr_11
        ORL     0xb3,#0x1
        MOV     ?V0 + 4,?V0 + 0
        MOV     ?V0 + 5,?V0 + 1
        MOV     A,#0x4
        MOV     R0,#?V0 + 4
        LCALL   ?S_SHL
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
        MOV     A,#0x10
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     A,#0x20
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     A,#0x30
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     A,#0x50
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     ?V0 + 9,#0x0
??halAesEncrDecr_7:
        LCALL   ?Subroutine8
// 1077       }
// 1078    }
??CrossCallReturnLabel_10:
        CLR     C
        MOV     A,?V0 + 4
        SUBB    A,R4
        MOV     A,?V0 + 5
        SUBB    A,R5
        JC      $+5
        LJMP    ??halAesEncrDecr_5
        MOV     A,R2
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,?V0 + 5
        MOV     DPH,A
        MOVX    A,@DPTR
        LJMP    ??halAesEncrDecr_6
// 1079 }
??halAesEncrDecr_11:
        MOV     R7,#0xa
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock44
        REQUIRE ENCCS
        REQUIRE ENCDI
        REQUIRE ENCDO

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine8:
        CFI Block cfiCond45 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_9
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+-1
        CFI CFA_XSP16 add(XSP16, 17)
        CFI Block cfiCond46 Using cfiCommon0
        CFI (cfiCond46) NoFunction
        CFI (cfiCond46) Conditional ??CrossCallReturnLabel_10
        CFI (cfiCond46) R6 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI (cfiCond46) VB load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond46) V0 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond46) V1 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond46) V2 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond46) V3 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond46) V4 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond46) V5 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond46) V6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond46) V7 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond46) V8 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond46) V9 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond46) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond46) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond46) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond46) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond46) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond46) CFA_SP SP+0
        CFI (cfiCond46) CFA_XSP16 add(XSP16, 17)
        CFI Block cfiPicker47 Using cfiCommon1
        CFI (cfiPicker47) NoFunction
        CFI (cfiPicker47) Picker
        MOV     ?V0 + 4,?V0 + 9
        MOV     A,R0
        ADD     A,?V0 + 4
        MOV     ?V0 + 4,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
        RET
        CFI EndBlock cfiCond45
        CFI EndBlock cfiCond46
        CFI EndBlock cfiPicker47
// 1080 
// 1081 
// 1082 
// 1083 
// 1084 #endif
// 1085 
// 1086  #ifdef _USER_OAD_FLASH_WRITE_

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1087 static void dl2rc(void)
??dl2rc:
        CFI Block cfiBlock48 Using cfiCommon0
        CFI Function ??dl2rc
        CODE
// 1088 {
        FUNCALL ??dl2rc, HalOADRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 35, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 35, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??dl2rc, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 33, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 33, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??dl2rc, HalOADRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 35, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 35, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??dl2rc, HalFlashErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 31, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 31, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 15)
        ; Saved register size: 15
        ; Auto size: 16
        MOV     A,#-0x10
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 31)
// 1089   preamble_t preamble;
// 1090   uint32 oset;
// 1091   //uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;				//0x0800/4		user code start address
// 1092   uint16 addr = HAL_OAD_CODE_START / HAL_FLASH_WORD_SIZE;
        MOV     R6,#0x0
        MOV     R7,#0x8
// 1093   uint8 buf[4];
// 1094 
// 1095   HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
        ; Setup parameters for call to function HalOADRead
        MOV     ?V0 + 0,#0xc
        MOV     ?V0 + 1,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 33)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 35)
        MOV     R1,#0x1
        MOV     DPTR,#__Constant_8c
        LCALL   ?XLOAD_R2345
        LCALL   ??Subroutine14_0
??CrossCallReturnLabel_23:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 31)
// 1096   //putsDialog("total len %x\r\n",preamble.len);
// 1097   //SendData(preamble.len>>24);
// 1098   //SendData((preamble.len>>16)&0xff);
// 1099   //SendData((preamble.len>>8)&0xff);
// 1100   //SendData(preamble.len&0xff);
// 1101   //preamble.len = 65536;
// 1102 
// 1103   for (oset = 0; oset < preamble.len; oset += HAL_FLASH_WORD_SIZE)
        MOV     DPTR,#__Constant_0
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        SJMP    ??dl2rc_1
// 1104   {
// 1105     HalOADRead(oset, buf, HAL_FLASH_WORD_SIZE, HAL_OAD_DL);
// 1106     if ((addr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
// 1107     {
// 1108       HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
// 1109       HAL_TOGGLE_LED1();
??dl2rc_2:
        SETB    0x90.1
// 1110     }
// 1111     HalFlashWrite(addr++, buf, 1);
??dl2rc_3:
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 33)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 31)
        MOV     A,R6
        ADD     A,#0x1
        INC     R6
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
        MOV     DPTR,#__Constant_4
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_X
??dl2rc_1:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?UL_GE_X
        JC      ??dl2rc_4
        ; Setup parameters for call to function HalOADRead
        MOV     ?V0 + 0,#0x4
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 33)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 35)
        MOV     R1,#0x1
        LCALL   ?Subroutine9
??CrossCallReturnLabel_21:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 31)
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        ANL     A,#0x1
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??dl2rc_3
        ; Setup parameters for call to function HalFlashErase
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,R7
        MOV     A,#0x9
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
        MOV     R1,?V0 + 0
        LCALL   HalFlashErase
        MOV     C,0x90.1
        JNC     ??dl2rc_2
        CLR     0x90.1
        LJMP    ??dl2rc_3
// 1112   }
// 1113   HAL_TURN_OFF_LED1();
??dl2rc_4:
        CLR     0x90.1
// 1114 }  
        MOV     A,#0x10
        CFI EndBlock cfiBlock48
        REQUIRE ?Subroutine2
        REQUIRE _A_P1
        ; // Fall through to label ?Subroutine2

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiBlock49 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 31)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI Invalid
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 15)
        CFI Valid
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock49
// 1115 
// 1116 /*********************************************************************
// 1117  * @fn      crcCalc
// 1118  *
// 1119  * @brief   Run the CRC16 Polynomial calculation over the RC image.
// 1120  *
// 1121  * @param   None.
// 1122  *
// 1123  * @return  The CRC16 calculated.
// 1124  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1125 static uint16 crcCalc(void)
??crcCalc:
        CFI Block cfiBlock50 Using cfiCommon0
        CFI Function ??crcCalc
        CODE
// 1126 {
        FUNCALL ??crcCalc, HalOADRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 32, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 32, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??crcCalc, HalOADRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 32, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 32, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??crcCalc, ??runPoly
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??crcCalc, ??runPoly
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??crcCalc, ??runPoly
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??crcCalc, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??crcCalc, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 15)
        ; Saved register size: 15
        ; Auto size: 13
        MOV     A,#-0xd
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 28)
// 1127   preamble_t preamble;
// 1128   uint32 oset;
// 1129   uint16 crc = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
// 1130   uint8 tmp;
// 1131 
// 1132   HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
        ; Setup parameters for call to function HalOADRead
        MOV     ?V0 + 0,#0xc
        MOV     ?V0 + 1,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 32)
        MOV     R1,#0x0
        MOV     DPTR,#__Constant_8c
        LCALL   ?XLOAD_R2345
        LCALL   ??Subroutine14_0
??CrossCallReturnLabel_24:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 28)
// 1133 
// 1134   if(preamble.len>HAL_OAD_RC_START)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
        CFI CFA_SP SP+-1
        PUSH    DPH
        CFI CFA_SP SP+-2
        MOV     DPTR,#__Constant_20001
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        POP     DPH
        CFI CFA_SP SP+-1
        POP     DPL
        CFI CFA_SP SP+0
        MOV     R0,#?V0 + 0
        LCALL   ?UL_GT_X
        JC      ??crcCalc_1
// 1135   {
// 1136 	return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??crcCalc_2
// 1137   }
// 1138 
// 1139   // Run the CRC calculation over the active body of code.
// 1140   for (oset = 0; oset < preamble.len; oset++)
??crcCalc_1:
        MOV     DPTR,#__Constant_0
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        SJMP    ??crcCalc_3
// 1141   {
// 1142  #if 1
// 1143     if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
// 1144     {
// 1145       uint8 buf;
// 1146       HalOADRead(oset, &buf, 1, HAL_OAD_RC);
// 1147       crc = runPoly(crc, buf);
// 1148     }
// 1149     if(0==(oset%HAL_FLASH_PAGE_SIZE))
// 1150     {
// 1151 	 HAL_TOGGLE_LED2();
??crcCalc_4:
        SETB    0x80.0
??crcCalc_5:
        MOV     DPTR,#__Constant_1
        MOV     R0,#?V0 + 4
        LCALL   ?L_ADD_X
??crcCalc_3:
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,#?V0 + 4
        LCALL   ?UL_GE_X
        JC      ??crcCalc_6
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
        MOV     ?V0 + 2,?V0 + 6
        MOV     ?V0 + 3,?V0 + 7
        MOV     DPTR,#__Constant_ffffff78
        MOV     R0,#?V0 + 0
        LCALL   ?L_ADD_X
        MOV     DPTR,#__Constant_4
        MOV     R0,#?V0 + 0
        LCALL   ?UL_GE_X
        JNC     ??CrossCallReturnLabel_5
        ; Setup parameters for call to function HalOADRead
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 32)
        MOV     R1,#0x0
        LCALL   ?Subroutine9
??CrossCallReturnLabel_22:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 28)
        ; Setup parameters for call to function runPoly
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ?Subroutine6
??CrossCallReturnLabel_5:
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
        MOV     A,?V0 + 1
        ANL     A,#0x7
        MOV     R1,A
        MOV     A,?V0 + 0
        ORL     A,R1
        JNZ     ??crcCalc_5
        MOV     C,0x80.0
        JNC     ??crcCalc_4
        CLR     0x80.0
        SJMP    ??crcCalc_5
// 1152     }
// 1153     //HAL_TURN_OFF_LED2();
// 1154 #else
// 1155 	uint8 buf;
// 1156 	HalOADRead(oset, &buf, 1, HAL_OAD_RC);
// 1157 	SendData(buf);
// 1158 #endif
// 1159 
// 1160   }
// 1161 
// 1162   // IAR note explains that poly must be run with value zero for each byte of crc.
// 1163   crc = runPoly(crc, 0);
??crcCalc_6:
        ; Setup parameters for call to function runPoly
        MOV     R1,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??runPoly
// 1164   crc = runPoly(crc, 0);
        ; Setup parameters for call to function runPoly
        MOV     R1,#0x0
        LCALL   ?Subroutine6
// 1165 
// 1166   SendData(crc>>8);
??CrossCallReturnLabel_6:
        ; Setup parameters for call to function SendData
        MOV     A,R7
        MOV     R1,A
        LCALL   ??SendData
// 1167   SendData(crc&0xff);
        ; Setup parameters for call to function SendData
        MOV     A,R6
        MOV     R1,A
        LCALL   ??SendData
// 1168 
// 1169   HAL_TURN_OFF_LED2();
        SETB    0x80.0
// 1170 
// 1171   return crc;
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??crcCalc_2:
        MOV     A,#0xd
        LJMP    ?Subroutine2
        CFI EndBlock cfiBlock50
        REQUIRE _A_P0
// 1172 }

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine9:
        CFI Block cfiCond51 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_21
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 35)
        CFI Block cfiCond52 Using cfiCommon0
        CFI (cfiCond52) NoFunction
        CFI (cfiCond52) Conditional ??CrossCallReturnLabel_22
        CFI (cfiCond52) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond52) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond52) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond52) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond52) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond52) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond52) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond52) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond52) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond52) V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond52) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond52) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond52) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond52) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond52) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond52) CFA_SP SP+0
        CFI (cfiCond52) CFA_XSP16 add(XSP16, 32)
        CFI Block cfiPicker53 Using cfiCommon1
        CFI (cfiPicker53) NoFunction
        CFI (cfiPicker53) Picker
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     R4,?V0 + 6
        MOV     R5,?V0 + 7
        CFI EndBlock cfiCond51
        CFI EndBlock cfiCond52
        CFI EndBlock cfiPicker53
        REQUIRE ??Subroutine14_0
        ; // Fall through to label ??Subroutine14_0

        RSEG NEAR_CODE:CODE:NOROOT(0)
??Subroutine14_0:
        CFI Block cfiCond54 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_23
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 35)
        CFI Block cfiCond55 Using cfiCommon0
        CFI (cfiCond55) NoFunction
        CFI (cfiCond55) Conditional ??CrossCallReturnLabel_24
        CFI (cfiCond55) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond55) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond55) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond55) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond55) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond55) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond55) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond55) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond55) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond55) V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond55) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond55) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond55) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond55) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond55) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond55) CFA_SP SP+0
        CFI (cfiCond55) CFA_XSP16 add(XSP16, 32)
        CFI Block cfiCond56 Using cfiCommon0
        CFI (cfiCond56) NoFunction
        CFI (cfiCond56) Conditional ??CrossCallReturnLabel_21
        CFI (cfiCond56) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond56) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond56) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond56) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond56) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond56) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond56) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond56) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond56) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond56) V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond56) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond56) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond56) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond56) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond56) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond56) CFA_SP SP+0
        CFI (cfiCond56) CFA_XSP16 add(XSP16, 35)
        CFI Block cfiCond57 Using cfiCommon0
        CFI (cfiCond57) NoFunction
        CFI (cfiCond57) Conditional ??CrossCallReturnLabel_22
        CFI (cfiCond57) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond57) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond57) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond57) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond57) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond57) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond57) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond57) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond57) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond57) V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond57) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond57) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond57) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond57) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond57) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond57) CFA_SP SP+0
        CFI (cfiCond57) CFA_XSP16 add(XSP16, 32)
        CFI Block cfiPicker58 Using cfiCommon1
        CFI (cfiPicker58) NoFunction
        CFI (cfiPicker58) Picker
        LCALL   HalOADRead
        MOV     A,#0x4
        RET
        CFI EndBlock cfiCond54
        CFI EndBlock cfiCond55
        CFI EndBlock cfiCond56
        CFI EndBlock cfiCond57
        CFI EndBlock cfiPicker58

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond59 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_5
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 28)
        CFI Block cfiCond60 Using cfiCommon0
        CFI (cfiCond60) NoFunction
        CFI (cfiCond60) Conditional ??CrossCallReturnLabel_6
        CFI (cfiCond60) R6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond60) VB load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond60) V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond60) V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond60) V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond60) V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond60) V4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond60) V5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond60) V6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond60) V7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond60) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond60) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond60) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond60) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond60) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond60) CFA_SP SP+0
        CFI (cfiCond60) CFA_XSP16 add(XSP16, 28)
        CFI Block cfiPicker61 Using cfiCommon1
        CFI (cfiPicker61) NoFunction
        CFI (cfiPicker61) Picker
        LCALL   ??runPoly
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R6,?V0 + 0
        MOV     R7,?V0 + 1
        RET
        CFI EndBlock cfiCond59
        CFI EndBlock cfiCond60
        CFI EndBlock cfiPicker61
// 1173 #endif
// 1174 //#endif
// 1175 
// 1176 /*********************************************************************
// 1177  * @fn      runPoly
// 1178  *
// 1179  * @brief   Run the CRC16 Polynomial calculation over the byte parameter.
// 1180  *
// 1181  * @param   crc - Running CRC calculated so far.
// 1182  * @param   val - Value on which to run the CRC16.
// 1183  *
// 1184  * @return  crc - Updated for the run.
// 1185  */
// 1186 #if _USER_OAD_FLASH_WRITE_

        RSEG NEAR_CODE:CODE:NOROOT(0)
// 1187 static uint16 runPoly(uint16 crc, uint8 val)
??runPoly:
        CFI Block cfiBlock62 Using cfiCommon0
        CFI Function ??runPoly
        CODE
// 1188 {
        PUSH    ?V0 + 0
        CFI V0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    ?V0 + 1
        CFI V1 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
// 1189   const uint16 poly = 0x1021;
// 1190   uint8 cnt;
// 1191 
// 1192   for (cnt = 0; cnt < 8; cnt++, val <<= 1)
        MOV     R4,#0x8
// 1193   {
// 1194     uint8 msb = (crc & 0x8000) ? 1 : 0;
??runPoly_1:
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0xf
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
// 1195 
// 1196     crc <<= 1;
        MOV     A,R2
        CLR     C
        RLC     A
        MOV     R2,A
        MOV     A,R3
        RLC     A
        MOV     R3,A
// 1197     if (val & 0x80)  crc |= 0x0001;
        MOV     A,R1
        MOV     C,0xE0 /* A   */.7
        JNC     ??runPoly_2
        MOV     A,#0x1
        ORL     A,R2
        MOV     R2,A
// 1198     if (msb)         crc ^= poly;
??runPoly_2:
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.0
        JNC     ??runPoly_3
        MOV     A,#0x21
        XRL     A,R2
        MOV     R2,A
        MOV     A,#0x10
        XRL     A,R3
        MOV     R3,A
// 1199   }
??runPoly_3:
        MOV     A,R1
        CLR     C
        RLC     A
        MOV     R1,A
        DEC     R4
        MOV     A,R4
        JNZ     ??runPoly_1
// 1200 
// 1201   return crc;
        POP     ?V0 + 1
        CFI V1 SameValue
        CFI CFA_SP SP+-3
        POP     ?V0 + 0
        CFI V0 SameValue
        CFI CFA_SP SP+-2
        RET
        CFI EndBlock cfiBlock62
// 1202 }

        RSEG NEAR_CODE:CODE:NOROOT(0)
HalOADRead:
        CFI Block cfiBlock63 Using cfiCommon0
        CFI Function HalOADRead
        CODE
        FUNCALL HalOADRead, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 15, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 15, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 13)
        ; Saved register size: 13
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     DPTR,#__Constant_20000
        MOV     R0,#?V0 + 0
        LCALL   ?L_ADD_X
        ; Setup parameters for call to function HalFlashRead
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     ?V0 + 4,?V0 + 0
        MOV     ?V0 + 5,?V0 + 1
        MOV     R2,?V0 + 4
        MOV     A,?V0 + 5
        ANL     A,#0x7
        MOV     R3,A
        MOV     A,#0xb
        MOV     R0,#?V0 + 0
        LCALL   ?UL_SHR
        MOV     R1,?V0 + 0
        LCALL   HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 13)
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock63

        RSEG NEAR_CODE:CODE:NOROOT(0)
main:
        CFI Block cfiBlock64 Using cfiCommon0
        CFI Function main
        CODE
        FUNCALL main, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesEncrDecr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??putsDialog
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??MemReadRam
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesEncrDecr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??crcCalc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??dl2rc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??MemReadRam
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??putsDialog
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??putsDialog
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??putsDialog
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesEncrDecr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Rcv
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashErase
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        ; Auto size: 20
        MOV     A,#-0x14
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     R6,#0x0
        MOV     R7,#0x8
        ANL     0xbe,#0xfb
??main_0:
        MOV     A,0x9d
        MOV     C,0xE0 /* A   */.6
        JNC     ??main_0
        NOP
        MOV     R0,#-0x8
        MOV     R1,#0x1
??main_1:
        NOP
        MOV     A,R0
        ADD     A,#-0x1
        DEC     R0
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??main_1
        MOV     0xc6,#-0x80
??main_2:
        MOV     A,#-0x80
        XRL     A,0x9e
        JNZ     ??main_2
        ORL     0xbe,#0x4
        MOV     DPTR,#0x6270
        MOV     A,R7
        MOVX    @DPTR,A
        ORL     0xfe,#0x2
        ORL     0xfd,#0x1
        MOV     A,#(dmaCh0 >> 8) & 0xff
        MOV     0xd5,A
        MOV     0xd4,#dmaCh0 & 0xff
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0 + 0,#0x1d
        MOV     ?V0 + 1,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#??ramCode & 0xff
        MOV     R5,#(??ramCode >> 8) & 0xff
        MOV     R2,#-0x1d
        MOV     R3,#0x7
        MOV     R1,#0x0
        LCALL   HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        ANL     0xf3,#0xcf
        ANL     0xfd,#0xdf
        ORL     0xfd,#0x10
        ORL     0xfd,#0x80
        CLR     0x80.4
        SETB    0x90.7
        ANL     0xf1,#0xfe
        ORL     0xf3,#0xc
        ORL     0x86,#0x80
        MOV     0xc5,#0xb
        MOV     0xc2,#-0x28
        CLR     0xe8.1
        ORL     0x86,#0x40
        CLR     0x88.3
        ANL     0xb3,#0x8f
        ORL     0xb3,#0x40
        SETB    0x80.0
        CLR     0x90.1
        MOV     A,0xb3
        ANL     A,#0xf8
        ORL     A,#0x4
        MOV     0xb3,A
        ORL     0xb3,#0x1
        MOV     R0,#0x0
??main_3:
        MOV     ?V0 + 0,R0
        MOV     A,#`?<Constant "WorkForYourDream">` & 0xff
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,#(`?<Constant "WorkForYourDream">` >> 8) & 0xff
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     0xb1,A
        INC     R0
        MOV     A,R0
        CLR     C
        SUBB    A,#0x10
        JC      ??main_3
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0 + 0,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x10
        MOV     R3,#0x7
        MOV     R1,#0x3
        LCALL   HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        ; Setup parameters for call to function halAesEncrDecr
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R1,#0x1
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??halAesEncrDecr
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        PUSH    DPL
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI CFA_SP SP+-4
        MOV     DPTR,#__Constant_3a4d3254
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        POP     DPH
        CFI CFA_SP SP+-3
        POP     DPL
        CFI CFA_SP SP+-2
        MOV     R0,#?V0 + 0
        LCALL   ?L_EQ_X
        JZ      $+5
        LJMP    ??main_4
        ; Setup parameters for call to function putsDialog
        MOV     R2,#`?<Constant "Initial\\r\\n">` & 0xff
        MOV     R3,#(`?<Constant "Initial\\r\\n">` >> 8) & 0xff
        LCALL   ??putsDialog
        MOV     DPTR,#__Constant_f8900a6
        LCALL   ?XLOAD_R2345
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?XSTORE_R2345
        ; Setup parameters for call to function MemReadRam
        MOV     R1,#0x8
        MOV     A,R1
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     R3,#0x78
        LCALL   ??MemReadRam
        ; Setup parameters for call to function halAesEncrDecr
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R1,#0x0
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??halAesEncrDecr
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        ; Setup parameters for call to function HalFlashErase
        MOV     R1,#0x3
        LCALL   HalFlashErase
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0 + 0,#0x4
        MOV     ?V0 + 1,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x4
        MOV     R3,#0x7
        LCALL   HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
??main_5:
        MOV     C,0x80.5
        JC      $+5
        LJMP    ??main_6
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0 + 0,#0x4
        MOV     ?V0 + 1,R6
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x78
        MOV     R3,#0x0
        MOV     R1,#0x40
        LCALL   HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??main_7
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R7
??main_7:
        JNZ     $+5
        LJMP    ??main_8
        ; Setup parameters for call to function SendData
        MOV     A,R7
        MOV     R1,A
        LCALL   ??SendData
        ; Setup parameters for call to function SendData
        MOV     A,R6
        MOV     R1,A
        LCALL   ??SendData
        ; Setup parameters for call to function crcCalc
        LCALL   ??crcCalc
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        XRL     A,R0
        JNZ     ??main_9
        MOV     A,R3
        XRL     A,R1
??main_9:
        JZ      $+5
        LJMP    ??main_10
        ; Setup parameters for call to function dl2rc
        LCALL   ??dl2rc
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LJMP    ??main_10
??main_4:
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI CFA_SP SP+-4
        MOV     DPTR,#__Constant_f8900a6
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV_X
        POP     DPH
        CFI CFA_SP SP+-3
        POP     DPL
        CFI CFA_SP SP+-2
        MOV     R0,#?V0 + 0
        LCALL   ?L_EQ_X
        JNZ     ??main_11
        ; Setup parameters for call to function MemReadRam
        MOV     R1,#0x8
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     R3,#0x78
        LCALL   ??MemReadRam
        MOV     ?V0 + 2,R7
        MOV     ?V0 + 3,R6
        MOV     A,R7
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,DPL
        MOV     R1,DPH
??main_12:
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     A,R4
        ADD     A,#-0x1
        MOV     ?V0 + 2,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     ?V0 + 3,A
        MOV     A,R4
        ORL     A,R5
        JZ      ??main_13
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        XRL     A,R4
        JZ      ??main_12
        ; Setup parameters for call to function putsDialog
        MOV     R2,#`?<Constant "Verified Error">` & 0xff
        MOV     R3,#(`?<Constant "Verified Error">` >> 8) & 0xff
        LCALL   ??putsDialog
??main_14:
        SJMP    ??main_14
??main_13:
        ; Setup parameters for call to function putsDialog
        MOV     R2,#`?<Constant "Start\\r\\n">` & 0xff
        MOV     R3,#(`?<Constant "Start\\r\\n">` >> 8) & 0xff
        LCALL   ??putsDialog
        LJMP    ??main_5
??main_11:
        ; Setup parameters for call to function putsDialog
        MOV     R2,#`?<Constant "Verified Error">` & 0xff
        MOV     R3,#(`?<Constant "Verified Error">` >> 8) & 0xff
        LCALL   ??putsDialog
??main_15:
        SJMP    ??main_15
??main_16:
        ; Setup parameters for call to function halAesEncrDecr
        MOV     ?V0 + 0,#0x14
        MOV     ?V0 + 1,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R1,#0x1
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     R2,#0x14
        MOV     R3,#0x1
        LCALL   ??halAesEncrDecr
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        ANL     A,#0x1
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??main_17
        ; Setup parameters for call to function HalFlashErase
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,R7
        MOV     A,#0x9
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
        MOV     R1,?V0 + 0
        LCALL   HalFlashErase
??main_17:
        ; Setup parameters for call to function HalFlashWrite
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     ?V0 + 0,A
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#0x14
        MOV     R5,#0x1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R0,A
        MOV     A,R6
        ADD     A,R0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#0x113
        MOV     A,#0x2
??main_18:
        MOVX    @DPTR,A
        ; Setup parameters for call to function Message_Send
        LCALL   ??Message_Send
??main_6:
        ; Setup parameters for call to function Message_Rcv
        LCALL   ??Message_Rcv
        MOV     A,R1
        JZ      ??main_6
        MOV     DPTR,#0x100
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#0x102
        MOVX    @DPTR,A
        MOV     DPTR,#0x111
        MOVX    A,@DPTR
        ADD     A,#-0x41
        JNZ     $+5
        LJMP    ??main_16
        DEC     A
        JNZ     ??main_6
        MOV     DPTR,#0x114
        MOV     A,#0x55
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#0x113
        MOV     A,#0x3
        SJMP    ??main_18
??main_10:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        ; Setup parameters for call to function HalFlashErase
        MOV     R1,#0x40
        LCALL   HalFlashErase
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0x22
        MOV     R3,#-0x80
        LCALL   HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 20)
??main_8:
        CLR     0x80.0
        CLR     0x90.1
        LJMP 0x2000
        MOV     A,#0x14
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        RET
        CFI EndBlock cfiBlock64
        REQUIRE SLEEPCMD
        REQUIRE SLEEPSTA
        REQUIRE CLKCONCMD
        REQUIRE CLKCONSTA
        REQUIRE P1DIR
        REQUIRE P0DIR
        REQUIRE DMA0CFGH
        REQUIRE DMA0CFGL
        REQUIRE P0SEL
        REQUIRE _A_P0
        REQUIRE _A_P1
        REQUIRE ENCCS
        REQUIRE ENCDI
        REQUIRE PERCFG
        REQUIRE U0CSR
        REQUIRE U0GCR
        REQUIRE U0BAUD
        REQUIRE _A_IRCON2
        REQUIRE _A_TCON

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "WorkForYourDream"`:
        DB "WorkForYourDream"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Initial\\r\\n">>`:
        DB "Initial\015\012"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Verified Error">>`:
        DB "Verified Error"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Start\\r\\n">>`:
        DB "Start\015\012"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_3a4d3254>`:
        DATA32
        DD 978137684

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_f8900a6>`:
        DATA32
        DD 260636838

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_8c>`:
        DATA32
        DD 140

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_0>`:
        DATA32
        DD 0

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_4>`:
        DATA32
        DD 4

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_20001>`:
        DATA32
        DD 131073

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_1>`:
        DATA32
        DD 1

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_ffffff78>`:
        DATA32
        DD 4294967160

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_20000>`:
        DATA32
        DD 131072

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "WorkForYourDream">`:
        DS 17
        REQUIRE `?<Initializer for <Constant "WorkForYourDream"`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "Initial\\r\\n">`:
        DS 10
        REQUIRE `?<Initializer for <Constant "Initial\\r\\n">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "Verified Error">`:
        DS 15
        REQUIRE `?<Initializer for <Constant "Verified Error">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "Start\\r\\n">`:
        DS 8
        REQUIRE `?<Initializer for <Constant "Start\\r\\n">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_3a4d3254:
        DS 4
        REQUIRE `?<Initializer for __Constant_3a4d3254>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_f8900a6:
        DS 4
        REQUIRE `?<Initializer for __Constant_f8900a6>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_8c:
        DS 4
        REQUIRE `?<Initializer for __Constant_8c>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_0:
        DS 4
        REQUIRE `?<Initializer for __Constant_0>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_4:
        DS 4
        REQUIRE `?<Initializer for __Constant_4>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_20001:
        DS 4
        REQUIRE `?<Initializer for __Constant_20001>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_1:
        DS 4
        REQUIRE `?<Initializer for __Constant_1>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_ffffff78:
        DS 4
        REQUIRE `?<Initializer for __Constant_ffffff78>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_20000:
        DS 4
        REQUIRE `?<Initializer for __Constant_20000>`
        REQUIRE __INIT_XDATA_I

        END
// 1203 
// 1204 /*********************************************************************
// 1205  * @fn      HalOADChkDL
// 1206  *
// 1207  * @brief   Run the CRC16 Polynomial calculation over the DL image.
// 1208  *
// 1209  * @param   dlImagePreambleOffset - Offset into the monolithic DL image to read the preamble.
// 1210  *
// 1211  * @return  SUCCESS or FAILURE.
// 1212  *********************************************************************/
// 1213  #if 0
// 1214 uint8 HalOADChkDL(uint8 dlImagePreambleOffset)
// 1215 {
// 1216   preamble_t preamble;
// 1217   uint32 oset;
// 1218   uint16 crc = 0, crc2;
// 1219 
// 1220   HalOADRead(dlImagePreambleOffset, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
// 1221 
// 1222   // Run the CRC calculation over the downloaded image.
// 1223   for (oset = 0; oset < preamble.len; oset++)
// 1224   {
// 1225     if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
// 1226     {
// 1227       uint8 buf;
// 1228       HalOADRead(oset, &buf, 1, HAL_OAD_DL);
// 1229       crc = runPoly(crc, buf);
// 1230     }
// 1231   }
// 1232 
// 1233   // IAR note explains that poly must be run with value zero for each byte of crc.
// 1234   crc = runPoly(crc, 0);
// 1235   crc = runPoly(crc, 0);
// 1236 
// 1237   HalOADRead(HAL_OAD_CRC_OSET, (uint8 *)&crc2, sizeof(crc2), HAL_OAD_DL);
// 1238   return (crc2 == crc) ? SUCCESS : FAILURE;
// 1239 }
// 1240  #endif
// 1241 
// 1242 /*********************************************************************
// 1243  * @fn      HalOADInvRC
// 1244  *
// 1245  * @brief   Invalidate the active image so that the boot code will instantiate the DL image on the
// 1246  *          next reset.
// 1247  *
// 1248  * @param   None.
// 1249  *
// 1250  * @return  None.
// 1251  *********************************************************************/
// 1252 void HalOADInvRC(void)
// 1253 {
// 1254   uint16 crc[2] = {0,0xFFFF};
// 1255   HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
// 1256 }
// 1257 
// 1258 /*********************************************************************
// 1259  * @fn      HalOADRead
// 1260  *
// 1261  * @brief   Read from the storage medium according to image type.
// 1262  *
// 1263  * @param   oset - Offset into the monolithic image.
// 1264  * @param   pBuf - Pointer to the buffer in which to copy the bytes read.
// 1265  * @param   len - Number of bytes to read.
// 1266  * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
// 1267  *
// 1268  * @return  None.
// 1269  *********************************************************************/
// 1270 void HalOADRead(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
// 1271 {
// 1272 #if 0
// 1273   if (HAL_OAD_RC != type)
// 1274   {
// 1275 #if HAL_OAD_XNV_IS_INT
// 1276     preamble_t preamble;
// 1277 
// 1278     HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
// 1279     //oset += HAL_OAD_RC_START + preamble.len;
// 1280     oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
// 1281 #elif HAL_OAD_XNV_IS_SPI
// 1282     oset += HAL_OAD_DL_OSET;
// 1283     HalSPIRead(oset, pBuf, len);
// 1284     return;
// 1285 #endif
// 1286   }
// 1287   else
// 1288   {
// 1289     oset += HAL_OAD_RC_START;
// 1290   }
// 1291  #endif
// 1292 
// 1293   oset += HAL_OAD_RC_START;
// 1294   HalFlashRead(oset / HAL_FLASH_PAGE_SIZE, oset % HAL_FLASH_PAGE_SIZE, pBuf, len);
// 1295 }
// 1296 
// 1297 /*********************************************************************
// 1298  * @fn      HalOADWrite
// 1299  *
// 1300  * @brief   Write to the storage medium according to the image type.
// 1301  *
// 1302  *  NOTE:   Destructive write on page boundary! When writing to the first flash word
// 1303  *          of a page boundary, the page is erased without saving/restoring the bytes not written.
// 1304  *          Writes anywhere else on a page assume that the location written to has been erased.
// 1305  *
// 1306  * @param   oset - Offset into the monolithic image, aligned to HAL_FLASH_WORD_SIZE.
// 1307  * @param   pBuf - Pointer to the buffer in from which to write.
// 1308  * @param   len - Number of bytes to write. If not an even multiple of HAL_FLASH_WORD_SIZE,
// 1309  *                remainder bytes are overwritten with garbage.
// 1310  * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
// 1311  *
// 1312  * @return  None.
// 1313  *********************************************************************/
// 1314 void HalOADWrite(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
// 1315 {
// 1316   if (HAL_OAD_RC != type)
// 1317   {
// 1318 #if HAL_OAD_XNV_IS_INT
// 1319     preamble_t preamble;
// 1320 
// 1321     HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
// 1322     //oset += HAL_OAD_RC_START + preamble.len;
// 1323     oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
// 1324 #elif HAL_OAD_XNV_IS_SPI
// 1325     oset += HAL_OAD_DL_OSET;
// 1326     HalSPIWrite(oset, pBuf, len);
// 1327     return;
// 1328 #endif
// 1329   }
// 1330   else
// 1331   {
// 1332     oset += HAL_OAD_RC_START;
// 1333   }
// 1334 
// 1335   if ((oset % HAL_FLASH_PAGE_SIZE) == 0)
// 1336   {
// 1337     HalFlashErase(oset / HAL_FLASH_PAGE_SIZE);
// 1338   }
// 1339 
// 1340   HalFlashWrite(oset / HAL_FLASH_WORD_SIZE, pBuf, len / HAL_FLASH_WORD_SIZE);
// 1341 }
// 1342 
// 1343 #if HAL_OAD_XNV_IS_INT
// 1344 /*********************************************************************
// 1345  * @fn      HalOADAvail
// 1346  *
// 1347  * @brief   Determine the space available for downloading an image.
// 1348  *
// 1349  * @param   None.
// 1350  *
// 1351  * @return  Number of bytes available for storing an OAD image.
// 1352  *********************************************************************/
// 1353 uint32 HalOADAvail(void)
// 1354 {
// 1355   /*
// 1356   preamble_t preamble;
// 1357 
// 1358   HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
// 1359   return HAL_OAD_DL_MAX - preamble.len;
// 1360    */
// 1361   return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
// 1362 }
// 1363 
// 1364 #elif HAL_OAD_XNV_IS_SPI
// 1365 
// 1366 /*********************************************************************
// 1367  * CONSTANTS
// 1368  */
// 1369 
// 1370 #define XNV_STAT_CMD  0x05
// 1371 #define XNV_WREN_CMD  0x06
// 1372 #define XNV_WRPG_CMD  0x0A
// 1373 #define XNV_READ_CMD  0x0B
// 1374 
// 1375 #define XNV_STAT_WIP  0x01
// 1376 
// 1377 /*********************************************************************
// 1378  * @fn      xnvSPIWrite
// 1379  *
// 1380  * @brief   SPI write sequence for code size savings.
// 1381  *
// 1382  * @param   ch - The byte to write to the SPI.
// 1383  *
// 1384  * @return  None.
// 1385  *********************************************************************/
// 1386 static void xnvSPIWrite(uint8 ch);
// 1387 static void xnvSPIWrite(uint8 ch)
// 1388 {
// 1389   XNV_SPI_TX(ch);
// 1390   XNV_SPI_WAIT_RXRDY();
// 1391 }
// 1392 
// 1393 /*********************************************************************
// 1394  * @fn      HalOADAvail
// 1395  *
// 1396  * @brief   Determine the space available for downloading an image.
// 1397  *
// 1398  * @param   None.
// 1399  *
// 1400  * @return  Number of bytes available for storing an OAD image.
// 1401  *********************************************************************/
// 1402 uint32 HalOADAvail(void)
// 1403 {
// 1404   return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
// 1405 }
// 1406 
// 1407 /*********************************************************************
// 1408  * @fn      HalSPIRead
// 1409  *
// 1410  * @brief   Read from the external NV storage via SPI.
// 1411  *
// 1412  * @param   addr - Offset into the external NV.
// 1413  * @param   pBuf - Pointer to the buffer in which to copy the bytes read from external NV.
// 1414  * @param   len - Number of bytes to read from external NV.
// 1415  *
// 1416  * @return  None.
// 1417  *********************************************************************/
// 1418  #if 0
// 1419 static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len)
// 1420 {
// 1421 #if !HAL_OAD_BOOT_CODE
// 1422   uint8 shdw = P1DIR;
// 1423   halIntState_t his;
// 1424   HAL_ENTER_CRITICAL_SECTION(his);
// 1425   P1DIR |= BV(3);
// 1426 #endif
// 1427 
// 1428   XNV_SPI_BEGIN();
// 1429   do {
// 1430     xnvSPIWrite(XNV_STAT_CMD);
// 1431   } while (XNV_SPI_RX() & XNV_STAT_WIP);
// 1432   XNV_SPI_END();
// 1433   asm("NOP"); asm("NOP");
// 1434 
// 1435   XNV_SPI_BEGIN();
// 1436   xnvSPIWrite(XNV_READ_CMD);
// 1437   xnvSPIWrite(addr >> 16);
// 1438   xnvSPIWrite(addr >> 8);
// 1439   xnvSPIWrite(addr);
// 1440   xnvSPIWrite(0);
// 1441 
// 1442   while (len--)
// 1443   {
// 1444     xnvSPIWrite(0);
// 1445     *pBuf++ = XNV_SPI_RX();
// 1446   }
// 1447   XNV_SPI_END();
// 1448 
// 1449 #if !HAL_OAD_BOOT_CODE
// 1450   P1DIR = shdw;
// 1451   HAL_EXIT_CRITICAL_SECTION(his);
// 1452 #endif
// 1453 }
// 1454  #endif
// 1455 
// 1456 /*********************************************************************
// 1457  * @fn      HalSPIWrite
// 1458  *
// 1459  * @brief   Write to the external NV storage via SPI.
// 1460  *
// 1461  * @param   addr - Offset into the external NV.
// 1462  * @param   pBuf - Pointer to the buffer in from which to write bytes to external NV.
// 1463  * @param   len - Number of bytes to write to external NV.
// 1464  *
// 1465  * @return  None.
// 1466  *********************************************************************/
// 1467 static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len)
// 1468 {
// 1469   uint8 cnt;
// 1470 #if !HAL_OAD_BOOT_CODE
// 1471   uint8 shdw = P1DIR;
// 1472   halIntState_t his;
// 1473   HAL_ENTER_CRITICAL_SECTION(his);
// 1474   P1DIR |= BV(3);
// 1475 #endif
// 1476 
// 1477   while (len)
// 1478   {
// 1479     XNV_SPI_BEGIN();
// 1480     do {
// 1481       xnvSPIWrite(XNV_STAT_CMD);
// 1482     } while (XNV_SPI_RX() & XNV_STAT_WIP);
// 1483     XNV_SPI_END();
// 1484     asm("NOP"); asm("NOP");
// 1485 
// 1486     XNV_SPI_BEGIN();
// 1487     xnvSPIWrite(XNV_WREN_CMD);
// 1488     XNV_SPI_END();
// 1489     asm("NOP"); asm("NOP");
// 1490 
// 1491     XNV_SPI_BEGIN();
// 1492     xnvSPIWrite(XNV_WRPG_CMD);
// 1493     xnvSPIWrite(addr >> 16);
// 1494     xnvSPIWrite(addr >> 8);
// 1495     xnvSPIWrite(addr);
// 1496 
// 1497     // Can only write within any one page boundary, so prepare for next page write if bytes remain.
// 1498     cnt = 0 - (uint8)addr;
// 1499     if (cnt)
// 1500     {
// 1501       addr += cnt;
// 1502     }
// 1503     else
// 1504     {
// 1505       addr += 256;
// 1506     }
// 1507 
// 1508     do
// 1509     {
// 1510       xnvSPIWrite(*pBuf++);
// 1511       cnt--;
// 1512       len--;
// 1513     } while (len && cnt);
// 1514     XNV_SPI_END();
// 1515   }
// 1516 
// 1517 #if !HAL_OAD_BOOT_CODE
// 1518   P1DIR = shdw;
// 1519   HAL_EXIT_CRITICAL_SECTION(his);
// 1520 #endif
// 1521 }
// 1522 #else
// 1523 #error Invalid Xtra-NV for OAD.
// 1524 #endif
// 1525 
// 1526 #endif
// 1527 
// 1528 /**************************************************************************************************
// 1529 */
// C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_uart.c
//    1 /**************************************************************************************************
//    2   Filename:       _hal_uart.c
//    3   Revised:        $Date: 2009-06-12 09:16:43 -0700 (Fri, 12 Jun 2009) $
//    4   Revision:       $Revision: 20142 $
//    5 
//    6   Description: This file contains the interface to the H/W UART driver.
//    7 
//    8 
//    9   Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 
//   44 #include "hal_board_cfg.h"
//   45 #include "hal_defs.h"
//   46 #include "hal_types.h"
//   47 #include "hal_uart.h"
//   48 
//   49 /*********************************************************************
//   50  * MACROS
//   51  */
//   52 
//   53 /*********************************************************************
//   54  * TYPEDEFS
//   55  */
//   56 
//   57 /*********************************************************************
//   58  * CONSTANTS
//   59  */
//   60 
//   61 /*********************************************************************
//   62  * GLOBAL VARIABLES
//   63  */
//   64 
//   65 /*********************************************************************
//   66  * GLOBAL FUNCTIONS
//   67  */
//   68 
//   69 /*********************************************************************
//   70  * LOCAL VARIABLES
//   71  */
//   72 
//   73 /*********************************************************************
//   74  * LOCAL FUNCTIONS
//   75  */
//   76 
//   77 #if HAL_UART_DMA
//   78 #include "_hal_uart_dma.c"
//   79 #endif
//   80 #if HAL_UART_ISR
//   81 #include "_hal_uart_isr.c"
//   82 #endif
//   83 #if HAL_UART_USB
//   84 #include "_hal_uart_usb.c"
//   85 #endif
//   86 
//   87 /******************************************************************************
//   88  * @fn      HalUARTInit
//   89  *
//   90  * @brief   Initialize the UART
//   91  *
//   92  * @param   none
//   93  *
//   94  * @return  none
//   95  *****************************************************************************/
//   96 void HalUARTInit(void)
//   97 {
//   98 #if HAL_UART_DMA
//   99   HalUARTInitDMA();
//  100 #endif
//  101 #if HAL_UART_ISR
//  102   HalUARTInitISR();
//  103 #endif
//  104 #if HAL_UART_USB
//  105   HalUARTInitUSB();
//  106 #endif
//  107 }
//  108 
//  109 /******************************************************************************
//  110  * @fn      HalUARTOpen
//  111  *
//  112  * @brief   Open a port according tp the configuration specified by parameter.
//  113  *
//  114  * @param   port   - UART port
//  115  *          config - contains configuration information
//  116  *
//  117  * @return  Status of the function call
//  118  *****************************************************************************/
//  119 uint8 HalUARTOpen(uint8 port, halUARTCfg_t *config)
//  120 {
//  121   (void)port;
//  122   (void)config;
//  123 
//  124 #if (HAL_UART_DMA == 1)
//  125   if (port == HAL_UART_PORT_0)  HalUARTOpenDMA(config);
//  126 #endif
//  127 #if (HAL_UART_DMA == 2)
//  128   if (port == HAL_UART_PORT_1)  HalUARTOpenDMA(config);
//  129 #endif
//  130 #if (HAL_UART_ISR == 1)
//  131   if (port == HAL_UART_PORT_0)  HalUARTOpenISR(config);
//  132 #endif
//  133 #if (HAL_UART_ISR == 2)
//  134   if (port == HAL_UART_PORT_1)  HalUARTOpenISR(config);
//  135 #endif
//  136 #if (HAL_UART_USB)
//  137   HalUARTOpenUSB(config);
//  138 #endif
//  139   
//  140   return HAL_UART_SUCCESS;
//  141 }
//  142 
//  143 /*****************************************************************************
//  144  * @fn      HalUARTRead
//  145  *
//  146  * @brief   Read a buffer from the UART
//  147  *
//  148  * @param   port - USART module designation
//  149  *          buf  - valid data buffer at least 'len' bytes in size
//  150  *          len  - max length number of bytes to copy to 'buf'
//  151  *
//  152  * @return  length of buffer that was read
//  153  *****************************************************************************/
//  154 uint16 HalUARTRead(uint8 port, uint8 *buf, uint16 len)
//  155 {
//  156   (void)port;
//  157   (void)buf;
//  158   (void)len;
//  159 
//  160 #if (HAL_UART_DMA == 1)
//  161   if (port == HAL_UART_PORT_0)  return HalUARTReadDMA(buf, len);
//  162 #endif
//  163 #if (HAL_UART_DMA == 2)
//  164   if (port == HAL_UART_PORT_1)  return HalUARTReadDMA(buf, len);
//  165 #endif
//  166 #if (HAL_UART_ISR == 1)
//  167   if (port == HAL_UART_PORT_0)  return HalUARTReadISR(buf, len);
//  168 #endif
//  169 #if (HAL_UART_ISR == 2)
//  170   if (port == HAL_UART_PORT_1)  return HalUARTReadISR(buf, len);
//  171 #endif
//  172 
//  173 #if HAL_UART_USB
//  174   return HalUARTRx(buf, len);
//  175 #else
//  176   return 0;
//  177 #endif
//  178 }
//  179 
//  180 /******************************************************************************
//  181  * @fn      HalUARTWrite
//  182  *
//  183  * @brief   Write a buffer to the UART.
//  184  *
//  185  * @param   port - UART port
//  186  *          buf  - pointer to the buffer that will be written, not freed
//  187  *          len  - length of
//  188  *
//  189  * @return  length of the buffer that was sent
//  190  *****************************************************************************/
//  191 uint16 HalUARTWrite(uint8 port, uint8 *buf, uint16 len)
//  192 {
//  193   (void)port;
//  194   (void)buf;
//  195   (void)len;
//  196 
//  197 #if (HAL_UART_DMA == 1)
//  198   if (port == HAL_UART_PORT_0)  return HalUARTWriteDMA(buf, len);
//  199 #endif
//  200 #if (HAL_UART_DMA == 2)
//  201   if (port == HAL_UART_PORT_1)  return HalUARTWriteDMA(buf, len);
//  202 #endif
//  203 #if (HAL_UART_ISR == 1)
//  204   if (port == HAL_UART_PORT_0)  return HalUARTWriteISR(buf, len);
//  205 #endif
//  206 #if (HAL_UART_ISR == 2)
//  207   if (port == HAL_UART_PORT_1)  return HalUARTWriteISR(buf, len);
//  208 #endif
//  209 
//  210 #if HAL_UART_USB
//  211   HalUARTTx(buf, len);
//  212   return len;
//  213 #else
//  214   return 0;
//  215 #endif
//  216 }
//  217 
//  218 /******************************************************************************
//  219  * @fn      HalUARTSuspend
//  220  *
//  221  * @brief   Suspend UART hardware before entering PM mode 1, 2 or 3.
//  222  *
//  223  * @param   None
//  224  *
//  225  * @return  None
//  226  *****************************************************************************/
//  227 void HalUARTSuspend( void )
//  228 {
//  229 #if HAL_UART_DMA
//  230   HalUARTSuspendDMA();
//  231 #endif
//  232 #if HAL_UART_ISR
//  233   HalUARTSuspendISR();
//  234 #endif
//  235 }
//  236 
//  237 /******************************************************************************
//  238  * @fn      HalUARTResume
//  239  *
//  240  * @brief   Resume UART hardware after exiting PM mode 1, 2 or 3.
//  241  *
//  242  * @param   None
//  243  *
//  244  * @return  None
//  245  *****************************************************************************/
//  246 void HalUARTResume( void )
//  247 {
//  248 #if HAL_UART_DMA
//  249   HalUARTResumeDMA();
//  250 #endif
//  251 #if HAL_UART_ISR
//  252   HalUARTResumeISR();
//  253 #endif
//  254 }
//  255 
//  256 /***************************************************************************************************
//  257  * @fn      HalUARTPoll
//  258  *
//  259  * @brief   Poll the UART.
//  260  *
//  261  * @param   none
//  262  *
//  263  * @return  none
//  264  *****************************************************************************/
//  265 void HalUARTPoll(void)
//  266 {
//  267 #if HAL_UART_DMA
//  268   HalUARTPollDMA();
//  269 #endif
//  270 #if HAL_UART_ISR
//  271   HalUARTPollISR();
//  272 #endif
//  273 #if HAL_UART_USB
//  274   HalUARTPollUSB();
//  275 #endif
//  276 }
//  277 
//  278 /**************************************************************************************************
//  279  * @fn      Hal_UART_RxBufLen()
//  280  *
//  281  * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
//  282  *
//  283  * @param   port - UART port
//  284  *
//  285  * @return  length of current Rx Buffer
//  286  **************************************************************************************************/
//  287 uint16 Hal_UART_RxBufLen( uint8 port )
//  288 {
//  289   (void)port;
//  290 
//  291 #if (HAL_UART_DMA == 1)
//  292   if (port == HAL_UART_PORT_0)  return HalUARTRxAvailDMA();
//  293 #endif
//  294 #if (HAL_UART_DMA == 2)
//  295   if (port == HAL_UART_PORT_1)  return HalUARTRxAvailDMA();
//  296 #endif
//  297 #if (HAL_UART_ISR == 1)
//  298   if (port == HAL_UART_PORT_0)  return HalUARTRxAvailISR();
//  299 #endif
//  300 #if (HAL_UART_ISR == 2)
//  301   if (port == HAL_UART_PORT_1)  return HalUARTRxAvailISR();
//  302 #endif
//  303 #if HAL_UART_USB
//  304   return HalUARTRxAvailUSB();
//  305 #else
//  306   return 0;
//  307 #endif
//  308 }
//  309 
//  310 /******************************************************************************
//  311 ******************************************************************************/
// 
// 2 403 bytes in segment NEAR_CODE
//    27 bytes in segment RAM_CODE_FLASH
//    29 bytes in segment RAM_CODE_XDATA
//    24 bytes in segment SFR_AN
//    86 bytes in segment XDATA_I
//    86 bytes in segment XDATA_ID
//     8 bytes in segment XDATA_Z
// 
// 2 480 bytes of CODE  memory (+ 36 bytes shared)
//     0 bytes of DATA  memory (+ 24 bytes shared)
//    87 bytes of XDATA memory (+ 36 bytes shared)
//
//Errors: none
//Warnings: 7
