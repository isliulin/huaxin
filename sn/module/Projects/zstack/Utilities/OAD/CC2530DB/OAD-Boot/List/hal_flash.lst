###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.4.40412/W32 for 8051         19/Jun/2016  18:59:08 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\freeman\Documents\work\SN\module\Componen #
#                          ts\hal\target\CC2530EB\hal_flash.c                 #
#    Command line       =  C:\Users\freeman\Documents\work\SN\module\Componen #
#                          ts\hal\target\CC2530EB\hal_flash.c -D              #
#                          HAL_OAD_BOOT_CODE -lC C:\Users\freeman\Documents\w #
#                          ork\SN\module\Projects\zstack\Utilities\OAD\CC2530 #
#                          DB\OAD-Boot\List\ -lA C:\Users\freeman\Documents\w #
#                          ork\SN\module\Projects\zstack\Utilities\OAD\CC2530 #
#                          DB\OAD-Boot\List\ --remarks -o                     #
#                          C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\Obj\ -e    #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=near               #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 16 -I     #
#                          C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\ -I                 #
#                          C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\SOURCE\ -I          #
#                          C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\..\..\..\Tools\CC25 #
#                          30DB\ -I C:\Users\freeman\Documents\work\SN\module #
#                          \Projects\zstack\Utilities\OAD\CC2530DB\..\..\..\Z #
#                          MAIN\TI2530DB\ -I C:\Users\freeman\Documents\work\ #
#                          SN\module\Projects\zstack\Utilities\OAD\CC2530DB\. #
#                          .\..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I           #
#                          C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\INCLUDE\ -I C:\Users\freeman\Documents #
#                          \work\SN\module\Projects\zstack\Utilities\OAD\CC25 #
#                          30DB\..\..\..\..\..\COMPONENTS\hal\common\ -I      #
#                          C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\HAL\TARGET\CC2530EB\ -Ohz                   #
#                          --require_prototypes --mfc                         #
#                          --discard_unused_publics                           #
#                          C:\Users\freeman\Documents\work\SN\module\Componen #
#                          ts\hal\target\CC2530EB\hal_oad.c                   #
#                          C:\Users\freeman\Documents\work\SN\module\Componen #
#                          ts\hal\target\CC2530EB\hal_uart.c                  #
#    List file          =  C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\List\hal_f #
#                          lash.lst                                           #
#    Object file        =  C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\Obj\hal_fl #
#                          ash.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_flash.c
      1          /**************************************************************************************************
      2            Filename:       _hal_flash.c
      3            Revised:        $Date:$
      4            Revision:       $Revision:$
      5          
      6            Description: This file contains the interface to the H/W Flash driver.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb1
   \   unsigned char volatile __sfr ENCDI
   \                     ENCDI:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb2
   \   unsigned char volatile __sfr ENCDO
   \                     ENCDO:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb3
   \   unsigned char volatile __sfr ENCCS
   \                     ENCCS:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc7
   \   unsigned char volatile __sfr MEMCTR
   \                     MEMCTR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     46          #include "hal_dma.h"
     47          #include "hal_flash.h"
     48          #include "hal_types.h"
     49          
     50          /* ------------------------------------------------------------------------------------------------
     51           *                                           Macros
     52           * ------------------------------------------------------------------------------------------------
     53           */
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                          Constants
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          // These values depend on RAM_CODE_FLASH in the .xcl file used.
     61          #if defined CC2530F64     // RemoTI is using 0x01DDD --> pg 3, offset 0x5DD.
     62          #define OSET_OF_RAM_CODE  0x5DD
     63          #define PAGE_OF_RAM_CODE  3
     64          #define SIZE_OF_RAM_CODE  0x23
     65          #elif defined HAL_OAD_BOOT_CODE
     66                                    // OAD boot code is using 0x7E3 --> pg 0, so same as offset 0x7E3.
     67          #define OSET_OF_RAM_CODE  0x7E3
     68          #define PAGE_OF_RAM_CODE  0
     69          #define SIZE_OF_RAM_CODE  0x1D
     70          #elif defined HAL_USB_BOOT_CODE
     71                                    // USB boot code is using 0x7DD --> pg 0, so same as offset 0x7DD.
     72          #define OSET_OF_RAM_CODE  0x7DD
     73          #define PAGE_OF_RAM_CODE  0
     74          #define SIZE_OF_RAM_CODE  0x23
     75          #else                     // Z-Stack is using 0x39EDD --> pg 51, offset 0x6DD.
     76          #define OSET_OF_RAM_CODE  0x6DD
     77          #define PAGE_OF_RAM_CODE  51
     78          #define SIZE_OF_RAM_CODE  0x23
     79          #endif
     80          
     81          /* ------------------------------------------------------------------------------------------------
     82           *                                          Typedefs
     83           * ------------------------------------------------------------------------------------------------
     84           */
     85          
     86          /* ------------------------------------------------------------------------------------------------
     87           *                                       Global Variables
     88           * ------------------------------------------------------------------------------------------------
     89           */
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                       Global Functions
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          
     96          /* ------------------------------------------------------------------------------------------------
     97           *                                       Local Variables
     98           * ------------------------------------------------------------------------------------------------
     99           */
    100          
    101          #pragma location="RAM_CODE_XDATA"

   \                                 In  segment RAM_CODE_XDATA, align 1
    102          static __no_init uint8 ramCode[SIZE_OF_RAM_CODE];
   \                     ??ramCode:
   \   000000                DS 29
    103          
    104          /* ------------------------------------------------------------------------------------------------
    105           *                                       Local Functions
    106           * ------------------------------------------------------------------------------------------------
    107           */
    108          
    109          #pragma location="RAM_CODE_FLASH"
    110          #if defined HAL_OAD_BOOT_CODE
    111          static void HalFlashWriteTrigger(void);
    112          #else
    113          static __monitor void HalFlashWriteTrigger(void);
    114          #endif
    115          
    116          /**************************************************************************************************
    117           * @fn          HalFlashInit
    118           *
    119           * @brief       This function initializes the environment for this module.
    120           *
    121           * input parameters
    122           *
    123           * None.
    124           *
    125           * output parameters
    126           *
    127           * None.
    128           *
    129           * @return      None.
    130           **************************************************************************************************
    131           */
    132          void HalFlashInit(void)
    133          {
    134            // Load the code to run from RAM into its reserved area of RAM once at startup.
    135            HalFlashRead(PAGE_OF_RAM_CODE, OSET_OF_RAM_CODE, ramCode, SIZE_OF_RAM_CODE);
    136          }
    137          
    138          
    139          /**************************************************************************************************
    140           * @fn          HalFlashRead
    141           *
    142           * @brief       This function reads 'cnt' bytes from the internal flash.
    143           *
    144           * input parameters
    145           *
    146           * @param       pg - A valid flash page number.
    147           * @param       offset - A valid offset into the page.
    148           * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
    149           * @param       cnt - A valid number of bytes to read.
    150           *
    151           * output parameters
    152           *
    153           * None.
    154           *
    155           * @return      None.
    156           **************************************************************************************************
    157           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    158          void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
   \                     HalFlashRead:
    159          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   740B         MOV     A,#0xb
   \   000009   12....       LCALL   ?XSTACK_DISP0_8
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   FE           MOV     R6,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FF           MOV     R7,A
    160            // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
    161            uint8 *ptr = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
    162                         ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
   \   000011   740F         MOV     A,#0xf
   \   000013   55..         ANL     A,?V0 + 0
   \   000015   F5..         MOV     ?V0 + 2,A
   \   000017   75..00       MOV     ?V0 + 3,#0x0
   \   00001A   740B         MOV     A,#0xb
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?S_SHL
   \   000021   EA           MOV     A,R2
   \   000022   2400         ADD     A,#0x0
   \   000024   F8           MOV     R0,A
   \   000025   EB           MOV     A,R3
   \   000026   3480         ADDC    A,#-0x80
   \   000028   F9           MOV     R1,A
   \   000029   E8           MOV     A,R0
   \   00002A   2400         ADD     A,#0x0
   \   00002C   E9           MOV     A,R1
   \   00002D   35..         ADDC    A,?V0 + 3
   \   00002F   F9           MOV     R1,A
    163            uint8 memctr = MEMCTR;  // Save to restore.
   \   000030   E5C7         MOV     A,0xc7
   \   000032   F5..         MOV     ?V0 + 1,A
    164          
    165          #if !defined HAL_OAD_BOOT_CODE
    166            halIntState_t is;
    167          #endif
    168          
    169            pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
    170          
    171          #if !defined HAL_OAD_BOOT_CODE
    172            HAL_ENTER_CRITICAL_SECTION(is);
    173          #endif
    174          
    175            // Calculate and map the containing flash bank into XDATA.
    176            MEMCTR = (MEMCTR & 0xF8) | pg;
   \   000034   E5..         MOV     A,?V0 + 0
   \   000036   C4           SWAP    A
   \   000037   540F         ANL     A,#0xf
   \   000039   FA           MOV     R2,A
   \   00003A   E5C7         MOV     A,0xc7
   \   00003C   54F8         ANL     A,#0xf8
   \   00003E   4A           ORL     A,R2
   \   00003F   F5C7         MOV     0xc7,A
   \   000041   801C         SJMP    ??HalFlashRead_0
    177          
    178            while (cnt--)
    179            {
    180              *buf++ = *ptr++;
   \                     ??HalFlashRead_1:
   \   000043   8882         MOV     DPL,R0
   \   000045   8983         MOV     DPH,R1
   \   000047   E0           MOVX    A,@DPTR
   \   000048   8C82         MOV     DPL,R4
   \   00004A   8D83         MOV     DPH,R5
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   8882         MOV     DPL,R0
   \   00004F   8983         MOV     DPH,R1
   \   000051   A3           INC     DPTR
   \   000052   A882         MOV     R0,DPL
   \   000054   A983         MOV     R1,DPH
   \   000056   8C82         MOV     DPL,R4
   \   000058   8D83         MOV     DPH,R5
   \   00005A   A3           INC     DPTR
   \   00005B   AC82         MOV     R4,DPL
   \   00005D   AD83         MOV     R5,DPH
    181            }
   \                     ??HalFlashRead_0:
   \   00005F   EE           MOV     A,R6
   \   000060   FA           MOV     R2,A
   \   000061   EF           MOV     A,R7
   \   000062   FB           MOV     R3,A
   \   000063   EA           MOV     A,R2
   \   000064   24FF         ADD     A,#-0x1
   \   000066   1E           DEC     R6
   \   000067   EB           MOV     A,R3
   \   000068   34FF         ADDC    A,#-0x1
   \   00006A   FF           MOV     R7,A
   \   00006B   EA           MOV     A,R2
   \   00006C   4B           ORL     A,R3
   \   00006D   70D4         JNZ     ??HalFlashRead_1
    182          
    183            MEMCTR = memctr;
   \   00006F   85..C7       MOV     0xc7,?V0 + 1
    184          
    185          #if !defined HAL_OAD_BOOT_CODE
    186            HAL_EXIT_CRITICAL_SECTION(is);
    187          #endif
    188          }
   \   000072   7F04         MOV     R7,#0x4
   \   000074   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000077                REQUIRE MEMCTR
    189          
    190          /**************************************************************************************************
    191           * @fn          HalFlashWrite
    192           *
    193           * @brief       This function writes 'cnt' bytes to the internal flash.
    194           *
    195           * input parameters
    196           *
    197           * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
    198           * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
    199           * @param       cnt - Number of 4-byte blocks to write.
    200           *
    201           * output parameters
    202           *
    203           * None.
    204           *
    205           * @return      None.
    206           **************************************************************************************************
    207           */
    208           #if HAL_DMA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    209          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
   \                     HalFlashWrite:
    210          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V0 + 0,A
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 1,A
    211            halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
    212          
    213            HAL_DMA_SET_SOURCE(ch, buf);
   \   000011   ED           MOV     A,R5
   \   000012   90....       MOV     DPTR,#dmaCh0
   \   000015   F0           MOVX    @DPTR,A
   \   000016   EC           MOV     A,R4
   \   000017   A3           INC     DPTR
   \   000018   F0           MOVX    @DPTR,A
    214            HAL_DMA_SET_DEST(ch, &FWDATA);
   \   000019   A3           INC     DPTR
   \   00001A   7462         MOV     A,#0x62
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   \   00001E   7473         MOV     A,#0x73
   \   000020   F0           MOVX    @DPTR,A
    215            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   541F         ANL     A,#0x1f
   \   000025   F0           MOVX    @DPTR,A
    216            HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
   \   000026   E5..         MOV     A,?V0 + 0
   \   000028   33           RLC     A
   \   000029   33           RLC     A
   \   00002A   54FC         ANL     A,#0xfc
   \   00002C   A3           INC     DPTR
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   7406         MOV     A,#0x6
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?US_SHR
   \   000035   E5..         MOV     A,?V0 + 0
   \   000037   90....       MOV     DPTR,#dmaCh0 + 4
   \   00003A   F0           MOVX    @DPTR,A
    217            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    218            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    219            HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
   \   00003B   90....       MOV     DPTR,#dmaCh0 + 6
   \   00003E   7412         MOV     A,#0x12
   \   000040   F0           MOVX    @DPTR,A
    220            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
    221            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
    222            // The DMA is to be polled and shall not issue an IRQ upon completion.
    223            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
    224            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
    225            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
   \   000041   A3           INC     DPTR
   \   000042   7442         MOV     A,#0x42
   \   000044   F0           MOVX    @DPTR,A
    226            HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
   \   000045   53D1FE       ANL     0xd1,#0xfe
    227            HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
   \   000048   75D601       MOV     0xd6,#0x1
    228          
    229            FADDRL = (uint8)addr;
   \   00004B   EA           MOV     A,R2
   \   00004C   906271       MOV     DPTR,#0x6271
   \   00004F   F0           MOVX    @DPTR,A
    230            FADDRH = (uint8)(addr >> 8);
   \   000050   EB           MOV     A,R3
   \   000051   A3           INC     DPTR
   \   000052   F0           MOVX    @DPTR,A
    231            HalFlashWriteTrigger();
   \   000053                ; Setup parameters for call to function HalFlashWriteTrigger
   \   000053   12....       LCALL   ??HalFlashWriteTrigger
    232          }
   \   000056                REQUIRE ?Subroutine0
   \   000056                REQUIRE DMAIRQ
   \   000056                REQUIRE DMAARM
   \   000056                ; // Fall through to label ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?FUNC_LEAVE_XDATA
    233          #else
    234          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
    235          {
    236            return;
    237          }
    238           #endif
    239          
    240          /**************************************************************************************************
    241           * @fn          HalFlashErase
    242           *
    243           * @brief       This function erases the specified page of the internal flash.
    244           *
    245           * input parameters
    246           *
    247           * @param       pg - A valid flash page number to erase.
    248           *
    249           * output parameters
    250           *
    251           * None.
    252           *
    253           * @return      None.
    254           **************************************************************************************************
    255           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    256          void HalFlashErase(uint8 pg)
   \                     HalFlashErase:
    257          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    258            FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \   000004   E9           MOV     A,R1
   \   000005   C3           CLR     C
   \   000006   33           RLC     A
   \   000007   906272       MOV     DPTR,#0x6272
   \   00000A   F0           MOVX    @DPTR,A
    259            FCTL |= 0x01;
   \   00000B   906270       MOV     DPTR,#0x6270
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   D2E0         SETB    0xE0 /* A   */.0
   \   000011   F0           MOVX    @DPTR,A
    260          }
   \   000012   80..         SJMP    ?Subroutine1

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   22           RET
    261          
    262          /**************************************************************************************************
    263           * @fn          HalFlashWriteTrigger
    264           *
    265           * @brief       This function must be copied to RAM before running because it triggers and then
    266           *              awaits completion of Flash write, which can only be done from RAM.
    267           *
    268           * input parameters
    269           *
    270           * None.
    271           *
    272           * output parameters
    273           *
    274           * None.
    275           *
    276           * @return      None.
    277           **************************************************************************************************
    278           */
    279          #if defined HAL_OAD_BOOT_CODE
    280          #pragma optimize=medium

   \                                 In  segment RAM_CODE_FLASH, align 1, keep-with-next
    281          static void HalFlashWriteTrigger(void)
   \                     ??HalFlashWriteTrigger:
    282          #else
    283          static __monitor void HalFlashWriteTrigger(void)
    284          #endif
    285          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    286            MEMCTR |= 0x08;       // Start the Memory Arbiter running CODE from RAM.
   \   000004   43C708       ORL     0xc7,#0x8
    287            FCTL |= 0x02;         // Trigger the DMA writes.
   \   000007   906270       MOV     DPTR,#0x6270
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   D2E1         SETB    0xE0 /* A   */.1
   \   00000D   F0           MOVX    @DPTR,A
    288            while (FCTL & 0x80);  // Wait until writing is done.
   \                     ??HalFlashWriteTrigger_1:
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000011   40FB         JC      ??HalFlashWriteTrigger_1
    289            MEMCTR &= ~0x08;      // Stop the Memory Arbiter.
   \   000013   53C7F7       ANL     0xc7,#0xf7
    290          }
   \   000016   D083         POP     DPH
   \   000018   D082         POP     DPL
   \   00001A   22           RET
   \   00001B                REQUIRE MEMCTR
    291          
    292          /**************************************************************************************************
    293          */
C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_oad.c
      1          /**************************************************************************************************
      2            Filename:       _hal_oad.c
      3            Revised:        $Date: 2008-01-17 12:32:06 -0800 (Thu, 17 Jan 2008) $
      4            Revision:       $Revision: 16224 $
      5          
      6            Description:    This module contains optionally-compiled Boot Code to support OAD.
      7                            The rest of the functionality is the H/W specific drivers to read/write
      8                            the flash/NV containing the ACTIVE and the DOWNLOADED images.
      9            Notes:          This version targets the Texas Instruments CC2x3x family of processors.
     10          
     11          
     12            Copyright 2008-2009 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com.
     41          **************************************************************************************************/
     42          
     43          /* ------------------------------------------------------------------------------------------------
     44           *                                          Includes
     45           * ------------------------------------------------------------------------------------------------
     46           */
     47          #include <ioCC2530.h>
     48          #include "comdef.h"
     49          #include "hal_board_cfg.h"
     50          #include "hal_dma.h"
     51          #include "hal_flash.h"
     52          #include "hal_oad.h"
     53          #include "hal_types.h"
     54          //#include "stdio.h"
     55          //#include "hal_aes.h"
     56          
     57          /* ------------------------------------------------------------------------------------------------
     58           *                                           Macros
     59           * ------------------------------------------------------------------------------------------------
     60           */
     61          
     62          /* ------------------------------------------------------------------------------------------------
     63           *                                          Constants
     64           * ------------------------------------------------------------------------------------------------
     65           */
     66          
     67          /* ------------------------------------------------------------------------------------------------
     68           *                                          Typedefs
     69           * ------------------------------------------------------------------------------------------------
     70           */
     71          
     72          /* ------------------------------------------------------------------------------------------------
     73           *                                       Global Variables
     74           * ------------------------------------------------------------------------------------------------
     75           */
     76          
     77          /* ------------------------------------------------------------------------------------------------
     78           *                                       Global Functions
     79           * ------------------------------------------------------------------------------------------------
     80           */
     81          
     82          /* ------------------------------------------------------------------------------------------------
     83           *                                       Local Variables
     84           * ------------------------------------------------------------------------------------------------
     85           */
     86          
     87          #if HAL_OAD_BOOT_CODE

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     88          halDMADesc_t dmaCh0;
   \                     dmaCh0:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
     89          #endif
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                       Local Functions
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          
     96          static uint16 runPoly(uint16 crc, uint8 val);
     97          
     98          #define	 ucLDR_Security_F	(*(unsigned char *)0x100)	
     99          #define	 start_flag	(*(unsigned char *)0x101)	
    100          #define	 ucLDR_Ret	(*(unsigned char *)0x102)
    101          #define	 ucLDR_Message	(*(Uart_message *)0x110)
    102          #define	 stCommand	(*(union  u_stCommand *)0x1E0)	
    103          #define	 ucLDR_WorkRam	(*(unsigned char *)0x200)
    104          //#define 	 dmaCh0		(*(halDMADesc_t*)0x201)
    105          
    106          #define LED_1 P1_3
    107          #define LED_2 P1_4
    108          
    109          #define OAD_AES_VERI
    110          
    111          // _mode_ is one of
    112          #define CBC         0x00
    113          #define CFB         0x10
    114          #define OFB         0x20
    115          #define CTR         0x30
    116          #define ECB         0x40
    117          #define CBC_MAC     0x50
    118          
    119          #define AES_BUSY    0x08
    120          #define ENCRYPT     0x00
    121          #define DECRYPT     0x01
    122          
    123          // Macro for starting or stopping encryption or decryption
    124          #define AES_SET_ENCR_DECR_KEY_IV(mode) \
    125             do {                                \
    126              ENCCS = (ENCCS & ~0x07) | mode     \
    127             } while(0)
    128          
    129          // Where _mode_ is one of
    130          #define AES_ENCRYPT     0x00;
    131          #define AES_DECRYPT     0x02;
    132          #define AES_LOAD_KEY    0x04;
    133          #define AES_LOAD_IV     0x06;
    134          
    135          #define LENGTH_IV  16
    136          #define LENGTH_KEY 16
    137          
    138          #define STRING_LENGTH       16
    139          
    140          #define VALID_INIT_SN				(978137684)
    141          #define VALID_START_SN				(260636838)
    142          
    143          
    144          // Macro for setting the mode of the AES operation
    145          #define AES_SETMODE(mode) do { ENCCS &= ~0x70; ENCCS |= mode; } while (0)
    146          
    147          // Macro for starting the AES module for either encryption, decryption,
    148          // key or initialisation vector loading.
    149          #define AES_START()     ENCCS |= 0x01
    150          
    151          #define DELAY 0x0F
    152          
    153          typedef unsigned char       BOOL;
    154          
    155          // Data
    156          typedef unsigned char       BYTE;
    157          typedef unsigned short      WORD;
    158          typedef unsigned long       DWORD;
    159          
    160          // Unsigned numbers
    161          typedef unsigned char       UINT8;
    162          typedef unsigned short      UINT16;
    163          typedef unsigned long       UINT32;
    164          
    165          // Signed numbers
    166          typedef signed char         INT8;
    167          typedef signed short        INT16;
    168          typedef signed long         INT32;
    169          
    170          typedef volatile unsigned char XDATA macRam_t;
    171          #define TI_EXTADDR  PXREG( 0x780C )  /* Pointer to Start of Flash Information Page          */
    172          
    173          #if HAL_OAD_XNV_IS_SPI
    174          static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len);
    175          static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len);
    176          static unsigned char RcvData(void);
    177          static unsigned char Message_Rcv(void);
    178          static void Message_Send(void);
    179          static void SendData(char dat);
    180          static void delay(unsigned int de);
    181          static void MemReadRam(macRam_t * pRam, uint8 * pData, uint8 len);
    182          static uint8 OAD_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len );
    183          static void putsDialog(const char *str);
    184          //static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr);
    185          //static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key);
    186          #ifdef OAD_AES_VERI
    187          static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key);
    188          static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr);
    189          #endif
    190          
    191          #endif
    192          
    193          #if 0
    194          const uint8 crcTest[] = {
    195          0x02,0x1C,0x0E,0x02,0x11,0xE2,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    196          0xFF,0xFF,0xFF,0x02,0x12,0xA8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    197          0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x2B,0xD2,0xFF,0xFF,
    198          0xFF,0xFF,0xFF,0x02,0x11,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x12,0xFD,0xFF,0xFF,
    199          0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x19,0x07,0xFF,0xFF,
    200          0xFF,0xFF,0xFF,0x02,0x11,0x22,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x19,0x16,0xFF,0xFF,
    201          0xFF,0xFF,0xFF,0x02,0x19,0x22,0xFF,0xFF,0xFF,0xFF,0xFF,0x02,0x2B,0x5B,0xFF,0xFF,
    202          0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    203          0xFF,0xFF,0xFF,0x02,0x11,0x70,0xFF,0xFF,0x00,0xF0,0x44,0x7B,0x0F,0xFE,0x00,0x8F,
    204          0x01,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,
    205          0x00,0x05,0x00,0x0A,0x00,0x14,0x00,0x28,0x00,0x4F,0x00,0x9E,0x00,0x00,0x00,0x59,
    206          0x21,0x59,0x21,0x59,0x21,0x2D,0x20,0x27,0x20,0x59,0x21,0x67,0x2C,0x00,0x00,0x00,
    207          0x00,0x2B,0x2D,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x0C,0x00,0x9C,0x04,0xFF,
    208          0x01,0x64,0x00,0x02,0x02,0x02,0x07,0x1E,0x02,0x05,0x1E,0x02,0x0A,0x03,0xB8,0x0B,
    209          0x02,0xF0,0xFF,0x02,0x01,0x17,0x00,0xFF,0x47,0x75,0x30,0x60,0x04,0x01,0xA0,0x04,
    210          0x01,0xA0,0x04,0x01,0xA0,0x04,0x01,0x00,0x00,0x01,0x00,0x00,0x0F,0x00,0xFF,0x48
    211          };
    212          #endif
    213          
    214          #if HAL_OAD_BOOT_CODE
    215          static void dl2rc(void);
    216          static uint16 crcCalc(void);
    217          static void InitUart(void);
    218          //static void Uart_Send_String(char *Data,int len);
    219          #endif
    220          
    221          #ifdef _FORMAT_PRINT_
    222          static int Printf(const char *fmt, ...);
    223          #endif
    224          
    225          /**************************************************************************************************
    226           * @fn          main
    227           *
    228           * @brief       ISR for the reset vector.
    229           *
    230           * input parameters
    231           *
    232           * None.
    233           *
    234           * output parameters
    235           *
    236           * None.
    237           *
    238           * @return      None.
    239           **************************************************************************************************
    240           */
    241           
    242          //#pragma location="RAM_CODE_XDATA"
    243          
    244          //unsigned char ucLDR_Security_F;
    245          //unsigned char start_flag;
    246          //unsigned char ucLDR_Ret;
    247          //Uart_message ucLDR_Message;
    248          //unsigned char ucLDR_WorkRam;
    249          
    250           //char *g_decKey = "WorkForYourDream";
    251           //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    252          #pragma location="NEAR_CODE"
    253          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    254          void main(void)
   \                     main:
    255          {
   \   000000                ; Auto size: 20
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?ALLOC_XSTACK8
    256            uint16 crc[2];
    257            uint8 veriBuf[16];
    258            //uint8 g_extAddr[8] = {0x38,0x15,0xC6,0xFE,0xFF,0x17,0x87,0x88};
    259           // uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;
    260           uint16 seriAddr = HAL_OAD_CODE_START/HAL_FLASH_WORD_SIZE;
   \   000005   7E00         MOV     R6,#0x0
   \   000007   7F08         MOV     R7,#0x8
    261            uint16 oset;
    262            //uint8 page=HAL_OAD_CODE_START/HAL_FLASH_PAGE_SIZE;
    263            uint8 page=HAL_OAD_RC_START/HAL_FLASH_PAGE_SIZE;
    264            char *decKey = "WorkForYourDream";
    265            uint32 *pVeriFlag;
    266            //preamble_t *tstPre;
    267            //uint8 test[12] = {0X0F,0XFE,0XAA,0XBB,0XCC,0XDD,0X00,0X03,0X00,0X03,0X00,0X03};
    268            //uint8 page=HAL_OAD_RC_START/HAL_FLASH_PAGE_SIZE;
    269            //uint8 buf[16];
    270           // char *g_decKey = "WorkForYourDream";
    271           //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    272            //uint8 buf[8] = {0};  
    273          
    274            HAL_BOARD_INIT();
   \   000009   53BEFB       ANL     0xbe,#0xfb
   \                     ??main_0:
   \   00000C   E59D         MOV     A,0x9d
   \   00000E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000010   50FA         JNC     ??main_0
   \   000012   00           NOP
   \   000013   78F8         MOV     R0,#-0x8
   \   000015   7901         MOV     R1,#0x1
   \                     ??main_1:
   \   000017   00           NOP
   \   000018   E8           MOV     A,R0
   \   000019   24FF         ADD     A,#-0x1
   \   00001B   18           DEC     R0
   \   00001C   E9           MOV     A,R1
   \   00001D   34FF         ADDC    A,#-0x1
   \   00001F   F9           MOV     R1,A
   \   000020   E8           MOV     A,R0
   \   000021   49           ORL     A,R1
   \   000022   70F3         JNZ     ??main_1
   \   000024   75C680       MOV     0xc6,#-0x80
   \                     ??main_2:
   \   000027   7480         MOV     A,#-0x80
   \   000029   659E         XRL     A,0x9e
   \   00002B   70FA         JNZ     ??main_2
   \   00002D   43BE04       ORL     0xbe,#0x4
   \   000030   906270       MOV     DPTR,#0x6270
   \   000033   EF           MOV     A,R7
   \   000034   F0           MOVX    @DPTR,A
   \   000035   43FE02       ORL     0xfe,#0x2
   \   000038   43FD01       ORL     0xfd,#0x1
    275          #if HAL_OAD_XNV_IS_SPI
    276            //XNV_SPI_INIT(); 
    277          #endif
    278            /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
    279             * descriptors in addition to just Channel 0.
    280             */
    281            HAL_DMA_SET_ADDR_DESC0( &dmaCh0 );
                   ^
Warning[Pe069]: integer conversion resulted in truncation
   \   00003B   74..         MOV     A,#(dmaCh0 >> 8) & 0xff
   \   00003D   F5D5         MOV     0xd5,A
   \   00003F   75D4..       MOV     0xd4,#dmaCh0 & 0xff
    282            HalFlashInit();
   \   000042                ; Setup parameters for call to function HalFlashRead
   \   000042   75..1D       MOV     ?V0 + 0,#0x1d
   \   000045   8E..         MOV     ?V0 + 1,R6
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004C   7C..         MOV     R4,#??ramCode & 0xff
   \   00004E   7D..         MOV     R5,#(??ramCode >> 8) & 0xff
   \   000050   7AE3         MOV     R2,#-0x1d
   \   000052   7B07         MOV     R3,#0x7
   \   000054   7900         MOV     R1,#0x0
   \   000056   12....       LCALL   HalFlashRead
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
    283          
    284          #if 0
    285            HalFlashRead(HAL_OAD_CRC_ADDR / HAL_FLASH_PAGE_SIZE,
    286                         HAL_OAD_CRC_ADDR % HAL_FLASH_PAGE_SIZE,
    287                         (uint8 *)crc, sizeof(crc));
    288          
    289          
    290            if (crc[0] != crc[1])
    291            {
    292              // If the CRC is erased or the RC code fails a sanity check, instantiate the DL code (again).
    293              if ((crc[0] == 0) || (crc[0] != crcCalc()))
    294              {
    295                dl2rc();
    296          
    297                /* If dl2rc() fails, a flawed image is allowed to run - 
    298                 * maybe the damage is not fatal to OTA ops?
    299                 */
    300              }
    301              else
    302              {
    303                crc[1] = crc[0];
    304                HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
    305              }
    306            }
    307          #endif
    308          
    309            //InitUart();
    310            //Uart_Send_String("boot",4);
    311            
    312            //P1DIR &=( ~0x04);
    313            //P1DIR |= 0x08;				//P1_3
    314            //P1DIR |= 0x08;
    315            //P1DIR |= 0x10;
    316            //P1DIR |= 0x18;
    317            //P1_3 = 0;
    318            //P1_4 = 0;
    319            P0SEL &= ~0x30;
   \   00005E   53F3CF       ANL     0xf3,#0xcf
    320            P0DIR &= 0xDF;
   \   000061   53FDDF       ANL     0xfd,#0xdf
    321            //P0DIR |= 0x11;
    322            P0DIR |= 0x10;
   \   000064   43FD10       ORL     0xfd,#0x10
    323            P0DIR |= 0x80;
   \   000067   43FD80       ORL     0xfd,#0x80
    324            //P1DIR |= 0x82;
    325            P0_4 = 0;
   \   00006A   C284         CLR     0x80.4
    326            P1_7 = 1;
   \   00006C   D297         SETB    0x90.7
    327            //P1_0 = 0;
    328            //P1_1 = 0;//led
    329            //P0_0 = 0;//led
    330            //P0 &= ~0x20;
    331            //P0DIR |= 0x10;
    332            //P0_4 = 1;
    333            //P1DIR |= 0x80;
    334            //P0DIR |= 0x20;					//P05
    335            InitUart();
   \   00006E   53F1FE       ANL     0xf1,#0xfe
   \   000071   43F30C       ORL     0xf3,#0xc
   \   000074   438680       ORL     0x86,#0x80
   \   000077   75C50B       MOV     0xc5,#0xb
   \   00007A   75C2D8       MOV     0xc2,#-0x28
   \   00007D   C2E9         CLR     0xe8.1
   \   00007F   438640       ORL     0x86,#0x40
   \   000082   C28B         CLR     0x88.3
    336          #ifdef OAD_AES_VERI
    337            AES_SETMODE(ECB);
   \   000084   53B38F       ANL     0xb3,#0x8f
   \   000087   43B340       ORL     0xb3,#0x40
    338          #endif
    339          
    340            HAL_TURN_OFF_LED2();
   \   00008A   D280         SETB    0x80.0
    341            HAL_TURN_OFF_LED1();
   \   00008C   C291         CLR     0x90.1
    342            
    343          #ifdef OAD_AES_VERI
    344            halAesLoadKeyOrInitVector(decKey, TRUE);
                                             ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "BYTE *"

    uint16 oset;
           ^
"C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_oad.c",261  Warning[Pe177]: 
          variable "oset" was declared but never referenced

    uint8 page=HAL_OAD_RC_START/HAL_FLASH_PAGE_SIZE;
          ^
"C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_oad.c",263  Warning[Pe177]: 
          variable "page" was declared but never referenced
   \   00008E   E5B3         MOV     A,0xb3
   \   000090   54F8         ANL     A,#0xf8
   \   000092   4404         ORL     A,#0x4
   \   000094   F5B3         MOV     0xb3,A
   \   000096   43B301       ORL     0xb3,#0x1
   \   000099   7800         MOV     R0,#0x0
   \                     ??main_3:
   \   00009B   88..         MOV     ?V0 + 0,R0
   \   00009D   74..         MOV     A,#`?<Constant "WorkForYourDream">` & 0xff
   \   00009F   25..         ADD     A,?V0 + 0
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   74..         MOV     A,#(`?<Constant "WorkForYourDream">` >> 8) & 0xff
   \   0000A5   3400         ADDC    A,#0x0
   \   0000A7   F583         MOV     DPH,A
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F5B1         MOV     0xb1,A
   \   0000AC   08           INC     R0
   \   0000AD   E8           MOV     A,R0
   \   0000AE   C3           CLR     C
   \   0000AF   9410         SUBB    A,#0x10
   \   0000B1   40E8         JC      ??main_3
    345            
    346            HalFlashRead(CPUID_VERI_ADDR / HAL_FLASH_PAGE_SIZE,
    347                         CPUID_VERI_ADDR % HAL_FLASH_PAGE_SIZE,
    348                         veriBuf, sizeof(veriBuf));
   \   0000B3                ; Setup parameters for call to function HalFlashRead
   \   0000B3   75..10       MOV     ?V0 + 0,#0x10
   \   0000B6   78..         MOV     R0,#?V0 + 0
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BB   7406         MOV     A,#0x6
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   AC82         MOV     R4,DPL
   \   0000C2   AD83         MOV     R5,DPH
   \   0000C4   7AF0         MOV     R2,#-0x10
   \   0000C6   7B07         MOV     R3,#0x7
   \   0000C8   7903         MOV     R1,#0x3
   \   0000CA   12....       LCALL   HalFlashRead
   \   0000CD   7402         MOV     A,#0x2
   \   0000CF   12....       LCALL   ?DEALLOC_XSTACK8
    349          
    350            halAesEncrDecr((BYTE *)veriBuf, CPUID_VERI_LEN, (BYTE *)veriBuf/*, ucLDR_Message.com_data*/, DECRYPT); 
   \   0000D2                ; Setup parameters for call to function halAesEncrDecr
   \   0000D2   8582..       MOV     ?V0 + 0,DPL
   \   0000D5   8583..       MOV     ?V0 + 1,DPH
   \   0000D8   78..         MOV     R0,#?V0 + 0
   \   0000DA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DD   7901         MOV     R1,#0x1
   \   0000DF   7C10         MOV     R4,#0x10
   \   0000E1   7D00         MOV     R5,#0x0
   \   0000E3   7406         MOV     A,#0x6
   \   0000E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E8   AA82         MOV     R2,DPL
   \   0000EA   AB83         MOV     R3,DPH
   \   0000EC   12....       LCALL   ??halAesEncrDecr
   \   0000EF   7402         MOV     A,#0x2
   \   0000F1   12....       LCALL   ?DEALLOC_XSTACK8
    351            
    352            pVeriFlag = (uint32*)veriBuf;
    353            if(VALID_INIT_SN==*pVeriFlag)
   \   0000F4   C082         PUSH    DPL
   \   0000F6   C083         PUSH    DPH
   \   0000F8   90....       MOV     DPTR,#__Constant_3a4d3254
   \   0000FB   78..         MOV     R0,#?V0 + 0
   \   0000FD   12....       LCALL   ?L_MOV_X
   \   000100   D083         POP     DPH
   \   000102   D082         POP     DPL
   \   000104   78..         MOV     R0,#?V0 + 0
   \   000106   12....       LCALL   ?L_EQ_X
   \   000109   6003         JZ      $+5
   \   00010B   02....       LJMP    ??main_4
    354            {
    355            	putsDialog("Initial\r\n");
   \   00010E                ; Setup parameters for call to function putsDialog
   \   00010E   7A..         MOV     R2,#`?<Constant "Initial\\r\\n">` & 0xff
   \   000110   7B..         MOV     R3,#(`?<Constant "Initial\\r\\n">` >> 8) & 0xff
   \   000112   12....       LCALL   ??putsDialog
    356          
    357          	
    358          	//2015/09/13 what's wrong
    359          	//dl2rc();
    360          	//HalFlashErase(HAL_OAD_RC_START / HAL_FLASH_PAGE_SIZE );
    361          	//HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);		//²»ÄÜÅúÁ¿ÉÕÂ¼
    362          	
    363            	*pVeriFlag = VALID_START_SN;						//first start 
   \   000115   90....       MOV     DPTR,#__Constant_f8900a6
   \   000118   12....       LCALL   ?XLOAD_R2345
   \   00011B   7404         MOV     A,#0x4
   \   00011D   12....       LCALL   ?XSTACK_DISP0_8
   \   000120   12....       LCALL   ?XSTORE_R2345
    364            	MemReadRam((macRam_t *)TI_EXTADDR, (veriBuf+4), 8);
   \   000123                ; Setup parameters for call to function MemReadRam
   \   000123   7908         MOV     R1,#0x8
   \   000125   E9           MOV     A,R1
   \   000126   12....       LCALL   ?XSTACK_DISP0_8
   \   000129   AC82         MOV     R4,DPL
   \   00012B   AD83         MOV     R5,DPH
   \   00012D   7A0C         MOV     R2,#0xc
   \   00012F   7B78         MOV     R3,#0x78
   \   000131   12....       LCALL   ??MemReadRam
    365          	halAesEncrDecr((BYTE *)veriBuf, CPUID_VERI_LEN, (BYTE *)veriBuf/*, ucLDR_Message.com_data*/, ENCRYPT); 
   \   000134                ; Setup parameters for call to function halAesEncrDecr
   \   000134   7404         MOV     A,#0x4
   \   000136   12....       LCALL   ?XSTACK_DISP0_8
   \   000139   8582..       MOV     ?V0 + 0,DPL
   \   00013C   8583..       MOV     ?V0 + 1,DPH
   \   00013F   78..         MOV     R0,#?V0 + 0
   \   000141   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000144   7900         MOV     R1,#0x0
   \   000146   7C10         MOV     R4,#0x10
   \   000148   7D00         MOV     R5,#0x0
   \   00014A   7406         MOV     A,#0x6
   \   00014C   12....       LCALL   ?XSTACK_DISP0_8
   \   00014F   AA82         MOV     R2,DPL
   \   000151   AB83         MOV     R3,DPH
   \   000153   12....       LCALL   ??halAesEncrDecr
   \   000156   7402         MOV     A,#0x2
   \   000158   12....       LCALL   ?DEALLOC_XSTACK8
    366          	HalFlashErase(CPUID_VERI_ADDR / HAL_FLASH_PAGE_SIZE);
   \   00015B                ; Setup parameters for call to function HalFlashErase
   \   00015B   7903         MOV     R1,#0x3
   \   00015D   12....       LCALL   HalFlashErase
    367          	HalFlashWrite((CPUID_VERI_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)veriBuf, CPUID_VERI_LEN/4);	
   \   000160                ; Setup parameters for call to function HalFlashWrite
   \   000160   75..04       MOV     ?V0 + 0,#0x4
   \   000163   8E..         MOV     ?V0 + 1,R6
   \   000165   78..         MOV     R0,#?V0 + 0
   \   000167   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016A   7406         MOV     A,#0x6
   \   00016C   12....       LCALL   ?XSTACK_DISP0_8
   \   00016F   AC82         MOV     R4,DPL
   \   000171   AD83         MOV     R5,DPH
   \   000173   7AFC         MOV     R2,#-0x4
   \   000175   7B07         MOV     R3,#0x7
   \   000177   12....       LCALL   HalFlashWrite
   \   00017A   7402         MOV     A,#0x2
   \   00017C   12....       LCALL   ?DEALLOC_XSTACK8
    368            }else if(VALID_START_SN==*pVeriFlag)
    369            {
    370            	MemReadRam((macRam_t *)TI_EXTADDR, (veriBuf+12), 8);		//read mac iD
    371          	if(FALSE==OAD_memcmp((veriBuf+4), (veriBuf+12), 8))
    372          	{
    373          		putsDialog("Verified Error");
    374          		while(1);
    375          		//asm("LJMP 0x1000\n");
    376          	}
    377          	putsDialog("Start\r\n");
    378            }else
    379            {
    380            	putsDialog("Verified Error");
    381          	while(1);
    382            }
    383          #endif
    384           //tstPre = (preamble_t*)test;
    385            //SendData(tstPre->len>>24);
    386           // SendData(tstPre->len>>16);
    387            //SendData(tstPre->len>>8);
    388            //SendData(tstPre->len);
    389          
    390            //HalFlashWrite((HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE), (uint8 *)crcTest, sizeof(crcTest)/4);
    391            
    392           //if(!P1_2)
    393            if(!P0_5)
   \                     ??main_5:
   \   00017F   A285         MOV     C,0x80.5
   \   000181   4003         JC      $+5
   \   000183   02....       LJMP    ??main_6
    394            {
    395          
    396          	//Uart_Send_String("boot",4);
    397          	//putsDialog("boot\r\n");
    398                  //P1DIR |= 0x18;
    399                  //P1_4 = 0;
    400          	
    401          	while(1)
    402          	{
    403          		if(Message_Rcv())
    404          		{	
    405          			//P1_3 = !P1_3;
    406          			ucLDR_Security_F = 0;
    407          			ucLDR_Ret = 0x00;
    408          			//Uart_Send_String("rcv",3);
    409          #if 1
    410          			switch(ucLDR_Message.protocol_command )
    411          			{
    412          
    413          				case AM1_IAP_READ_64BYTE:
    414          #if 0
    415          					//P1_3 = !P1_3;
    416                                             //     P1_4 = !P1_4;
    417          				  	for (oset = 0; oset < HAL_FLASH_PAGE_SIZE; oset += 64)
    418          				  	{
    419          						HalFlashRead(page,oset,ucLDR_Message.com_data,64);
    420          						ucLDR_Message.data_length=64;
    421          						Message_Send();		
    422          						//Uart_Send_String(buf,4);
    423          					
    424          				  	}
    425          					page++;
    426          #endif
    427          				break;
    428          /*
    429          				case BOOT_FIRMWARE_VERSION:
    430          					ucLDR_Message.com_data[0]=1;
    431          					ucLDR_Message.com_data[1]=0;      
    432          					ucLDR_Message.com_data[12]=5;	//for AM1_IAP
    433          					ucLDR_Message.data_length=20;
    434          					Message_Send();
    435          					break;
    436          					
    437          				case AM1_IAP_READ_64BYTE:
    438          					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
    439          					stCommand.Program_Lib.dst_adr	+= 64;
    440          					if( stCommand.Program_Lib.dst_adr == 0x00 )
    441          					stCommand.Program_Lib.dst_bank++;	
    442          					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
    443          					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
    444          					ucLDR_Read_64Byte_Ram();
    445          					ucLDR_Message.data_length=64;
    446          					Message_Send();
    447          					break;
    448          
    449          						
    450          				case AM1_IAP_READ_STATUS:
    451          					stCommand.ReadStatus_Lib.ram_adr = (unsigned char*)&ucLDR_WorkRam;
    452          					ucLDR_Ret=0;//test
    453          					ucLDR_ReadStatus_Ram();//test
    454          					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
    455          					ucLDR_Message.data_length=2;
    456          					Message_Send();
    457          					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
    458          					stCommand.Program_Lib.dst_bank	= 0;	
    459          					break;
    460          
    461          					  
    462          				case AM1_IAP_SECURITYCHECK:
    463          		 			stCommand.Security_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam;
    464          			 		stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
    465          					ucLDR_Ret = 0x00;
    466          					ucLDR_SecurityCheck_Ram();
    467          					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
    468          					ucLDR_Message.data_length=2;		
    469          					Message_Send();
    470          					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
    471          					stCommand.Program_Lib.dst_bank	= 0;	
    472          				      break;
    473          */
    474          						
    475          	//=================================================================================
    476          				case AM1_IAP_WRITE_PAGE:	
    477          /*
    478          					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
    479          					stCommand.Program_Lib.dst_adr	+= 64;
    480          					if( stCommand.Program_Lib.dst_adr == 0x00 )
    481          					stCommand.Program_Lib.dst_bank++;	
    482          					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
    483          					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
    484          					ucLDR_Ret=0x00;//test	
    485          					ucLDR_Program_Ram();//test
    486          */
    487          					halAesEncrDecr((BYTE *)ucLDR_Message.com_data, STRING_LENGTH, (BYTE *)ucLDR_Message.com_data/*, ucLDR_Message.com_data*/, DECRYPT);
    488          					//Uart_Send_String((BYTE *)buf,16);
    489          					if ((seriAddr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
    490          					{
    491          						HalFlashErase(seriAddr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
    492          					}
    493          					//HalFlashWrite(addr++, ucLDR_Message.com_data, 1);
    494          					HalFlashWrite(seriAddr, ucLDR_Message.com_data, ucLDR_Message.data_length/4);
    495          					seriAddr+=(ucLDR_Message.data_length/4);
    496          					delay(1000);
    497          				    //ucLDR_Read_64Byte_Ram();
    498          					ucLDR_Message.com_data[0]=0x00;
    499          					ucLDR_Message.data_length=2;
    500          					Message_Send();					
    501          					break;
    502          
    503          				case AM1_IAP_ERASE_DEVICE:
    504          					ucLDR_Message.com_data[0]=0x55;
    505          					ucLDR_Message.com_data[1]=0x00;
    506          					ucLDR_Message.data_length=3;
    507          					Message_Send();	
    508          				break;
    509          	//=================================================================================
    510          /*
    511          				case AM1_IAP_ERASE_DEVICE:		
    512          					ucLDR_Security_F = 0;
    513          					stCommand.ReadStatus_Lib.ram_adr = &ucLDR_WorkRam;
    514          					ucLDR_Ret=0;//test
    515          					ucLDR_ReadStatus_Ram();//test
    516          					if( (ucLDR_Ret&0x01) == 0x01 )
    517          						{
    518          						ucLDR_Message.com_data[0]=0x55;// No Key	
    519          						ucLDR_Security_F=1;
    520          					     }
    521          					else
    522          						{
    523          						ucLDR_Ret = 0x00;
    524          			 			stCommand.Security_Lib.ram_adr	= &ucLDR_WorkRam;
    525          			 			stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
    526          						ucLDR_SecurityCheck_Ram();
    527          						if( ucLDR_Ret != 0x00 )
    528          							{
    529          							ucLDR_Message.com_data[0]=0xEE;   //Key Verify error
    530          			
    531          							}
    532          						else
    533          							{
    534          							 ucLDR_Message.com_data[0]=0xaa ;//Key Verify Pass
    535          		                                 ucLDR_Security_F=1;
    536          						       }
    537          						}
    538          
    539          						 if(ucLDR_Security_F==1)
    540          							{
    541          								stCommand.Erase_Lib.ram_adr	= &ucLDR_WorkRam;
    542          								ucLDR_Ret=0x00;//test
    543          								ucLDR_Erase_Ram();//test
    544          								ucLDR_Message.com_data[1]= ucLDR_Ret;
    545          								#if 0
    546          								if(ucLDR_Ret==0)
    547          								{
    548          								stCommand.Secter_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam[0];
    549          								ucLDR_Ret=0x00;//test
    550          								ucLDR_BankCheck_Ram();  //test 
    551          								ucLDR_Message.com_data[2]=ucLDR_Ret;
    552          								}
    553          								#endif
    554          							}
    555          					delay(60000);		
    556          					stCommand.Program_Lib.dst_adr	= (unsigned char*)(0x4000-64);	   
    557          					stCommand.Program_Lib.dst_bank	= 0;
    558          					Message_Send();	
    559          					break;
    560          */
    561          //=================================================================================
    562          				  default:
    563          					//Message_Send();		
    564          					break;
    565          				}
    566          #endif
    567          		}
    568          		//start_flag = 0;
    569          		//InitUart();
    570          		//Uart_Send_String("test",4);
    571          		//P1_3 = !P1_3;
    572          
    573          	}
    574            }else
    575            {
    576          
    577          #if 1
    578            	HalFlashRead(HAL_OAD_CRC_ADDR / HAL_FLASH_PAGE_SIZE,
    579                         HAL_OAD_CRC_ADDR % HAL_FLASH_PAGE_SIZE,
    580                         (uint8 *)crc, sizeof(crc));
   \   000186                ; Setup parameters for call to function HalFlashRead
   \   000186   75..04       MOV     ?V0 + 0,#0x4
   \   000189   8E..         MOV     ?V0 + 1,R6
   \   00018B   78..         MOV     R0,#?V0 + 0
   \   00018D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000190   7402         MOV     A,#0x2
   \   000192   12....       LCALL   ?XSTACK_DISP0_8
   \   000195   AC82         MOV     R4,DPL
   \   000197   AD83         MOV     R5,DPH
   \   000199   7A88         MOV     R2,#-0x78
   \   00019B   7B00         MOV     R3,#0x0
   \   00019D   7940         MOV     R1,#0x40
   \   00019F   12....       LCALL   HalFlashRead
   \   0001A2   7402         MOV     A,#0x2
   \   0001A4   12....       LCALL   ?DEALLOC_XSTACK8
    581          
    582          	if (crc[0] != crc[1])
   \   0001A7   7402         MOV     A,#0x2
   \   0001A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   FE           MOV     R6,A
   \   0001AE   A3           INC     DPTR
   \   0001AF   E0           MOVX    A,@DPTR
   \   0001B0   FF           MOV     R7,A
   \   0001B1   85..82       MOV     DPL,?XSP + 0
   \   0001B4   85..83       MOV     DPH,?XSP + 1
   \   0001B7   E0           MOVX    A,@DPTR
   \   0001B8   6E           XRL     A,R6
   \   0001B9   7003         JNZ     ??main_7
   \   0001BB   A3           INC     DPTR
   \   0001BC   E0           MOVX    A,@DPTR
   \   0001BD   6F           XRL     A,R7
   \                     ??main_7:
   \   0001BE   7003         JNZ     $+5
   \   0001C0   02....       LJMP    ??main_8
    583          	{
    584          		SendData(crc[1]>>8);
   \   0001C3                ; Setup parameters for call to function SendData
   \   0001C3   EF           MOV     A,R7
   \   0001C4   F9           MOV     R1,A
   \   0001C5   12....       LCALL   ??SendData
    585          		SendData(crc[1]&0xFF);
   \   0001C8                ; Setup parameters for call to function SendData
   \   0001C8   EE           MOV     A,R6
   \   0001C9   F9           MOV     R1,A
   \   0001CA   12....       LCALL   ??SendData
    586          		if( crc[1]== crcCalc())
   \   0001CD                ; Setup parameters for call to function crcCalc
   \   0001CD   12....       LCALL   ??crcCalc
   \   0001D0   7402         MOV     A,#0x2
   \   0001D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D5   E0           MOVX    A,@DPTR
   \   0001D6   F8           MOV     R0,A
   \   0001D7   A3           INC     DPTR
   \   0001D8   E0           MOVX    A,@DPTR
   \   0001D9   F9           MOV     R1,A
   \   0001DA   EA           MOV     A,R2
   \   0001DB   68           XRL     A,R0
   \   0001DC   7002         JNZ     ??main_9
   \   0001DE   EB           MOV     A,R3
   \   0001DF   69           XRL     A,R1
   \                     ??main_9:
   \   0001E0   6003         JZ      $+5
   \   0001E2   02....       LJMP    ??main_10
    587          		{
    588          			//putsDialog("CRC OK\r\n");
    589          			dl2rc();
   \   0001E5                ; Setup parameters for call to function dl2rc
   \   0001E5   12....       LCALL   ??dl2rc
    590          			//putsDialog("FW OK\r\n");
    591          			crc[0] = crc[1];
   \   0001E8   7402         MOV     A,#0x2
   \   0001EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001ED   E0           MOVX    A,@DPTR
   \   0001EE   F8           MOV     R0,A
   \   0001EF   A3           INC     DPTR
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   F9           MOV     R1,A
   \   0001F2   02....       LJMP    ??main_10
    592          			//HalFlashErase(HAL_OAD_RC_START / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
    593          			//HalFlashErase(HAL_OAD_RC_START / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
    594          			HalFlashErase(HAL_OAD_RC_START / HAL_FLASH_PAGE_SIZE );
    595          			HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
    596          		}else
   \                     ??main_4:
   \   0001F5   7404         MOV     A,#0x4
   \   0001F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FA   C082         PUSH    DPL
   \   0001FC   C083         PUSH    DPH
   \   0001FE   90....       MOV     DPTR,#__Constant_f8900a6
   \   000201   78..         MOV     R0,#?V0 + 0
   \   000203   12....       LCALL   ?L_MOV_X
   \   000206   D083         POP     DPH
   \   000208   D082         POP     DPL
   \   00020A   78..         MOV     R0,#?V0 + 0
   \   00020C   12....       LCALL   ?L_EQ_X
   \   00020F   7078         JNZ     ??main_11
   \   000211                ; Setup parameters for call to function MemReadRam
   \   000211   7908         MOV     R1,#0x8
   \   000213   7410         MOV     A,#0x10
   \   000215   12....       LCALL   ?XSTACK_DISP0_8
   \   000218   AC82         MOV     R4,DPL
   \   00021A   AD83         MOV     R5,DPH
   \   00021C   7A0C         MOV     R2,#0xc
   \   00021E   7B78         MOV     R3,#0x78
   \   000220   12....       LCALL   ??MemReadRam
   \   000223   8F..         MOV     ?V0 + 2,R7
   \   000225   8E..         MOV     ?V0 + 3,R6
   \   000227   EF           MOV     A,R7
   \   000228   12....       LCALL   ?XSTACK_DISP0_8
   \   00022B   AA82         MOV     R2,DPL
   \   00022D   AB83         MOV     R3,DPH
   \   00022F   7410         MOV     A,#0x10
   \   000231   12....       LCALL   ?XSTACK_DISP0_8
   \   000234   A882         MOV     R0,DPL
   \   000236   A983         MOV     R1,DPH
   \                     ??main_12:
   \   000238   AC..         MOV     R4,?V0 + 2
   \   00023A   AD..         MOV     R5,?V0 + 3
   \   00023C   EC           MOV     A,R4
   \   00023D   24FF         ADD     A,#-0x1
   \   00023F   F5..         MOV     ?V0 + 2,A
   \   000241   ED           MOV     A,R5
   \   000242   34FF         ADDC    A,#-0x1
   \   000244   F5..         MOV     ?V0 + 3,A
   \   000246   EC           MOV     A,R4
   \   000247   4D           ORL     A,R5
   \   000248   6035         JZ      ??main_13
   \   00024A   EA           MOV     A,R2
   \   00024B   FC           MOV     R4,A
   \   00024C   EB           MOV     A,R3
   \   00024D   FD           MOV     R5,A
   \   00024E   8C82         MOV     DPL,R4
   \   000250   8D83         MOV     DPH,R5
   \   000252   A3           INC     DPTR
   \   000253   AA82         MOV     R2,DPL
   \   000255   AB83         MOV     R3,DPH
   \   000257   88..         MOV     ?V0 + 0,R0
   \   000259   89..         MOV     ?V0 + 1,R1
   \   00025B   85..82       MOV     DPL,?V0 + 0
   \   00025E   85..83       MOV     DPH,?V0 + 1
   \   000261   A3           INC     DPTR
   \   000262   A882         MOV     R0,DPL
   \   000264   A983         MOV     R1,DPH
   \   000266   8C82         MOV     DPL,R4
   \   000268   8D83         MOV     DPH,R5
   \   00026A   E0           MOVX    A,@DPTR
   \   00026B   FC           MOV     R4,A
   \   00026C   85..82       MOV     DPL,?V0 + 0
   \   00026F   85..83       MOV     DPH,?V0 + 1
   \   000272   E0           MOVX    A,@DPTR
   \   000273   6C           XRL     A,R4
   \   000274   60C2         JZ      ??main_12
   \   000276                ; Setup parameters for call to function putsDialog
   \   000276   7A..         MOV     R2,#`?<Constant "Verified Error">` & 0xff
   \   000278   7B..         MOV     R3,#(`?<Constant "Verified Error">` >> 8) & 0xff
   \   00027A   12....       LCALL   ??putsDialog
   \                     ??main_14:
   \   00027D   80FE         SJMP    ??main_14
   \                     ??main_13:
   \   00027F                ; Setup parameters for call to function putsDialog
   \   00027F   7A..         MOV     R2,#`?<Constant "Start\\r\\n">` & 0xff
   \   000281   7B..         MOV     R3,#(`?<Constant "Start\\r\\n">` >> 8) & 0xff
   \   000283   12....       LCALL   ??putsDialog
   \   000286   02....       LJMP    ??main_5
   \                     ??main_11:
   \   000289                ; Setup parameters for call to function putsDialog
   \   000289   7A..         MOV     R2,#`?<Constant "Verified Error">` & 0xff
   \   00028B   7B..         MOV     R3,#(`?<Constant "Verified Error">` >> 8) & 0xff
   \   00028D   12....       LCALL   ??putsDialog
   \                     ??main_15:
   \   000290   80FE         SJMP    ??main_15
   \                     ??main_16:
   \   000292                ; Setup parameters for call to function halAesEncrDecr
   \   000292   75..14       MOV     ?V0 + 0,#0x14
   \   000295   75..01       MOV     ?V0 + 1,#0x1
   \   000298   78..         MOV     R0,#?V0 + 0
   \   00029A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00029D   7901         MOV     R1,#0x1
   \   00029F   7C10         MOV     R4,#0x10
   \   0002A1   7D00         MOV     R5,#0x0
   \   0002A3   7A14         MOV     R2,#0x14
   \   0002A5   7B01         MOV     R3,#0x1
   \   0002A7   12....       LCALL   ??halAesEncrDecr
   \   0002AA   7402         MOV     A,#0x2
   \   0002AC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002AF   EE           MOV     A,R6
   \   0002B0   F8           MOV     R0,A
   \   0002B1   EF           MOV     A,R7
   \   0002B2   5401         ANL     A,#0x1
   \   0002B4   F9           MOV     R1,A
   \   0002B5   E8           MOV     A,R0
   \   0002B6   49           ORL     A,R1
   \   0002B7   7010         JNZ     ??main_17
   \   0002B9                ; Setup parameters for call to function HalFlashErase
   \   0002B9   8E..         MOV     ?V0 + 0,R6
   \   0002BB   8F..         MOV     ?V0 + 1,R7
   \   0002BD   7409         MOV     A,#0x9
   \   0002BF   78..         MOV     R0,#?V0 + 0
   \   0002C1   12....       LCALL   ?US_SHR
   \   0002C4   A9..         MOV     R1,?V0 + 0
   \   0002C6   12....       LCALL   HalFlashErase
   \                     ??main_17:
   \   0002C9                ; Setup parameters for call to function HalFlashWrite
   \   0002C9   900113       MOV     DPTR,#0x113
   \   0002CC   E0           MOVX    A,@DPTR
   \   0002CD   13           RRC     A
   \   0002CE   13           RRC     A
   \   0002CF   543F         ANL     A,#0x3f
   \   0002D1   F5..         MOV     ?V0 + 0,A
   \   0002D3   75..00       MOV     ?V0 + 1,#0x0
   \   0002D6   78..         MOV     R0,#?V0 + 0
   \   0002D8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002DB   7C14         MOV     R4,#0x14
   \   0002DD   7D01         MOV     R5,#0x1
   \   0002DF   EE           MOV     A,R6
   \   0002E0   FA           MOV     R2,A
   \   0002E1   EF           MOV     A,R7
   \   0002E2   FB           MOV     R3,A
   \   0002E3   12....       LCALL   HalFlashWrite
   \   0002E6   7402         MOV     A,#0x2
   \   0002E8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002EB   900113       MOV     DPTR,#0x113
   \   0002EE   E0           MOVX    A,@DPTR
   \   0002EF   13           RRC     A
   \   0002F0   13           RRC     A
   \   0002F1   543F         ANL     A,#0x3f
   \   0002F3   F8           MOV     R0,A
   \   0002F4   EE           MOV     A,R6
   \   0002F5   28           ADD     A,R0
   \   0002F6   FE           MOV     R6,A
   \   0002F7   EF           MOV     A,R7
   \   0002F8   3400         ADDC    A,#0x0
   \   0002FA   FF           MOV     R7,A
   \   0002FB   A3           INC     DPTR
   \   0002FC   E4           CLR     A
   \   0002FD   F0           MOVX    @DPTR,A
   \   0002FE   900113       MOV     DPTR,#0x113
   \   000301   7402         MOV     A,#0x2
   \                     ??main_18:
   \   000303   F0           MOVX    @DPTR,A
   \   000304                ; Setup parameters for call to function Message_Send
   \   000304   12....       LCALL   ??Message_Send
   \                     ??main_6:
   \   000307                ; Setup parameters for call to function Message_Rcv
   \   000307   12....       LCALL   ??Message_Rcv
   \   00030A   E9           MOV     A,R1
   \   00030B   60FA         JZ      ??main_6
   \   00030D   900100       MOV     DPTR,#0x100
   \   000310   E4           CLR     A
   \   000311   F0           MOVX    @DPTR,A
   \   000312   900102       MOV     DPTR,#0x102
   \   000315   F0           MOVX    @DPTR,A
   \   000316   900111       MOV     DPTR,#0x111
   \   000319   E0           MOVX    A,@DPTR
   \   00031A   24BF         ADD     A,#-0x41
   \   00031C   7003         JNZ     $+5
   \   00031E   02....       LJMP    ??main_16
   \   000321   14           DEC     A
   \   000322   70E3         JNZ     ??main_6
   \   000324   900114       MOV     DPTR,#0x114
   \   000327   7455         MOV     A,#0x55
   \   000329   F0           MOVX    @DPTR,A
   \   00032A   A3           INC     DPTR
   \   00032B   E4           CLR     A
   \   00032C   F0           MOVX    @DPTR,A
   \   00032D   900113       MOV     DPTR,#0x113
   \   000330   7403         MOV     A,#0x3
   \   000332   80CF         SJMP    ??main_18
    597          		{
    598          			//Add code to avoiding repeat crc process
    599          			crc[0] = crc[1];
   \                     ??main_10:
   \   000334   85..82       MOV     DPL,?XSP + 0
   \   000337   85..83       MOV     DPH,?XSP + 1
   \   00033A   E8           MOV     A,R0
   \   00033B   F0           MOVX    @DPTR,A
   \   00033C   A3           INC     DPTR
   \   00033D   E9           MOV     A,R1
   \   00033E   F0           MOVX    @DPTR,A
    600          			HalFlashErase(HAL_OAD_RC_START / HAL_FLASH_PAGE_SIZE );
   \   00033F                ; Setup parameters for call to function HalFlashErase
   \   00033F   7940         MOV     R1,#0x40
   \   000341   12....       LCALL   HalFlashErase
    601          			HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
   \   000344                ; Setup parameters for call to function HalFlashWrite
   \   000344   75..01       MOV     ?V0 + 0,#0x1
   \   000347   78..         MOV     R0,#?V0 + 0
   \   000349   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00034C   7402         MOV     A,#0x2
   \   00034E   12....       LCALL   ?XSTACK_DISP0_8
   \   000351   AC82         MOV     R4,DPL
   \   000353   AD83         MOV     R5,DPH
   \   000355   7A22         MOV     R2,#0x22
   \   000357   7B80         MOV     R3,#-0x80
   \   000359   12....       LCALL   HalFlashWrite
   \   00035C   7402         MOV     A,#0x2
   \   00035E   12....       LCALL   ?DEALLOC_XSTACK8
    602          			//putsDialog("CRC error\r\n");
    603          			//SendData(crc[0]>>8);
    604          			//SendData(crc[0]&0xff);
    605          			//SendData(crc[1]>>8);
    606          			//SendData(crc[1]&0xff);
    607          		}
    608          	}
    609          
    610          	HAL_TURN_ON_LED2();
   \                     ??main_8:
   \   000361   C280         CLR     0x80.0
    611          	HAL_TURN_OFF_LED1();
   \   000363   C291         CLR     0x90.1
    612          #if 0
    613          	  if (crc[0] != crc[1])
    614          	{
    615          		// If the CRC is erased or the RC code fails a sanity check, instantiate the DL code (again).
    616          		if ((crc[0] == 0) || (crc[0] != crcCalc()))
    617          		{
    618          			dl2rc();
    619          
    620          			/* If dl2rc() fails, a flawed image is allowed to run - 
    621          			* maybe the damage is not fatal to OTA ops?
    622          			*/
    623          		}
    624          		else
    625          		{
    626          			crc[1] = crc[0];
    627          			HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
    628          		}
    629          	}
    630          #endif
    631          #endif
    632          
    633          	// Simulate a reset for the Application code by an absolute jump to location 0x0800.
    634          	//asm("LJMP 0x800\n");
    635          	//Uart_Send_String("jump",4);
    636          	//asm("LJMP 0x2000\n");
    637          	//putsDialog("jump");
    638          	//asm("LJMP 0x1000\n");
    639          	asm("LJMP 0x2000\n");
   \   000365   022000       LJMP 0x2000
    640          	//asm("LJMP 0x2000\n");
    641          	//asm("LJMP 0x1000\n");
    642          	//asm("LJMP 0x5000\n");
    643            }
    644            
    645          }
   \   000368   7414         MOV     A,#0x14
   \   00036A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00036D   22           RET
   \   00036E                REQUIRE SLEEPCMD
   \   00036E                REQUIRE SLEEPSTA
   \   00036E                REQUIRE CLKCONCMD
   \   00036E                REQUIRE CLKCONSTA
   \   00036E                REQUIRE P1DIR
   \   00036E                REQUIRE P0DIR
   \   00036E                REQUIRE DMA0CFGH
   \   00036E                REQUIRE DMA0CFGL
   \   00036E                REQUIRE P0SEL
   \   00036E                REQUIRE _A_P0
   \   00036E                REQUIRE _A_P1
   \   00036E                REQUIRE ENCCS
   \   00036E                REQUIRE ENCDI
   \   00036E                REQUIRE PERCFG
   \   00036E                REQUIRE U0CSR
   \   00036E                REQUIRE U0GCR
   \   00036E                REQUIRE U0BAUD
   \   00036E                REQUIRE _A_IRCON2
   \   00036E                REQUIRE _A_TCON
    646          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    647          static void MemReadRam(macRam_t * pRam, uint8 * pData, uint8 len)
   \                     ??MemReadRam:
    648          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   801D         SJMP    ??MemReadRam_1
    649            while (len)
    650            {
    651              len--;
   \                     ??MemReadRam_2:
   \   000006   19           DEC     R1
    652              *pData = *pRam;
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   F0           MOVX    @DPTR,A
    653              pRam++;
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   A3           INC     DPTR
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
    654              pData++;
   \   00001A   8C82         MOV     DPL,R4
   \   00001C   8D83         MOV     DPH,R5
   \   00001E   A3           INC     DPTR
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
    655            }
   \                     ??MemReadRam_1:
   \   000023   E9           MOV     A,R1
   \   000024   70E0         JNZ     ??MemReadRam_2
    656          }
   \   000026   80..         SJMP    ?Subroutine1
    657          
    658          static uint8 OAD_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
    659          {
    660            const uint8 GENERIC *pSrc1;
    661            const uint8 GENERIC *pSrc2;
    662          
    663            pSrc1 = src1;
    664            pSrc2 = src2;
    665          
    666            while ( len-- )
    667            {
    668              if( *pSrc1++ != *pSrc2++ )
    669                return FALSE;
    670            }
    671            return TRUE;
    672          }
    673          
    674          static void InitUart(void)
    675          {
    676              //CLKCONCMD &= ~0x40; // ÉèÖÃÏµÍ³Ê±ÖÓÔ´Îª 32MHZ¾§Õñ
    677              //while(CLKCONSTA & 0x40);                     // µÈ´ý¾§ÕñÎÈ¶¨ 
    678              //CLKCONCMD &= ~0x47;                          // ÉèÖÃÏµÍ³Ö÷Ê±ÖÓÆµÂÊÎª 32MHZ
    679          
    680              PERCFG &= ~0x01;        //Î»ÖÃ1 P0¿Ú 
    681              P0SEL |= 0x0c;        //P0_2,P0_3,P0_4,P0_5ÓÃ×÷´®¿Ú,µÚ¶þ¹¦ÄÜ 
    682              //P0DIR |= 0x04;
    683             // P0DIR &= ~0x08;
    684              //P0DIR |= 0x08;
    685              //P2DIR &= ~0XC0;      //P0 ÓÅÏÈ×÷ÎªUART0 £¬ÓÅÏÈ¼¶
    686              //PERCFG &= ~(BV(0)); //Ñ¡ÔñP0¶Ë¿Úuart
    687              //P0SEL |=BV(5)|BV(4)|BV(3)|BV(2);
    688              //P2DIR &=~(BV(7)|BV(6));
    689          
    690              U0CSR |= 0x80;       //UART ·½Ê½ 
    691              U0GCR = 11;         //U0GCRÓëU0BAUDÅäºÏ     
    692              U0BAUD = 216;       // ²¨ÌØÂÊÉèÎª115200 
    693              UTX0IF = 0;          //UART0 TX ÖÐ¶Ï±êÖ¾³õÊ¼ÖÃÎ»1  £¨ÊÕ·¢Ê±ºò£©
    694              U0CSR |= 0X40;       //ÔÊÐí½ÓÊÕ 
    695             // IEN0 |= 0x84;        // ¿ª×ÜÖÐ¶Ï£¬½ÓÊÕÖÐ¶Ï    
    696          
    697             URX0IF = 0;
    698          
    699            // P1_3 = !P1_3;
    700          }
    701          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    702          static void SendData(char dat)
   \                     ??SendData:
    703          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    704          	U0DBUF = dat;
   \   000000   89C1         MOV     0xc1,R1
    705          	while(!UTX0IF);
   \                     ??SendData_1:
   \   000002   A2E9         MOV     C,0xe8.1
   \   000004   50FC         JNC     ??SendData_1
    706          	UTX0IF = 0; 	
   \   000006   C2E9         CLR     0xe8.1
    707          }
   \   000008   22           RET
   \   000009                REQUIRE U0DBUF
   \   000009                REQUIRE _A_IRCON2
    708          
    709          #if 1

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    710          static void putsDialog(const char *str)
   \                     ??putsDialog:
    711          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   8004         SJMP    ??putsDialog_1
    712          	 //UartDecode(str);
    713          	 while(*str != '\0')
    714          	{
    715                  	SendData(*str++);
   \                     ??putsDialog_2:
   \   00000A                ; Setup parameters for call to function SendData
   \   00000A   12....       LCALL   ??SendData
   \   00000D   A3           INC     DPTR
    716              }
   \                     ??putsDialog_1:
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F9           MOV     R1,A
   \   000010   70F8         JNZ     ??putsDialog_2
    717          }
   \   000012                REQUIRE ?Subroutine1
   \   000012                ; // Fall through to label ?Subroutine1
    718          #endif
    719          
    720          #ifdef _FORMAT_PRINT_
    721          
    722          
    723          static char *_itoa(long n, int base)
    724           {
    725            	char *p;
    726           	int minus;
    727           	static char buf[16];
    728          
    729          //	puts_("enter _itoa\n");
    730          //	put_hex(n);
    731          
    732           	p = &buf[16];
    733           	*--p =  0;
    734           	if (n < 0) 
    735          	{
    736            		minus = 1;
    737            		n = -n;
    738           	}
    739           	else
    740            		minus = 0;
    741          
    742          
    743           	if (n == 0)
    744          	{
    745            		*--p = '0';
    746          	}
    747           	else
    748            		while (n > 0) 
    749          		{  
    750          	//		puts_("_itoa ");
    751             			*--p = "0123456789abcdef"[n % base];
    752          	//		putchar(*p);
    753             			n /= base;
    754            		}
    755          
    756           	if (minus)
    757            		*--p = '-';
    758          
    759           	return p;
    760          }
    761          /*
    762          int printfDig( long n, int base )
    763          {
    764          	return Tprintf( _itoa( n, base ) );
    765          	put_byte(0x0D);
    766              put_byte(0x0A);	
    767          }
    768          */
    769          static int Printf(const char *fmt, ...)
    770          {
    771          	//int i;
    772          	const char *s;
    773           	int d;
    774          	char buf[16];
    775          	char *p = buf;
    776          //	char buf[16];
    777          //	char *p = buf;
    778           	va_list ap;
    779          
    780              va_start(ap, fmt);
    781          	//i = 16;
    782          
    783              while (*fmt) 
    784          	{
    785                  if (*fmt != '%') 
    786          		{
    787                      SendData(*fmt++);
    788                      continue;
    789                  }
    790          		
    791          		switch(*++fmt)
    792          		{
    793                      case 's':
    794                          s = va_arg(ap, const char *);
    795                          for ( ; *s; s++) 
    796          				{
    797                              SendData(*s);
    798                          }
    799                          break;
    800                      case 'd':			
    801                          d = va_arg(ap, int);
    802          				//d>>=8;
    803                          p = _itoa(d, 10);
    804                          for (s = p; *s; s++) 
    805          				{
    806                              SendData(*s);
    807                          }
    808          
    809          				break;
    810          
    811                      case 'x':
    812          			case 'X':
    813                          d = va_arg(ap, int);
    814                          p = _itoa(d, 16);
    815                          for (s = p; *s; s++) 
    816          				{
    817                              SendData(*s);
    818                          }
    819                          break;
    820                       //Add other specifiers here...              
    821                      default:  
    822                          putsDialog(fmt);
    823                          break;
    824                  } 
    825                  fmt++;
    826              }
    827              va_end(ap);
    828          
    829              return 1;   /* Dummy return value */
    830          } 
    831          #endif
    832          
    833          static void delay(unsigned int de)
    834          {
    835          	//while(de--);
    836          	 uint16 i,j;
    837          	 for(i=de;i>0;i--)
    838          	   for(j=587;j>0;j--);
    839          }
    840          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    841          static unsigned char RcvData(void)
   \                     ??RcvData:
    842          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    843          	unsigned char count1=0;
   \   000004   7900         MOV     R1,#0x0
    844          	unsigned char count2=0;
   \   000006   7800         MOV     R0,#0x0
    845          
    846          	while( !URX0IF )
   \                     ??RcvData_1:
   \   000008   A28B         MOV     C,0x88.3
   \   00000A   401B         JC      ??RcvData_2
    847          	{
    848          		count1++;
   \   00000C   09           INC     R1
    849          		if(count1==252)
   \   00000D   74FC         MOV     A,#-0x4
   \   00000F   69           XRL     A,R1
   \   000010   7003         JNZ     ??RcvData_3
    850          		{
    851          		count1=0;
   \   000012   7900         MOV     R1,#0x0
    852          		count2++;
   \   000014   08           INC     R0
    853          		}
    854          		if((count2==252)&&(start_flag==1))
   \                     ??RcvData_3:
   \   000015   74FC         MOV     A,#-0x4
   \   000017   68           XRL     A,R0
   \   000018   70EE         JNZ     ??RcvData_1
   \   00001A   900101       MOV     DPTR,#0x101
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6401         XRL     A,#0x1
   \   000020   70E6         JNZ     ??RcvData_1
    855          		{
    856          			start_flag=0;
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
    857          			
    858          			return 0;
   \   000024   F9           MOV     R1,A
   \   000025   8004         SJMP    ??RcvData_4
    859          		}
    860          	}
    861          	URX0IF = 0;
   \                     ??RcvData_2:
   \   000027   C28B         CLR     0x88.3
    862          	return U0DBUF;
   \   000029   A9C1         MOV     R1,0xc1
   \                     ??RcvData_4:
   \   00002B   80..         SJMP    ?Subroutine1
   \   00002D                REQUIRE _A_TCON
   \   00002D                REQUIRE U0DBUF
    863          }
    864          
    865          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    866          static unsigned char Message_Rcv(void)
   \                     ??Message_Rcv:
    867          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    868          	unsigned char	ucdata;
    869          	unsigned char 	rcvdat;
    870          	unsigned char	uci;
    871          	start_flag=0;
   \   000005   900101       MOV     DPTR,#0x101
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
    872          
    873          	//P1_3 = !P1_3;
    874          	
    875               ucdata=RcvData();
    876          	if(ucdata!=0x7E)
   \   00000A                ; Setup parameters for call to function RcvData
   \   00000A   12....       LCALL   ??RcvData
   \   00000D   E9           MOV     A,R1
   \   00000E   647E         XRL     A,#0x7e
   \   000010   6004         JZ      ??Message_Rcv_1
    877          	   return 0;
   \                     ??Message_Rcv_2:
   \   000012   7900         MOV     R1,#0x0
   \   000014   8062         SJMP    ??Message_Rcv_3
    878          	start_flag=1;
   \                     ??Message_Rcv_1:
   \   000016   7401         MOV     A,#0x1
   \   000018   F0           MOVX    @DPTR,A
    879          	ucdata=RcvData();
   \   000019                ; Setup parameters for call to function RcvData
   \   000019   12....       LCALL   ??RcvData
   \   00001C   E9           MOV     A,R1
    880          	ucLDR_Message.com_number=  ucdata;
   \   00001D   900110       MOV     DPTR,#0x110
   \   000020   F0           MOVX    @DPTR,A
    881          	ucLDR_Message.msg_cks=ucdata;
   \   000021   900164       MOV     DPTR,#0x164
   \   000024   12....       LCALL   ??Subroutine13_0
    882          	
    883                ucdata=RcvData();
    884          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_18:
   \   000027   60E9         JZ      ??Message_Rcv_2
    885          		return 0;
    886          	ucLDR_Message.protocol_command=  ucdata;
   \   000029   E8           MOV     A,R0
   \   00002A   900111       MOV     DPTR,#0x111
   \   00002D   12....       LCALL   ?Subroutine3
    887          	ucLDR_Message.msg_cks+=ucdata;	
    888          	
    889          	ucdata=RcvData();
    890          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_16:
   \   000030   60E0         JZ      ??Message_Rcv_2
    891          		 return 0;
    892          	ucLDR_Message.no_used=  ucdata;
   \   000032   E8           MOV     A,R0
   \   000033   900112       MOV     DPTR,#0x112
   \   000036   12....       LCALL   ?Subroutine3
    893          	ucLDR_Message.msg_cks+=ucdata;	
    894          	
    895          	ucdata=RcvData();
    896          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_17:
   \   000039   60D7         JZ      ??Message_Rcv_2
    897          		 return 0;
    898          	ucLDR_Message.data_length=  ucdata;
   \   00003B   E8           MOV     A,R0
   \   00003C   900113       MOV     DPTR,#0x113
   \   00003F   12....       LCALL   ?Subroutine10
    899          	ucLDR_Message.msg_cks+=ucdata;
   \                     ??CrossCallReturnLabel_11:
   \   000042   F0           MOVX    @DPTR,A
    900          	
    901          	for( uci=0 ; uci<ucLDR_Message.data_length ; uci++ )
   \   000043   7E00         MOV     R6,#0x0
   \   000045   8019         SJMP    ??Message_Rcv_4
    902          	{
    903          		ucdata = RcvData();
   \                     ??Message_Rcv_5:
   \   000047                ; Setup parameters for call to function RcvData
   \   000047   12....       LCALL   ?Subroutine7
    904          		if(start_flag==0)
   \                     ??CrossCallReturnLabel_7:
   \   00004A   60C6         JZ      ??Message_Rcv_2
    905          			 return 0;
    906          		ucLDR_Message.com_data[uci] = ucdata;
   \   00004C   8E..         MOV     ?V0 + 0,R6
   \   00004E   7414         MOV     A,#0x14
   \   000050   25..         ADD     A,?V0 + 0
   \   000052   F582         MOV     DPL,A
   \   000054   7401         MOV     A,#0x1
   \   000056   3400         ADDC    A,#0x0
   \   000058   F583         MOV     DPH,A
   \   00005A   E8           MOV     A,R0
   \   00005B   12....       LCALL   ?Subroutine10
    907          		ucLDR_Message.msg_cks+=ucdata;
    908          	}
   \                     ??CrossCallReturnLabel_12:
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   0E           INC     R6
   \                     ??Message_Rcv_4:
   \   000060   900113       MOV     DPTR,#0x113
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F8           MOV     R0,A
   \   000065   EE           MOV     A,R6
   \   000066   C3           CLR     C
   \   000067   98           SUBB    A,R0
   \   000068   40DD         JC      ??Message_Rcv_5
    909          	ucdata = RcvData();
   \   00006A                ; Setup parameters for call to function RcvData
   \   00006A   12....       LCALL   ?Subroutine7
    910          	rcvdat = ucLDR_Message.msg_cks;
    911          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_8:
   \   00006D   60A3         JZ      ??Message_Rcv_2
    912          		 return 0;
    913          	//if(ucLDR_Message.msg_cks==ucdata)
    914          	if(rcvdat==ucdata)
   \   00006F   900164       MOV     DPTR,#0x164
   \   000072   E0           MOVX    A,@DPTR
   \   000073   68           XRL     A,R0
   \   000074   709C         JNZ     ??Message_Rcv_2
    915                return 1;
   \   000076   7901         MOV     R1,#0x1
   \                     ??Message_Rcv_3:
   \   000078   02....       LJMP    ?Subroutine0
    916          	else
    917          	return 0;	
    918          
    919          }

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine11
   \                     ??CrossCallReturnLabel_19:
   \   000003   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine10
   \                     ??CrossCallReturnLabel_13:
   \   000003                REQUIRE ??Subroutine13_0
   \   000003                ; // Fall through to label ??Subroutine13_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine13_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function RcvData
   \   000001                ; Setup parameters for call to function RcvData
   \   000001                ; Setup parameters for call to function RcvData
   \   000001   12....       LCALL   ?Subroutine11
   \                     ??CrossCallReturnLabel_20:
   \   000004   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ??RcvData
   \   000003   E9           MOV     A,R1
   \   000004   F8           MOV     R0,A
   \   000005   900101       MOV     DPTR,#0x101
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   900164       MOV     DPTR,#0x164
   \   000004   E0           MOVX    A,@DPTR
   \   000005   28           ADD     A,R0
   \   000006   22           RET
    920          
    921          
    922          /*********************************************************************
    923           * @fn      dl2rc
    924           *
    925           * @brief   Copy the DL image to the RC image location.
    926           *
    927           *  NOTE:   Assumes that DL image ends on a flash word boundary.
    928           *
    929           * @param   None.
    930           *
    931           * @return  None.
    932           *********************************************************************/
    933          #if 1

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    934          static void Message_Send(void)
   \                     ??Message_Send:
    935          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    936          	unsigned char  uci;
    937          	
    938          	SendData(0x7E);
   \   000005                ; Setup parameters for call to function SendData
   \   000005   797E         MOV     R1,#0x7e
   \   000007   12....       LCALL   ??SendData
    939              
    940          	ucLDR_Message.msg_cks =ucLDR_Message.com_number;
   \   00000A   900110       MOV     DPTR,#0x110
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   900164       MOV     DPTR,#0x164
   \   000011   F0           MOVX    @DPTR,A
    941              SendData(ucLDR_Message.com_number);
   \   000012                ; Setup parameters for call to function SendData
   \   000012   F9           MOV     R1,A
   \   000013   12....       LCALL   ??SendData
    942              
    943              ucLDR_Message.msg_cks+=ucLDR_Message.protocol_command;
   \   000016   900111       MOV     DPTR,#0x111
   \   000019   12....       LCALL   ?Subroutine12
    944          	SendData(ucLDR_Message.protocol_command);  
   \                     ??CrossCallReturnLabel_14:
   \   00001C                ; Setup parameters for call to function SendData
   \   00001C   900111       MOV     DPTR,#0x111
   \   00001F   12....       LCALL   ?Subroutine4
    945          	
    946              ucLDR_Message.msg_cks+=ucLDR_Message.no_used;
    947          	SendData(ucLDR_Message.no_used); 	
   \                     ??CrossCallReturnLabel_0:
   \   000022                ; Setup parameters for call to function SendData
   \   000022   900112       MOV     DPTR,#0x112
   \   000025   12....       LCALL   ?Subroutine4
    948          		
    949              ucLDR_Message.msg_cks+=ucLDR_Message.data_length;
    950          	SendData(ucLDR_Message.data_length); 
   \                     ??CrossCallReturnLabel_1:
   \   000028                ; Setup parameters for call to function SendData
   \   000028   900113       MOV     DPTR,#0x113
   \   00002B   12....       LCALL   ?Subroutine5
    951          		
    952          
    953              for(uci =0;uci<ucLDR_Message.data_length;uci++)
   \                     ??CrossCallReturnLabel_2:
   \   00002E   7E00         MOV     R6,#0x0
   \   000030   8020         SJMP    ??Message_Send_1
    954              {
    955                 ucLDR_Message.msg_cks+=ucLDR_Message.com_data[uci];  
   \                     ??Message_Send_2:
   \   000032   8E..         MOV     ?V0 + 0,R6
   \   000034   7414         MOV     A,#0x14
   \   000036   25..         ADD     A,?V0 + 0
   \   000038   F8           MOV     R0,A
   \   000039   7401         MOV     A,#0x1
   \   00003B   3400         ADDC    A,#0x0
   \   00003D   F9           MOV     R1,A
   \   00003E   8882         MOV     DPL,R0
   \   000040   8983         MOV     DPH,R1
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FA           MOV     R2,A
   \   000044   900164       MOV     DPTR,#0x164
   \   000047   E0           MOVX    A,@DPTR
   \   000048   2A           ADD     A,R2
   \   000049   F0           MOVX    @DPTR,A
    956                 SendData(ucLDR_Message.com_data[uci]); 	
   \   00004A                ; Setup parameters for call to function SendData
   \   00004A   8882         MOV     DPL,R0
   \   00004C   8983         MOV     DPH,R1
   \   00004E   12....       LCALL   ?Subroutine5
    957          	 }
   \                     ??CrossCallReturnLabel_3:
   \   000051   0E           INC     R6
   \                     ??Message_Send_1:
   \   000052   900113       MOV     DPTR,#0x113
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   EE           MOV     A,R6
   \   000058   C3           CLR     C
   \   000059   98           SUBB    A,R0
   \   00005A   40D6         JC      ??Message_Send_2
    958               ucLDR_Message.msg_cks+=0;
   \   00005C   900164       MOV     DPTR,#0x164
   \   00005F   12....       LCALL   ?Subroutine5
    959          	 SendData(ucLDR_Message.msg_cks); 		
    960          }
   \                     ??CrossCallReturnLabel_4:
   \   000062   02....       LJMP    ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                ; Setup parameters for call to function SendData
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??SendData
   \   000005   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??SendData
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine12
   \                     ??CrossCallReturnLabel_15:
   \   000009   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   900164       MOV     DPTR,#0x164
   \   000005   E0           MOVX    A,@DPTR
   \   000006   28           ADD     A,R0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET
    961          
    962          #endif
    963          
    964          #ifdef OAD_AES_VERI
    965          static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key)
    966          {
    967             UINT8 i;
    968          
    969             // Checking whether to load a key or an initialisation vector.
    970             if(key){
    971                AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_KEY);
    972             }
    973             else {
    974                AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_IV);
    975             }
    976             // Starting loading of key or vector.
    977             AES_START();
    978          
    979             // loading the data (key or vector)
    980             for(i = 0; i < 16; i++){
    981                ENCDI = pData[i];
    982             }
    983          }
    984          
    985          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    986          static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr)
   \                     ??halAesEncrDecr:
    987          {
   \   000000   74EF         MOV     A,#-0x11
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 17
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 6,R1
   \   000007   7411         MOV     A,#0x11
   \   000009   12....       LCALL   ?XSTACK_DISP0_8
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   E8           MOV     A,R0
   \   000012   FE           MOV     R6,A
   \   000013   E9           MOV     A,R1
   \   000014   FF           MOV     R7,A
    988             UINT16  i;
    989             UINT8   j, k;
                               ^
Warning[Pe177]: variable "k" was declared but never referenced
    990             BYTE    mode;
    991             UINT16  nbrOfBlocks;
    992             UINT16  convertedBlock;
    993             UINT8   delay;
    994          
    995             nbrOfBlocks = length / 16;
   \   000015   8C..         MOV     ?V0 + 0,R4
   \   000017   8D..         MOV     ?V0 + 1,R5
   \   000019   7404         MOV     A,#0x4
   \   00001B   78..         MOV     R0,#?V0 + 0
   \   00001D   12....       LCALL   ?US_SHR
   \   000020   85....       MOV     ?V0 + 2,?V0 + 0
   \   000023   85....       MOV     ?V0 + 3,?V0 + 1
    996             mode = 0;
    997          
    998             if( (length % 16) != 0){
   \   000026   EC           MOV     A,R4
   \   000027   540F         ANL     A,#0xf
   \   000029   600C         JZ      ??halAesEncrDecr_1
    999                // length not multiplum of 16, convert one block extra with zeropadding
   1000                nbrOfBlocks++;
   \   00002B   E5..         MOV     A,?V0 + 2
   \   00002D   2401         ADD     A,#0x1
   \   00002F   F5..         MOV     ?V0 + 2,A
   \   000031   E5..         MOV     A,?V0 + 3
   \   000033   3400         ADDC    A,#0x0
   \   000035   F5..         MOV     ?V0 + 3,A
   1001             }
   1002          
   1003             // Loading the IV.
   1004             //halAesLoadKeyOrInitVector(pInitVector, FALSE);
   1005          
   1006             // Starting either encryption or decryption
   1007             if(decr){
   \                     ??halAesEncrDecr_1:
   \   000037   E5..         MOV     A,?V0 + 6
   \   000039   600A         JZ      ??halAesEncrDecr_2
   1008                AES_SET_ENCR_DECR_KEY_IV(AES_DECRYPT);
   \   00003B   E5B3         MOV     A,0xb3
   \   00003D   54F8         ANL     A,#0xf8
   \   00003F   4402         ORL     A,#0x2
   \   000041   F5B3         MOV     0xb3,A
   \   000043   8003         SJMP    ??halAesEncrDecr_3
   1009             } else {
   1010                AES_SET_ENCR_DECR_KEY_IV(AES_ENCRYPT);
   \                     ??halAesEncrDecr_2:
   \   000045   53B3F8       ANL     0xb3,#0xf8
   1011             }
   1012          
   1013             // Getting the operation mode.
   1014             mode = ENCCS & 0x70;
   \                     ??halAesEncrDecr_3:
   \   000048   E5B3         MOV     A,0xb3
   \   00004A   5470         ANL     A,#0x70
   \   00004C   F5..         MOV     ?V0 + 7,A
   1015          
   1016             for(convertedBlock = 0; convertedBlock < nbrOfBlocks; convertedBlock++){
   \   00004E   75..00       MOV     ?V0 + 0,#0x0
   \   000051   75..00       MOV     ?V0 + 1,#0x0
   \   000054   8047         SJMP    ??halAesEncrDecr_4
   1017                // Starting the conversion.
   1018                AES_START();
   1019          
   1020                i = convertedBlock * 16;
   1021                // Counter, Output Feedback and Cipher Feedback operates on 4 bytes and not 16 bytes.
   1022                if((mode == CFB) || (mode == OFB) || (mode == CTR))
   1023          	 {
   1024          /*
   1025                   for(j = 0; j < 4; j++){
   1026                      // Writing the input data
   1027                      // Zeropadding the remainder of the block
   1028                      for(k = 0; k < 4; k++){
   1029                         ENCDI = ((i + 4*j + k < length) ? pDataIn[i + 4*j + k] : 0x00 );
   1030                      }
   1031                      // wait for data ready
   1032                      delay = DELAY;
   1033                      while(delay--);
   1034                      // Read out data for every 4th byte
   1035                      for(k = 0; k < 4; k++){
   1036                         pDataOut[i + 4*j + k] = ENCDO;
   1037                      }
   1038                   }
   1039          */
   1040                }
   1041                else if(mode == CBC_MAC){/*
   1042                   // Writing the input data
   1043                   // Zeropadding the remainder of the block
   1044                   for(j = 0; j < 16; j++){
   1045                      ENCDI = ((i + j < length) ? pDataIn[i + j] : 0x00 );
   1046                   }
   1047                   // The last block of the CBC-MAC is computed by using CBC mode.
   1048                   if(convertedBlock == nbrOfBlocks - 2){
   1049                      AES_SETMODE(CBC);
   1050                      delay = DELAY;
   1051                      while(delay--);
   1052                   }
   1053                   // The CBC-MAC does not produce an output on the n-1 first blocks
   1054                   // only the last block is read out
   1055                   else if(convertedBlock == nbrOfBlocks - 1){
   1056                      // wait for data ready
   1057                      delay = DELAY;
   1058                      while(delay--);
   1059                      for(j = 0; j < 16; j++){
   1060                         pDataOut[j] = ENCDO;
   1061                      }
   1062                   }*/
   1063                }
   1064                else{
   1065                   // Writing the input data
   1066                   // Zeropadding the remainder of the block
   1067                   for(j = 0; j < 16; j++){
   1068                      ENCDI = ((i+j < length) ? pDataIn[i+j] : 0x00 );
   \                     ??halAesEncrDecr_5:
   \   000056   E4           CLR     A
   \                     ??halAesEncrDecr_6:
   \   000057   F5B1         MOV     0xb1,A
   \   000059   05..         INC     ?V0 + 9
   \   00005B   E5..         MOV     A,?V0 + 9
   \   00005D   C3           CLR     C
   \   00005E   9410         SUBB    A,#0x10
   \   000060   4075         JC      ??halAesEncrDecr_7
   1069                   }
   1070                   // wait for data ready
   1071                   delay = DELAY;
   \   000062   75..0F       MOV     ?V0 + 4,#0xf
   1072                   while(delay--);
   \                     ??halAesEncrDecr_8:
   \   000065   85....       MOV     ?V0 + 8,?V0 + 4
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   25..         ADD     A,?V0 + 8
   \   00006C   F5..         MOV     ?V0 + 4,A
   \   00006E   04           INC     A
   \   00006F   70F4         JNZ     ??halAesEncrDecr_8
   1073                   // Read out data
   1074                   for(j = 0; j < 16; j++){
   \   000071   75..00       MOV     ?V0 + 9,#0x0
   1075                      pDataOut[i+j] = ENCDO;
   \                     ??halAesEncrDecr_9:
   \   000074   E5B2         MOV     A,0xb2
   \   000076   C0E0         PUSH    A
   \   000078   12....       LCALL   ?Subroutine8
   1076                   }
   \                     ??CrossCallReturnLabel_9:
   \   00007B   EE           MOV     A,R6
   \   00007C   25..         ADD     A,?V0 + 4
   \   00007E   F582         MOV     DPL,A
   \   000080   EF           MOV     A,R7
   \   000081   35..         ADDC    A,?V0 + 5
   \   000083   F583         MOV     DPH,A
   \   000085   D0E0         POP     A
   \   000087   F0           MOVX    @DPTR,A
   \   000088   05..         INC     ?V0 + 9
   \   00008A   E5..         MOV     A,?V0 + 9
   \   00008C   C3           CLR     C
   \   00008D   9410         SUBB    A,#0x10
   \   00008F   40E3         JC      ??halAesEncrDecr_9
   \                     ??halAesEncrDecr_10:
   \   000091   E5..         MOV     A,?V0 + 0
   \   000093   2401         ADD     A,#0x1
   \   000095   F5..         MOV     ?V0 + 0,A
   \   000097   E5..         MOV     A,?V0 + 1
   \   000099   3400         ADDC    A,#0x0
   \   00009B   F5..         MOV     ?V0 + 1,A
   \                     ??halAesEncrDecr_4:
   \   00009D   C3           CLR     C
   \   00009E   E5..         MOV     A,?V0 + 0
   \   0000A0   95..         SUBB    A,?V0 + 2
   \   0000A2   E5..         MOV     A,?V0 + 1
   \   0000A4   95..         SUBB    A,?V0 + 3
   \   0000A6   504C         JNC     ??halAesEncrDecr_11
   \   0000A8   43B301       ORL     0xb3,#0x1
   \   0000AB   85....       MOV     ?V0 + 4,?V0 + 0
   \   0000AE   85....       MOV     ?V0 + 5,?V0 + 1
   \   0000B1   7404         MOV     A,#0x4
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?S_SHL
   \   0000B8   A8..         MOV     R0,?V0 + 4
   \   0000BA   A9..         MOV     R1,?V0 + 5
   \   0000BC   7410         MOV     A,#0x10
   \   0000BE   65..         XRL     A,?V0 + 7
   \   0000C0   60CF         JZ      ??halAesEncrDecr_10
   \   0000C2   7420         MOV     A,#0x20
   \   0000C4   65..         XRL     A,?V0 + 7
   \   0000C6   60C9         JZ      ??halAesEncrDecr_10
   \   0000C8   7430         MOV     A,#0x30
   \   0000CA   65..         XRL     A,?V0 + 7
   \   0000CC   60C3         JZ      ??halAesEncrDecr_10
   \   0000CE   7450         MOV     A,#0x50
   \   0000D0   65..         XRL     A,?V0 + 7
   \   0000D2   60BD         JZ      ??halAesEncrDecr_10
   \   0000D4   75..00       MOV     ?V0 + 9,#0x0
   \                     ??halAesEncrDecr_7:
   \   0000D7   12....       LCALL   ?Subroutine8
   1077                }
   1078             }
   \                     ??CrossCallReturnLabel_10:
   \   0000DA   C3           CLR     C
   \   0000DB   E5..         MOV     A,?V0 + 4
   \   0000DD   9C           SUBB    A,R4
   \   0000DE   E5..         MOV     A,?V0 + 5
   \   0000E0   9D           SUBB    A,R5
   \   0000E1   4003         JC      $+5
   \   0000E3   02....       LJMP    ??halAesEncrDecr_5
   \   0000E6   EA           MOV     A,R2
   \   0000E7   25..         ADD     A,?V0 + 4
   \   0000E9   F582         MOV     DPL,A
   \   0000EB   EB           MOV     A,R3
   \   0000EC   35..         ADDC    A,?V0 + 5
   \   0000EE   F583         MOV     DPH,A
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   02....       LJMP    ??halAesEncrDecr_6
   1079          }
   \                     ??halAesEncrDecr_11:
   \   0000F4   7F0A         MOV     R7,#0xa
   \   0000F6   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   0000F9                REQUIRE ENCCS
   \   0000F9                REQUIRE ENCDI
   \   0000F9                REQUIRE ENCDO

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   85....       MOV     ?V0 + 4,?V0 + 9
   \   000003   E8           MOV     A,R0
   \   000004   25..         ADD     A,?V0 + 4
   \   000006   F5..         MOV     ?V0 + 4,A
   \   000008   E9           MOV     A,R1
   \   000009   3400         ADDC    A,#0x0
   \   00000B   F5..         MOV     ?V0 + 5,A
   \   00000D   22           RET
   1080          
   1081          
   1082          
   1083          
   1084          #endif
   1085          
   1086           #ifdef _USER_OAD_FLASH_WRITE_

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1087          static void dl2rc(void)
   \                     ??dl2rc:
   1088          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1089            preamble_t preamble;
   1090            uint32 oset;
   1091            //uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;				//0x0800/4		user code start address
   1092            uint16 addr = HAL_OAD_CODE_START / HAL_FLASH_WORD_SIZE;
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   7F08         MOV     R7,#0x8
   1093            uint8 buf[4];
   1094          
   1095            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
   \   00000E                ; Setup parameters for call to function HalOADRead
   \   00000E   75..0C       MOV     ?V0 + 0,#0xc
   \   000011   8E..         MOV     ?V0 + 1,R6
   \   000013   78..         MOV     R0,#?V0 + 0
   \   000015   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000018   7406         MOV     A,#0x6
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   8582..       MOV     ?V0 + 0,DPL
   \   000020   8583..       MOV     ?V0 + 1,DPH
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7901         MOV     R1,#0x1
   \   00002A   90....       MOV     DPTR,#__Constant_8c
   \   00002D   12....       LCALL   ?XLOAD_R2345
   \   000030   12....       LCALL   ??Subroutine14_0
   \                     ??CrossCallReturnLabel_23:
   \   000033   12....       LCALL   ?DEALLOC_XSTACK8
   1096            //putsDialog("total len %x\r\n",preamble.len);
   1097            //SendData(preamble.len>>24);
   1098            //SendData((preamble.len>>16)&0xff);
   1099            //SendData((preamble.len>>8)&0xff);
   1100            //SendData(preamble.len&0xff);
   1101            //preamble.len = 65536;
   1102          
   1103            for (oset = 0; oset < preamble.len; oset += HAL_FLASH_WORD_SIZE)
   \   000036   90....       MOV     DPTR,#__Constant_0
   \   000039   78..         MOV     R0,#?V0 + 4
   \   00003B   12....       LCALL   ?L_MOV_X
   \   00003E   8032         SJMP    ??dl2rc_1
   1104            {
   1105              HalOADRead(oset, buf, HAL_FLASH_WORD_SIZE, HAL_OAD_DL);
   1106              if ((addr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
   1107              {
   1108                HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
   1109                HAL_TOGGLE_LED1();
   \                     ??dl2rc_2:
   \   000040   D291         SETB    0x90.1
   1110              }
   1111              HalFlashWrite(addr++, buf, 1);
   \                     ??dl2rc_3:
   \   000042                ; Setup parameters for call to function HalFlashWrite
   \   000042   75..01       MOV     ?V0 + 0,#0x1
   \   000045   75..00       MOV     ?V0 + 1,#0x0
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   7402         MOV     A,#0x2
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   AC82         MOV     R4,DPL
   \   000054   AD83         MOV     R5,DPH
   \   000056   EE           MOV     A,R6
   \   000057   FA           MOV     R2,A
   \   000058   EF           MOV     A,R7
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   HalFlashWrite
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   EE           MOV     A,R6
   \   000063   2401         ADD     A,#0x1
   \   000065   0E           INC     R6
   \   000066   EF           MOV     A,R7
   \   000067   3400         ADDC    A,#0x0
   \   000069   FF           MOV     R7,A
   \   00006A   90....       MOV     DPTR,#__Constant_4
   \   00006D   78..         MOV     R0,#?V0 + 4
   \   00006F   12....       LCALL   ?L_ADD_X
   \                     ??dl2rc_1:
   \   000072   7406         MOV     A,#0x6
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   78..         MOV     R0,#?V0 + 4
   \   000079   12....       LCALL   ?UL_GE_X
   \   00007C   4046         JC      ??dl2rc_4
   \   00007E                ; Setup parameters for call to function HalOADRead
   \   00007E   75..04       MOV     ?V0 + 0,#0x4
   \   000081   75..00       MOV     ?V0 + 1,#0x0
   \   000084   78..         MOV     R0,#?V0 + 0
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   7402         MOV     A,#0x2
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   8582..       MOV     ?V0 + 0,DPL
   \   000091   8583..       MOV     ?V0 + 1,DPH
   \   000094   78..         MOV     R0,#?V0 + 0
   \   000096   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000099   7901         MOV     R1,#0x1
   \   00009B   12....       LCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_21:
   \   00009E   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A1   EE           MOV     A,R6
   \   0000A2   F8           MOV     R0,A
   \   0000A3   EF           MOV     A,R7
   \   0000A4   5401         ANL     A,#0x1
   \   0000A6   F9           MOV     R1,A
   \   0000A7   E8           MOV     A,R0
   \   0000A8   49           ORL     A,R1
   \   0000A9   7097         JNZ     ??dl2rc_3
   \   0000AB                ; Setup parameters for call to function HalFlashErase
   \   0000AB   8E..         MOV     ?V0 + 0,R6
   \   0000AD   8F..         MOV     ?V0 + 1,R7
   \   0000AF   7409         MOV     A,#0x9
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?US_SHR
   \   0000B6   A9..         MOV     R1,?V0 + 0
   \   0000B8   12....       LCALL   HalFlashErase
   \   0000BB   A291         MOV     C,0x90.1
   \   0000BD   5081         JNC     ??dl2rc_2
   \   0000BF   C291         CLR     0x90.1
   \   0000C1   02....       LJMP    ??dl2rc_3
   1112            }
   1113            HAL_TURN_OFF_LED1();
   \                     ??dl2rc_4:
   \   0000C4   C291         CLR     0x90.1
   1114          }  
   \   0000C6   7410         MOV     A,#0x10
   \   0000C8                REQUIRE ?Subroutine2
   \   0000C8                REQUIRE _A_P1
   \   0000C8                ; // Fall through to label ?Subroutine2

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   AA..         MOV     R2,?V0 + 4
   \   000002   AB..         MOV     R3,?V0 + 5
   \   000004   AC..         MOV     R4,?V0 + 6
   \   000006   AD..         MOV     R5,?V0 + 7
   \   000008                REQUIRE ??Subroutine14_0
   \   000008                ; // Fall through to label ??Subroutine14_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine14_0:
   \   000000   12....       LCALL   HalOADRead
   \   000003   7404         MOV     A,#0x4
   \   000005   22           RET
   1115          
   1116          /*********************************************************************
   1117           * @fn      crcCalc
   1118           *
   1119           * @brief   Run the CRC16 Polynomial calculation over the RC image.
   1120           *
   1121           * @param   None.
   1122           *
   1123           * @return  The CRC16 calculated.
   1124           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1125          static uint16 crcCalc(void)
   \                     ??crcCalc:
   1126          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1127            preamble_t preamble;
   1128            uint32 oset;
   1129            uint16 crc = 0;
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   7F00         MOV     R7,#0x0
   1130            uint8 tmp;
                         ^
Warning[Pe177]: variable "tmp" was declared but never referenced
   1131          
   1132            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
   \   00000E                ; Setup parameters for call to function HalOADRead
   \   00000E   75..0C       MOV     ?V0 + 0,#0xc
   \   000011   8E..         MOV     ?V0 + 1,R6
   \   000013   78..         MOV     R0,#?V0 + 0
   \   000015   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   8582..       MOV     ?V0 + 0,DPL
   \   000020   8583..       MOV     ?V0 + 1,DPH
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7900         MOV     R1,#0x0
   \   00002A   90....       MOV     DPTR,#__Constant_8c
   \   00002D   12....       LCALL   ?XLOAD_R2345
   \   000030   12....       LCALL   ??Subroutine14_0
   \                     ??CrossCallReturnLabel_24:
   \   000033   12....       LCALL   ?DEALLOC_XSTACK8
   1133          
   1134            if(preamble.len>HAL_OAD_RC_START)
   \   000036   7403         MOV     A,#0x3
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   C082         PUSH    DPL
   \   00003D   C083         PUSH    DPH
   \   00003F   90....       MOV     DPTR,#__Constant_20001
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   12....       LCALL   ?L_MOV_X
   \   000047   D083         POP     DPH
   \   000049   D082         POP     DPL
   \   00004B   78..         MOV     R0,#?V0 + 0
   \   00004D   12....       LCALL   ?UL_GT_X
   \   000050   4007         JC      ??crcCalc_1
   1135            {
   1136          	return 0;
   \   000052   7A00         MOV     R2,#0x0
   \   000054   7B00         MOV     R3,#0x0
   \   000056   02....       LJMP    ??crcCalc_2
   1137            }
   1138          
   1139            // Run the CRC calculation over the active body of code.
   1140            for (oset = 0; oset < preamble.len; oset++)
   \                     ??crcCalc_1:
   \   000059   90....       MOV     DPTR,#__Constant_0
   \   00005C   78..         MOV     R0,#?V0 + 4
   \   00005E   12....       LCALL   ?L_MOV_X
   \   000061   800A         SJMP    ??crcCalc_3
   1141            {
   1142           #if 1
   1143              if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
   1144              {
   1145                uint8 buf;
   1146                HalOADRead(oset, &buf, 1, HAL_OAD_RC);
   1147                crc = runPoly(crc, buf);
   1148              }
   1149              if(0==(oset%HAL_FLASH_PAGE_SIZE))
   1150              {
   1151          	 HAL_TOGGLE_LED2();
   \                     ??crcCalc_4:
   \   000063   D280         SETB    0x80.0
   \                     ??crcCalc_5:
   \   000065   90....       MOV     DPTR,#__Constant_1
   \   000068   78..         MOV     R0,#?V0 + 4
   \   00006A   12....       LCALL   ?L_ADD_X
   \                     ??crcCalc_3:
   \   00006D   7403         MOV     A,#0x3
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   78..         MOV     R0,#?V0 + 4
   \   000074   12....       LCALL   ?UL_GE_X
   \   000077   4068         JC      ??crcCalc_6
   \   000079   85....       MOV     ?V0 + 0,?V0 + 4
   \   00007C   85....       MOV     ?V0 + 1,?V0 + 5
   \   00007F   85....       MOV     ?V0 + 2,?V0 + 6
   \   000082   85....       MOV     ?V0 + 3,?V0 + 7
   \   000085   90....       MOV     DPTR,#__Constant_ffffff78
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?L_ADD_X
   \   00008D   90....       MOV     DPTR,#__Constant_4
   \   000090   78..         MOV     R0,#?V0 + 0
   \   000092   12....       LCALL   ?UL_GE_X
   \   000095   5032         JNC     ??CrossCallReturnLabel_5
   \   000097                ; Setup parameters for call to function HalOADRead
   \   000097   75..01       MOV     ?V0 + 0,#0x1
   \   00009A   75..00       MOV     ?V0 + 1,#0x0
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   7402         MOV     A,#0x2
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   8582..       MOV     ?V0 + 0,DPL
   \   0000AA   8583..       MOV     ?V0 + 1,DPH
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   7900         MOV     R1,#0x0
   \   0000B4   12....       LCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_22:
   \   0000B7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BA                ; Setup parameters for call to function runPoly
   \   0000BA   85..82       MOV     DPL,?XSP + 0
   \   0000BD   85..83       MOV     DPH,?XSP + 1
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   F9           MOV     R1,A
   \   0000C2   EE           MOV     A,R6
   \   0000C3   FA           MOV     R2,A
   \   0000C4   EF           MOV     A,R7
   \   0000C5   FB           MOV     R3,A
   \   0000C6   12....       LCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_5:
   \   0000C9   85....       MOV     ?V0 + 0,?V0 + 4
   \   0000CC   85....       MOV     ?V0 + 1,?V0 + 5
   \   0000CF   E5..         MOV     A,?V0 + 1
   \   0000D1   5407         ANL     A,#0x7
   \   0000D3   F9           MOV     R1,A
   \   0000D4   E5..         MOV     A,?V0 + 0
   \   0000D6   49           ORL     A,R1
   \   0000D7   708C         JNZ     ??crcCalc_5
   \   0000D9   A280         MOV     C,0x80.0
   \   0000DB   5086         JNC     ??crcCalc_4
   \   0000DD   C280         CLR     0x80.0
   \   0000DF   8084         SJMP    ??crcCalc_5
   1152              }
   1153              //HAL_TURN_OFF_LED2();
   1154          #else
   1155          	uint8 buf;
   1156          	HalOADRead(oset, &buf, 1, HAL_OAD_RC);
   1157          	SendData(buf);
   1158          #endif
   1159          
   1160            }
   1161          
   1162            // IAR note explains that poly must be run with value zero for each byte of crc.
   1163            crc = runPoly(crc, 0);
   \                     ??crcCalc_6:
   \   0000E1                ; Setup parameters for call to function runPoly
   \   0000E1   7900         MOV     R1,#0x0
   \   0000E3   EE           MOV     A,R6
   \   0000E4   FA           MOV     R2,A
   \   0000E5   EF           MOV     A,R7
   \   0000E6   FB           MOV     R3,A
   \   0000E7   12....       LCALL   ??runPoly
   1164            crc = runPoly(crc, 0);
   \   0000EA                ; Setup parameters for call to function runPoly
   \   0000EA   7900         MOV     R1,#0x0
   \   0000EC   12....       LCALL   ?Subroutine6
   1165          
   1166            SendData(crc>>8);
   \                     ??CrossCallReturnLabel_6:
   \   0000EF                ; Setup parameters for call to function SendData
   \   0000EF   EF           MOV     A,R7
   \   0000F0   F9           MOV     R1,A
   \   0000F1   12....       LCALL   ??SendData
   1167            SendData(crc&0xff);
   \   0000F4                ; Setup parameters for call to function SendData
   \   0000F4   EE           MOV     A,R6
   \   0000F5   F9           MOV     R1,A
   \   0000F6   12....       LCALL   ??SendData
   1168          
   1169            HAL_TURN_OFF_LED2();
   \   0000F9   D280         SETB    0x80.0
   1170          
   1171            return crc;
   \   0000FB   EE           MOV     A,R6
   \   0000FC   FA           MOV     R2,A
   \   0000FD   EF           MOV     A,R7
   \   0000FE   FB           MOV     R3,A
   \                     ??crcCalc_2:
   \   0000FF   740D         MOV     A,#0xd
   \   000101   02....       LJMP    ?Subroutine2
   \   000104                REQUIRE _A_P0
   1172          }

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ??runPoly
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   AE..         MOV     R6,?V0 + 0
   \   000009   AF..         MOV     R7,?V0 + 1
   \   00000B   22           RET
   1173          #endif
   1174          //#endif
   1175          
   1176          /*********************************************************************
   1177           * @fn      runPoly
   1178           *
   1179           * @brief   Run the CRC16 Polynomial calculation over the byte parameter.
   1180           *
   1181           * @param   crc - Running CRC calculated so far.
   1182           * @param   val - Value on which to run the CRC16.
   1183           *
   1184           * @return  crc - Updated for the run.
   1185           */
   1186          #if _USER_OAD_FLASH_WRITE_

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1187          static uint16 runPoly(uint16 crc, uint8 val)
   \                     ??runPoly:
   1188          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1189            const uint16 poly = 0x1021;
   1190            uint8 cnt;
   1191          
   1192            for (cnt = 0; cnt < 8; cnt++, val <<= 1)
   \   000004   7C08         MOV     R4,#0x8
   1193            {
   1194              uint8 msb = (crc & 0x8000) ? 1 : 0;
   \                     ??runPoly_1:
   \   000006   8A..         MOV     ?V0 + 0,R2
   \   000008   8B..         MOV     ?V0 + 1,R3
   \   00000A   740F         MOV     A,#0xf
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   12....       LCALL   ?US_SHR
   1195          
   1196              crc <<= 1;
   \   000011   EA           MOV     A,R2
   \   000012   C3           CLR     C
   \   000013   33           RLC     A
   \   000014   FA           MOV     R2,A
   \   000015   EB           MOV     A,R3
   \   000016   33           RLC     A
   \   000017   FB           MOV     R3,A
   1197              if (val & 0x80)  crc |= 0x0001;
   \   000018   E9           MOV     A,R1
   \   000019   A2E7         MOV     C,0xE0 /* A   */.7
   \   00001B   5004         JNC     ??runPoly_2
   \   00001D   7401         MOV     A,#0x1
   \   00001F   4A           ORL     A,R2
   \   000020   FA           MOV     R2,A
   1198              if (msb)         crc ^= poly;
   \                     ??runPoly_2:
   \   000021   E5..         MOV     A,?V0 + 0
   \   000023   A2E0         MOV     C,0xE0 /* A   */.0
   \   000025   5008         JNC     ??runPoly_3
   \   000027   7421         MOV     A,#0x21
   \   000029   6A           XRL     A,R2
   \   00002A   FA           MOV     R2,A
   \   00002B   7410         MOV     A,#0x10
   \   00002D   6B           XRL     A,R3
   \   00002E   FB           MOV     R3,A
   1199            }
   \                     ??runPoly_3:
   \   00002F   E9           MOV     A,R1
   \   000030   C3           CLR     C
   \   000031   33           RLC     A
   \   000032   F9           MOV     R1,A
   \   000033   1C           DEC     R4
   \   000034   EC           MOV     A,R4
   \   000035   70CF         JNZ     ??runPoly_1
   1200          
   1201            return crc;
   \   000037   D0..         POP     ?V0 + 1
   \   000039   D0..         POP     ?V0 + 0
   \   00003B   22           RET
   1202          }
   1203          
   1204          /*********************************************************************
   1205           * @fn      HalOADChkDL
   1206           *
   1207           * @brief   Run the CRC16 Polynomial calculation over the DL image.
   1208           *
   1209           * @param   dlImagePreambleOffset - Offset into the monolithic DL image to read the preamble.
   1210           *
   1211           * @return  SUCCESS or FAILURE.
   1212           *********************************************************************/
   1213           #if 0
   1214          uint8 HalOADChkDL(uint8 dlImagePreambleOffset)
   1215          {
   1216            preamble_t preamble;
   1217            uint32 oset;
   1218            uint16 crc = 0, crc2;
   1219          
   1220            HalOADRead(dlImagePreambleOffset, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
   1221          
   1222            // Run the CRC calculation over the downloaded image.
   1223            for (oset = 0; oset < preamble.len; oset++)
   1224            {
   1225              if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
   1226              {
   1227                uint8 buf;
   1228                HalOADRead(oset, &buf, 1, HAL_OAD_DL);
   1229                crc = runPoly(crc, buf);
   1230              }
   1231            }
   1232          
   1233            // IAR note explains that poly must be run with value zero for each byte of crc.
   1234            crc = runPoly(crc, 0);
   1235            crc = runPoly(crc, 0);
   1236          
   1237            HalOADRead(HAL_OAD_CRC_OSET, (uint8 *)&crc2, sizeof(crc2), HAL_OAD_DL);
   1238            return (crc2 == crc) ? SUCCESS : FAILURE;
   1239          }
   1240           #endif
   1241          
   1242          /*********************************************************************
   1243           * @fn      HalOADInvRC
   1244           *
   1245           * @brief   Invalidate the active image so that the boot code will instantiate the DL image on the
   1246           *          next reset.
   1247           *
   1248           * @param   None.
   1249           *
   1250           * @return  None.
   1251           *********************************************************************/
   1252          void HalOADInvRC(void)
   1253          {
   1254            uint16 crc[2] = {0,0xFFFF};
   1255            HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
   1256          }
   1257          
   1258          /*********************************************************************
   1259           * @fn      HalOADRead
   1260           *
   1261           * @brief   Read from the storage medium according to image type.
   1262           *
   1263           * @param   oset - Offset into the monolithic image.
   1264           * @param   pBuf - Pointer to the buffer in which to copy the bytes read.
   1265           * @param   len - Number of bytes to read.
   1266           * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
   1267           *
   1268           * @return  None.
   1269           *********************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   1270          void HalOADRead(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
                                                                               ^
Remark[Pe826]: parameter "type" was never referenced

  static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len);
              ^
"C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_oad.c",174  Warning[Pe177]: 
          function "HalSPIRead" was declared but never referenced
   \                     HalOADRead:
   1271          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   740D         MOV     A,#0xd
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FC           MOV     R4,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FD           MOV     R5,A
   \   000017   740F         MOV     A,#0xf
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 4,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 5,A
   1272          #if 0
   1273            if (HAL_OAD_RC != type)
   1274            {
   1275          #if HAL_OAD_XNV_IS_INT
   1276              preamble_t preamble;
   1277          
   1278              HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
   1279              //oset += HAL_OAD_RC_START + preamble.len;
   1280              oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
   1281          #elif HAL_OAD_XNV_IS_SPI
   1282              oset += HAL_OAD_DL_OSET;
   1283              HalSPIRead(oset, pBuf, len);
   1284              return;
   1285          #endif
   1286            }
   1287            else
   1288            {
   1289              oset += HAL_OAD_RC_START;
   1290            }
   1291           #endif
   1292          
   1293            oset += HAL_OAD_RC_START;
   \   000023   90....       MOV     DPTR,#__Constant_20000
   \   000026   78..         MOV     R0,#?V0 + 0
   \   000028   12....       LCALL   ?L_ADD_X
   1294            HalFlashRead(oset / HAL_FLASH_PAGE_SIZE, oset % HAL_FLASH_PAGE_SIZE, pBuf, len);
   \   00002B                ; Setup parameters for call to function HalFlashRead
   \   00002B   78..         MOV     R0,#?V0 + 4
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   85....       MOV     ?V0 + 4,?V0 + 0
   \   000033   85....       MOV     ?V0 + 5,?V0 + 1
   \   000036   AA..         MOV     R2,?V0 + 4
   \   000038   E5..         MOV     A,?V0 + 5
   \   00003A   5407         ANL     A,#0x7
   \   00003C   FB           MOV     R3,A
   \   00003D   740B         MOV     A,#0xb
   \   00003F   78..         MOV     R0,#?V0 + 0
   \   000041   12....       LCALL   ?UL_SHR
   \   000044   A9..         MOV     R1,?V0 + 0
   \   000046   12....       LCALL   HalFlashRead
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   1295          }
   \   00004E   7F06         MOV     R7,#0x6
   \   000050   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "WorkForYourDream"`:
   \   000000   576F726B     DB "WorkForYourDream"
   \            466F7259
   \            6F757244
   \            7265616D
   \            00      

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "Initial\\r\\n">>`:
   \   000000   496E6974     DB "Initial\015\012"
   \            69616C0D
   \            0A00    

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "Verified Error">>`:
   \   000000   56657269     DB "Verified Error"
   \            66696564
   \            20457272
   \            6F7200  

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "Start\\r\\n">>`:
   \   000000   53746172     DB "Start\015\012"
   \            740D0A00

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_3a4d3254>`:
   \   000000   54324D3A     DD 978137684

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_f8900a6>`:
   \   000000   A600890F     DD 260636838

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_8c>`:
   \   000000   8C000000     DD 140

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_4>`:
   \   000000   04000000     DD 4

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_20001>`:
   \   000000   01000200     DD 131073

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_1>`:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffffff78>`:
   \   000000   78FFFFFF     DD 4294967160

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_20000>`:
   \   000000   00000200     DD 131072

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "WorkForYourDream">`:
   \   000000                DS 17
   \   000011                REQUIRE `?<Initializer for <Constant "WorkForYourDream"`
   \   000011                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "Initial\\r\\n">`:
   \   000000                DS 10
   \   00000A                REQUIRE `?<Initializer for <Constant "Initial\\r\\n">>`
   \   00000A                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "Verified Error">`:
   \   000000                DS 15
   \   00000F                REQUIRE `?<Initializer for <Constant "Verified Error">>`
   \   00000F                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "Start\\r\\n">`:
   \   000000                DS 8
   \   000008                REQUIRE `?<Initializer for <Constant "Start\\r\\n">>`
   \   000008                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_3a4d3254:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_3a4d3254>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_f8900a6:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_f8900a6>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_8c:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_8c>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_4:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_4>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_20001:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_20001>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_1:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_1>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffffff78:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffffff78>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_20000:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_20000>`
   \   000004                REQUIRE __INIT_XDATA_I
   1296          
   1297          /*********************************************************************
   1298           * @fn      HalOADWrite
   1299           *
   1300           * @brief   Write to the storage medium according to the image type.
   1301           *
   1302           *  NOTE:   Destructive write on page boundary! When writing to the first flash word
   1303           *          of a page boundary, the page is erased without saving/restoring the bytes not written.
   1304           *          Writes anywhere else on a page assume that the location written to has been erased.
   1305           *
   1306           * @param   oset - Offset into the monolithic image, aligned to HAL_FLASH_WORD_SIZE.
   1307           * @param   pBuf - Pointer to the buffer in from which to write.
   1308           * @param   len - Number of bytes to write. If not an even multiple of HAL_FLASH_WORD_SIZE,
   1309           *                remainder bytes are overwritten with garbage.
   1310           * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
   1311           *
   1312           * @return  None.
   1313           *********************************************************************/
   1314          void HalOADWrite(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
   1315          {
   1316            if (HAL_OAD_RC != type)
   1317            {
   1318          #if HAL_OAD_XNV_IS_INT
   1319              preamble_t preamble;
   1320          
   1321              HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
   1322              //oset += HAL_OAD_RC_START + preamble.len;
   1323              oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
   1324          #elif HAL_OAD_XNV_IS_SPI
   1325              oset += HAL_OAD_DL_OSET;
   1326              HalSPIWrite(oset, pBuf, len);
   1327              return;
   1328          #endif
   1329            }
   1330            else
   1331            {
   1332              oset += HAL_OAD_RC_START;
   1333            }
   1334          
   1335            if ((oset % HAL_FLASH_PAGE_SIZE) == 0)
   1336            {
   1337              HalFlashErase(oset / HAL_FLASH_PAGE_SIZE);
   1338            }
   1339          
   1340            HalFlashWrite(oset / HAL_FLASH_WORD_SIZE, pBuf, len / HAL_FLASH_WORD_SIZE);
   1341          }
   1342          
   1343          #if HAL_OAD_XNV_IS_INT
   1344          /*********************************************************************
   1345           * @fn      HalOADAvail
   1346           *
   1347           * @brief   Determine the space available for downloading an image.
   1348           *
   1349           * @param   None.
   1350           *
   1351           * @return  Number of bytes available for storing an OAD image.
   1352           *********************************************************************/
   1353          uint32 HalOADAvail(void)
   1354          {
   1355            /*
   1356            preamble_t preamble;
   1357          
   1358            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
   1359            return HAL_OAD_DL_MAX - preamble.len;
   1360             */
   1361            return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
   1362          }
   1363          
   1364          #elif HAL_OAD_XNV_IS_SPI
   1365          
   1366          /*********************************************************************
   1367           * CONSTANTS
   1368           */
   1369          
   1370          #define XNV_STAT_CMD  0x05
   1371          #define XNV_WREN_CMD  0x06
   1372          #define XNV_WRPG_CMD  0x0A
   1373          #define XNV_READ_CMD  0x0B
   1374          
   1375          #define XNV_STAT_WIP  0x01
   1376          
   1377          /*********************************************************************
   1378           * @fn      xnvSPIWrite
   1379           *
   1380           * @brief   SPI write sequence for code size savings.
   1381           *
   1382           * @param   ch - The byte to write to the SPI.
   1383           *
   1384           * @return  None.
   1385           *********************************************************************/
   1386          static void xnvSPIWrite(uint8 ch);
   1387          static void xnvSPIWrite(uint8 ch)
   1388          {
   1389            XNV_SPI_TX(ch);
   1390            XNV_SPI_WAIT_RXRDY();
   1391          }
   1392          
   1393          /*********************************************************************
   1394           * @fn      HalOADAvail
   1395           *
   1396           * @brief   Determine the space available for downloading an image.
   1397           *
   1398           * @param   None.
   1399           *
   1400           * @return  Number of bytes available for storing an OAD image.
   1401           *********************************************************************/
   1402          uint32 HalOADAvail(void)
   1403          {
   1404            return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
   1405          }
   1406          
   1407          /*********************************************************************
   1408           * @fn      HalSPIRead
   1409           *
   1410           * @brief   Read from the external NV storage via SPI.
   1411           *
   1412           * @param   addr - Offset into the external NV.
   1413           * @param   pBuf - Pointer to the buffer in which to copy the bytes read from external NV.
   1414           * @param   len - Number of bytes to read from external NV.
   1415           *
   1416           * @return  None.
   1417           *********************************************************************/
   1418           #if 0
   1419          static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len)
   1420          {
   1421          #if !HAL_OAD_BOOT_CODE
   1422            uint8 shdw = P1DIR;
   1423            halIntState_t his;
   1424            HAL_ENTER_CRITICAL_SECTION(his);
   1425            P1DIR |= BV(3);
   1426          #endif
   1427          
   1428            XNV_SPI_BEGIN();
   1429            do {
   1430              xnvSPIWrite(XNV_STAT_CMD);
   1431            } while (XNV_SPI_RX() & XNV_STAT_WIP);
   1432            XNV_SPI_END();
   1433            asm("NOP"); asm("NOP");
   1434          
   1435            XNV_SPI_BEGIN();
   1436            xnvSPIWrite(XNV_READ_CMD);
   1437            xnvSPIWrite(addr >> 16);
   1438            xnvSPIWrite(addr >> 8);
   1439            xnvSPIWrite(addr);
   1440            xnvSPIWrite(0);
   1441          
   1442            while (len--)
   1443            {
   1444              xnvSPIWrite(0);
   1445              *pBuf++ = XNV_SPI_RX();
   1446            }
   1447            XNV_SPI_END();
   1448          
   1449          #if !HAL_OAD_BOOT_CODE
   1450            P1DIR = shdw;
   1451            HAL_EXIT_CRITICAL_SECTION(his);
   1452          #endif
   1453          }
   1454           #endif
   1455          
   1456          /*********************************************************************
   1457           * @fn      HalSPIWrite
   1458           *
   1459           * @brief   Write to the external NV storage via SPI.
   1460           *
   1461           * @param   addr - Offset into the external NV.
   1462           * @param   pBuf - Pointer to the buffer in from which to write bytes to external NV.
   1463           * @param   len - Number of bytes to write to external NV.
   1464           *
   1465           * @return  None.
   1466           *********************************************************************/
   1467          static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len)
   1468          {
   1469            uint8 cnt;
   1470          #if !HAL_OAD_BOOT_CODE
   1471            uint8 shdw = P1DIR;
   1472            halIntState_t his;
   1473            HAL_ENTER_CRITICAL_SECTION(his);
   1474            P1DIR |= BV(3);
   1475          #endif
   1476          
   1477            while (len)
   1478            {
   1479              XNV_SPI_BEGIN();
   1480              do {
   1481                xnvSPIWrite(XNV_STAT_CMD);
   1482              } while (XNV_SPI_RX() & XNV_STAT_WIP);
   1483              XNV_SPI_END();
   1484              asm("NOP"); asm("NOP");
   1485          
   1486              XNV_SPI_BEGIN();
   1487              xnvSPIWrite(XNV_WREN_CMD);
   1488              XNV_SPI_END();
   1489              asm("NOP"); asm("NOP");
   1490          
   1491              XNV_SPI_BEGIN();
   1492              xnvSPIWrite(XNV_WRPG_CMD);
   1493              xnvSPIWrite(addr >> 16);
   1494              xnvSPIWrite(addr >> 8);
   1495              xnvSPIWrite(addr);
   1496          
   1497              // Can only write within any one page boundary, so prepare for next page write if bytes remain.
   1498              cnt = 0 - (uint8)addr;
   1499              if (cnt)
   1500              {
   1501                addr += cnt;
   1502              }
   1503              else
   1504              {
   1505                addr += 256;
   1506              }
   1507          
   1508              do
   1509              {
   1510                xnvSPIWrite(*pBuf++);
   1511                cnt--;
   1512                len--;
   1513              } while (len && cnt);
   1514              XNV_SPI_END();
   1515            }
   1516          
   1517          #if !HAL_OAD_BOOT_CODE
   1518            P1DIR = shdw;
   1519            HAL_EXIT_CRITICAL_SECTION(his);
   1520          #endif
   1521          }
   1522          #else
   1523          #error Invalid Xtra-NV for OAD.
   1524          #endif
   1525          
   1526          #endif
   1527          
   1528          /**************************************************************************************************
   1529          */
C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart.c
      3            Revised:        $Date: 2009-06-12 09:16:43 -0700 (Fri, 12 Jun 2009) $
      4            Revision:       $Revision: 20142 $
      5          
      6            Description: This file contains the interface to the H/W UART driver.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_board_cfg.h"
     45          #include "hal_defs.h"
     46          #include "hal_types.h"
     47          #include "hal_uart.h"
     48          
     49          /*********************************************************************
     50           * MACROS
     51           */
     52          
     53          /*********************************************************************
     54           * TYPEDEFS
     55           */
     56          
     57          /*********************************************************************
     58           * CONSTANTS
     59           */
     60          
     61          /*********************************************************************
     62           * GLOBAL VARIABLES
     63           */
     64          
     65          /*********************************************************************
     66           * GLOBAL FUNCTIONS
     67           */
     68          
     69          /*********************************************************************
     70           * LOCAL VARIABLES
     71           */
     72          
     73          /*********************************************************************
     74           * LOCAL FUNCTIONS
     75           */
     76          
     77          #if HAL_UART_DMA
     78          #include "_hal_uart_dma.c"
     79          #endif
     80          #if HAL_UART_ISR
     81          #include "_hal_uart_isr.c"
     82          #endif
     83          #if HAL_UART_USB
     84          #include "_hal_uart_usb.c"
     85          #endif
     86          
     87          /******************************************************************************
     88           * @fn      HalUARTInit
     89           *
     90           * @brief   Initialize the UART
     91           *
     92           * @param   none
     93           *
     94           * @return  none
     95           *****************************************************************************/
     96          void HalUARTInit(void)
     97          {
     98          #if HAL_UART_DMA
     99            HalUARTInitDMA();
    100          #endif
    101          #if HAL_UART_ISR
    102            HalUARTInitISR();
    103          #endif
    104          #if HAL_UART_USB
    105            HalUARTInitUSB();
    106          #endif
    107          }
    108          
    109          /******************************************************************************
    110           * @fn      HalUARTOpen
    111           *
    112           * @brief   Open a port according tp the configuration specified by parameter.
    113           *
    114           * @param   port   - UART port
    115           *          config - contains configuration information
    116           *
    117           * @return  Status of the function call
    118           *****************************************************************************/
    119          uint8 HalUARTOpen(uint8 port, halUARTCfg_t *config)
    120          {
    121            (void)port;
    122            (void)config;
    123          
    124          #if (HAL_UART_DMA == 1)
    125            if (port == HAL_UART_PORT_0)  HalUARTOpenDMA(config);
    126          #endif
    127          #if (HAL_UART_DMA == 2)
    128            if (port == HAL_UART_PORT_1)  HalUARTOpenDMA(config);
    129          #endif
    130          #if (HAL_UART_ISR == 1)
    131            if (port == HAL_UART_PORT_0)  HalUARTOpenISR(config);
    132          #endif
    133          #if (HAL_UART_ISR == 2)
    134            if (port == HAL_UART_PORT_1)  HalUARTOpenISR(config);
    135          #endif
    136          #if (HAL_UART_USB)
    137            HalUARTOpenUSB(config);
    138          #endif
    139            
    140            return HAL_UART_SUCCESS;
    141          }
    142          
    143          /*****************************************************************************
    144           * @fn      HalUARTRead
    145           *
    146           * @brief   Read a buffer from the UART
    147           *
    148           * @param   port - USART module designation
    149           *          buf  - valid data buffer at least 'len' bytes in size
    150           *          len  - max length number of bytes to copy to 'buf'
    151           *
    152           * @return  length of buffer that was read
    153           *****************************************************************************/
    154          uint16 HalUARTRead(uint8 port, uint8 *buf, uint16 len)
    155          {
    156            (void)port;
    157            (void)buf;
    158            (void)len;
    159          
    160          #if (HAL_UART_DMA == 1)
    161            if (port == HAL_UART_PORT_0)  return HalUARTReadDMA(buf, len);
    162          #endif
    163          #if (HAL_UART_DMA == 2)
    164            if (port == HAL_UART_PORT_1)  return HalUARTReadDMA(buf, len);
    165          #endif
    166          #if (HAL_UART_ISR == 1)
    167            if (port == HAL_UART_PORT_0)  return HalUARTReadISR(buf, len);
    168          #endif
    169          #if (HAL_UART_ISR == 2)
    170            if (port == HAL_UART_PORT_1)  return HalUARTReadISR(buf, len);
    171          #endif
    172          
    173          #if HAL_UART_USB
    174            return HalUARTRx(buf, len);
    175          #else
    176            return 0;
    177          #endif
    178          }
    179          
    180          /******************************************************************************
    181           * @fn      HalUARTWrite
    182           *
    183           * @brief   Write a buffer to the UART.
    184           *
    185           * @param   port - UART port
    186           *          buf  - pointer to the buffer that will be written, not freed
    187           *          len  - length of
    188           *
    189           * @return  length of the buffer that was sent
    190           *****************************************************************************/
    191          uint16 HalUARTWrite(uint8 port, uint8 *buf, uint16 len)
    192          {
    193            (void)port;
    194            (void)buf;
    195            (void)len;
    196          
    197          #if (HAL_UART_DMA == 1)
    198            if (port == HAL_UART_PORT_0)  return HalUARTWriteDMA(buf, len);
    199          #endif
    200          #if (HAL_UART_DMA == 2)
    201            if (port == HAL_UART_PORT_1)  return HalUARTWriteDMA(buf, len);
    202          #endif
    203          #if (HAL_UART_ISR == 1)
    204            if (port == HAL_UART_PORT_0)  return HalUARTWriteISR(buf, len);
    205          #endif
    206          #if (HAL_UART_ISR == 2)
    207            if (port == HAL_UART_PORT_1)  return HalUARTWriteISR(buf, len);
    208          #endif
    209          
    210          #if HAL_UART_USB
    211            HalUARTTx(buf, len);
    212            return len;
    213          #else
    214            return 0;
    215          #endif
    216          }
    217          
    218          /******************************************************************************
    219           * @fn      HalUARTSuspend
    220           *
    221           * @brief   Suspend UART hardware before entering PM mode 1, 2 or 3.
    222           *
    223           * @param   None
    224           *
    225           * @return  None
    226           *****************************************************************************/
    227          void HalUARTSuspend( void )
    228          {
    229          #if HAL_UART_DMA
    230            HalUARTSuspendDMA();
    231          #endif
    232          #if HAL_UART_ISR
    233            HalUARTSuspendISR();
    234          #endif
    235          }
    236          
    237          /******************************************************************************
    238           * @fn      HalUARTResume
    239           *
    240           * @brief   Resume UART hardware after exiting PM mode 1, 2 or 3.
    241           *
    242           * @param   None
    243           *
    244           * @return  None
    245           *****************************************************************************/
    246          void HalUARTResume( void )
    247          {
    248          #if HAL_UART_DMA
    249            HalUARTResumeDMA();
    250          #endif
    251          #if HAL_UART_ISR
    252            HalUARTResumeISR();
    253          #endif
    254          }
    255          
    256          /***************************************************************************************************
    257           * @fn      HalUARTPoll
    258           *
    259           * @brief   Poll the UART.
    260           *
    261           * @param   none
    262           *
    263           * @return  none
    264           *****************************************************************************/
    265          void HalUARTPoll(void)
    266          {
    267          #if HAL_UART_DMA
    268            HalUARTPollDMA();
    269          #endif
    270          #if HAL_UART_ISR
    271            HalUARTPollISR();
    272          #endif
    273          #if HAL_UART_USB
    274            HalUARTPollUSB();
    275          #endif
    276          }
    277          
    278          /**************************************************************************************************
    279           * @fn      Hal_UART_RxBufLen()
    280           *
    281           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    282           *
    283           * @param   port - UART port
    284           *
    285           * @return  length of current Rx Buffer
    286           **************************************************************************************************/
    287          uint16 Hal_UART_RxBufLen( uint8 port )
    288          {
    289            (void)port;
    290          
    291          #if (HAL_UART_DMA == 1)
    292            if (port == HAL_UART_PORT_0)  return HalUARTRxAvailDMA();
    293          #endif
    294          #if (HAL_UART_DMA == 2)
    295            if (port == HAL_UART_PORT_1)  return HalUARTRxAvailDMA();
    296          #endif
    297          #if (HAL_UART_ISR == 1)
    298            if (port == HAL_UART_PORT_0)  return HalUARTRxAvailISR();
    299          #endif
    300          #if (HAL_UART_ISR == 2)
    301            if (port == HAL_UART_PORT_1)  return HalUARTRxAvailISR();
    302          #endif
    303          #if HAL_UART_USB
    304            return HalUARTRxAvailUSB();
    305          #else
    306            return 0;
    307          #endif
    308          }
    309          
    310          /******************************************************************************
    311          ******************************************************************************/

   Maximum stack usage in bytes:

     Function                  ISTACK PSTACK XSTACK
     --------                  ------ ------ ------
     HalFlashErase                 2      0     31
     HalFlashRead                  1      0     33
     HalFlashWrite                 0      0     42
       -> HalFlashWriteTrigger     0      0     18
     HalFlashWriteTrigger          2      0      9
     HalOADRead                    0      0     50
       -> HalFlashRead             0      0     30
     MemReadRam                    3      0     20
     Message_Rcv                   1      0     29
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
     Message_Send                  0      0     29
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
     RcvData                       2      0      9
     SendData                      0      0     28
     crcCalc                       2      0     52
       -> HalOADRead               0      0     64
       -> HalOADRead               0      0     64
       -> runPoly                  0      0     56
       -> runPoly                  0      0     56
       -> runPoly                  0      0     56
       -> SendData                 0      0     56
       -> SendData                 0      0     56
     dl2rc                         0      0     55
       -> HalOADRead               0      0     70
       -> HalFlashWrite            0      0     66
       -> HalOADRead               0      0     70
       -> HalFlashErase            0      0     62
     halAesEncrDecr                1      0     39
     main                          2      0     22
       -> HalFlashRead             0      0     44
       -> HalFlashRead             0      0     44
       -> halAesEncrDecr           0      0     44
       -> putsDialog               0      0     40
       -> MemReadRam               0      0     40
       -> halAesEncrDecr           0      0     44
       -> HalFlashErase            0      0     40
       -> HalFlashWrite            0      0     44
       -> HalFlashRead             0      0     44
       -> SendData                 0      0     40
       -> SendData                 0      0     40
       -> crcCalc                  0      0     40
       -> dl2rc                    0      0     40
       -> HalFlashErase            0      0     40
       -> HalFlashWrite            0      0     44
       -> MemReadRam               0      0     40
       -> putsDialog               0      0     40
       -> putsDialog               0      0     40
       -> putsDialog               0      0     40
       -> halAesEncrDecr           0      0     44
       -> HalFlashErase            0      0     40
       -> HalFlashWrite            0      0     44
       -> Message_Send             0      0     40
       -> Message_Rcv              0      0     40
       -> Message_Send             0      0     40
       -> HalFlashErase            0      0     40
       -> HalFlashWrite            0      0     44
     putsDialog                    2      0     20
       -> SendData                 4      0      0
     runPoly                       2      0     28


   Segment part sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     _A_P0                                             1
     U0CSR                                             1
     _A_TCON                                           1
     _A_P1                                             1
     SLEEPSTA                                          1
     CLKCONSTA                                         1
     ENCDI                                             1
     ENCDO                                             1
     ENCCS                                             1
     SLEEPCMD                                          1
     U0DBUF                                            1
     U0BAUD                                            1
     U0GCR                                             1
     CLKCONCMD                                         1
     MEMCTR                                            1
     DMAIRQ                                            1
     DMA0CFGL                                          1
     DMA0CFGH                                          1
     DMAARM                                            1
     _A_IRCON2                                         1
     PERCFG                                            1
     P0SEL                                             1
     P0DIR                                             1
     P1DIR                                             1
     ramCode                                          29
     HalFlashRead                                    119
     HalFlashWrite                                    86
     ?Subroutine0                                      5
     HalFlashErase                                    20
     ?Subroutine1                                      5
     HalFlashWriteTrigger                             27
     dmaCh0                                            8
     main                                            878
     MemReadRam                                       40
     SendData                                          9
     putsDialog                                       18
     RcvData                                          45
     Message_Rcv                                     123
     ?Subroutine7                                      4
     ?Subroutine3                                      3
     ??Subroutine13_0                                  5
     ?Subroutine11                                    10
     ?Subroutine10                                     7
     Message_Send                                    101
     ?Subroutine5                                      6
     ?Subroutine4                                     10
     ?Subroutine12                                     9
     halAesEncrDecr                                  249
     ?Subroutine8                                     14
     dl2rc                                           200
     ?Subroutine2                                      8
     ?Subroutine9                                      8
     ??Subroutine14_0                                  6
     crcCalc                                         260
     ?Subroutine6                                     12
     runPoly                                          60
     HalOADRead                                       83
     ?<Initializer for <Constant "WorkForYourDream"   17
     ?<Initializer for <Constant "Initial\r\n">>      10
     ?<Initializer for <Constant "Verified Error">>   15
     ?<Initializer for <Constant "Start\r\n">>         8
     ?<Initializer for __Constant_3a4d3254>            4
     ?<Initializer for __Constant_f8900a6>             4
     ?<Initializer for __Constant_8c>                  4
     ?<Initializer for __Constant_0>                   4
     ?<Initializer for __Constant_4>                   4
     ?<Initializer for __Constant_20001>               4
     ?<Initializer for __Constant_1>                   4
     ?<Initializer for __Constant_ffffff78>            4
     ?<Initializer for __Constant_20000>               4
     ?<Constant "WorkForYourDream">                   17
     ?<Constant "Initial\r\n">                        10
     ?<Constant "Verified Error">                     15
     ?<Constant "Start\r\n">                           8
     __Constant_3a4d3254                               4
     __Constant_f8900a6                                4
     __Constant_8c                                     4
     __Constant_0                                      4
     __Constant_4                                      4
     __Constant_20001                                  4
     __Constant_1                                      4
     __Constant_ffffff78                               4
     __Constant_20000                                  4

 
 2 403 bytes in segment NEAR_CODE
    27 bytes in segment RAM_CODE_FLASH
    29 bytes in segment RAM_CODE_XDATA
    24 bytes in segment SFR_AN
    86 bytes in segment XDATA_I
    86 bytes in segment XDATA_ID
     8 bytes in segment XDATA_Z
 
 2 480 bytes of CODE  memory (+ 36 bytes shared)
     0 bytes of DATA  memory (+ 24 bytes shared)
    87 bytes of XDATA memory (+ 36 bytes shared)

Errors: none
Warnings: 7
