###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.4.40412/W32 for 8051         19/Jun/2016  18:16:08 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\freeman\Documents\work\SN\module\Componen #
#                          ts\hal\target\CC2530EB\hal_key.c                   #
#    Command line       =  -f "C:\Users\freeman\Documents\work\SN\module\Proj #
#                          ects\zstack\Samples\SampleApp                      #
#                          com\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg #
#                          " (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR    #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF0                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          C:\Users\freeman\Documents\work\SN\module\Componen #
#                          ts\hal\target\CC2530EB\hal_key.c -D ZIGBEEPRO -D   #
#                          ZTOOL_P1 -lC "C:\Users\freeman\Documents\work\SN\m #
#                          odule\Projects\zstack\Samples\SampleApp            #
#                          com\CC2530DB\CoordinatorEB-Pro\List\" -lA          #
#                          "C:\Users\freeman\Documents\work\SN\module\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\CoordinatorEB-Pro\List\"              #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "C:\Users\freeman\Documents\work\SN\module\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\CoordinatorEB-Pro\Obj\" -e --debug    #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Users\freeman\Document #
#                          s\work\SN\module\Projects\zstack\Samples\SampleApp #
#                           com\CC2530DB\" -I "C:\Users\freeman\Documents\wor #
#                          k\SN\module\Projects\zstack\Samples\SampleApp      #
#                          com\CC2530DB\..\SOURCE\" -I                        #
#                          "C:\Users\freeman\Documents\work\SN\module\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I          #
#                          "C:\Users\freeman\Documents\work\SN\module\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I     #
#                          "C:\Users\freeman\Documents\work\SN\module\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE #
#                          \" -I "C:\Users\freeman\Documents\work\SN\module\P #
#                          rojects\zstack\Samples\SampleApp                   #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\ #
#                          CC2530EB\" -I "C:\Users\freeman\Documents\work\SN\ #
#                          module\Projects\zstack\Samples\SampleApp           #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CC #
#                          SOC\" -I "C:\Users\freeman\Documents\work\SN\modul #
#                          e\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUD #
#                          E\" -I "C:\Users\freeman\Documents\work\SN\module\ #
#                          Projects\zstack\Samples\SampleApp                  #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\"  #
#                          -I "C:\Users\freeman\Documents\work\SN\module\Proj #
#                          ects\zstack\Samples\SampleApp                      #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\" #
#                           -I "C:\Users\freeman\Documents\work\SN\module\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\" #
#                           -I "C:\Users\freeman\Documents\work\SN\module\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ #
#                          " -I "C:\Users\freeman\Documents\work\SN\module\Pr #
#                          ojects\zstack\Samples\SampleApp                    #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\" #
#                           -I "C:\Users\freeman\Documents\work\SN\module\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\" #
#                           -I "C:\Users\freeman\Documents\work\SN\module\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"  #
#                          -I "C:\Users\freeman\Documents\work\SN\module\Proj #
#                          ects\zstack\Samples\SampleApp                      #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I   #
#                          "C:\Users\freeman\Documents\work\SN\module\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SA #
#                          DDR\" -I "C:\Users\freeman\Documents\work\SN\modul #
#                          e\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SD #
#                          ATA\" -I "C:\Users\freeman\Documents\work\SN\modul #
#                          e\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE #
#                          \" -I "C:\Users\freeman\Documents\work\SN\module\P #
#                          rojects\zstack\Samples\SampleApp                   #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LE #
#                          VEL\" -I "C:\Users\freeman\Documents\work\SN\modul #
#                          e\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\" -I "C:\Users\freeman\Documents\work\SN\ #
#                          module\Projects\zstack\Samples\SampleApp           #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\SINGLE_CHIP\" -I                          #
#                          "C:\Users\freeman\Documents\work\SN\module\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\usb\library #
#                          \" -I "C:\Users\freeman\Documents\work\SN\module\P #
#                          rojects\zstack\Samples\SampleApp                   #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\usb\class_h #
#                          id\" -I "C:\Users\freeman\Documents\work\SN\module #
#                          \Projects\zstack\Samples\SampleApp                 #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\hal\common\ #
#                          " -Ohz --require_prototypes                        #
#    List file          =  C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Samples\SampleApp                          #
#                          com\CC2530DB\CoordinatorEB-Pro\List\hal_key.lst    #
#    Object file        =  C:\Users\freeman\Documents\work\SN\module\Projects #
#                          \zstack\Samples\SampleApp                          #
#                          com\CC2530DB\CoordinatorEB-Pro\Obj\hal_key.r51     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\freeman\Documents\work\SN\module\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2009-12-16 17:44:49 -0800 (Wed, 16 Dec 2009) $
      4            Revision:       $Revision: 21351 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_board.h"
     87          #include "hal_drivers.h"
     88          #include "hal_adc.h"
     89          #include "hal_key.h"
     90          #include "osal.h"
     91          
     92          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     93          
     94          /**************************************************************************************************
     95           *                                              MACROS
     96           **************************************************************************************************/
     97          
     98          /**************************************************************************************************
     99           *                                            CONSTANTS
    100           **************************************************************************************************/
    101          #define HAL_KEY_RISING_EDGE   0
    102          #define HAL_KEY_FALLING_EDGE  1
    103          
    104          #define HAL_KEY_DEBOUNCE_VALUE  25
    105          #define HAL_KEY_POLLING_VALUE   100
    106          
    107          /* CPU port interrupt (key P0.1 J-STICK P2.0)*/
    108          #define HAL_KEY_CPU_PORT_0_IF P0IF
    109          #define HAL_KEY_CPU_PORT_2_IF P2IF
    110          
    111          /* SW_6 is at P0.1 */
    112          #define HAL_KEY_SW_6_PORT   P0
    113          #define HAL_KEY_SW_6_BIT    BV(1)
    114          #define HAL_KEY_SW_6_SEL    P0SEL
    115          #define HAL_KEY_SW_6_DIR    P0DIR
    116          
    117          /* edge interrupt */
    118          #define HAL_KEY_SW_6_EDGEBIT  BV(0)
    119          #define HAL_KEY_SW_6_EDGE     HAL_KEY_FALLING_EDGE
    120          
    121          
    122          /* SW_6 interrupts */
    123          #define HAL_KEY_SW_6_IEN      IEN1  /* CPU interrupt mask register */
    124          #define HAL_KEY_SW_6_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    125          #define HAL_KEY_SW_6_ICTL     P0IEN /* Port Interrupt Control register */
    126          #define HAL_KEY_SW_6_ICTLBIT  BV(1) /* P0IEN - P0.1 enable/disable bit */
    127          #define HAL_KEY_SW_6_PXIFG    P0IFG /* Interrupt flag at source */
    128          
    129          /* Joy stick move at P2.0 */
    130          #define HAL_KEY_JOY_MOVE_PORT   P2
    131          #define HAL_KEY_JOY_MOVE_BIT    BV(0)
    132          #define HAL_KEY_JOY_MOVE_SEL    P2SEL
    133          #define HAL_KEY_JOY_MOVE_DIR    P2DIR
    134          
    135          /* edge interrupt */
    136          #define HAL_KEY_JOY_MOVE_EDGEBIT  BV(3)
    137          #define HAL_KEY_JOY_MOVE_EDGE     HAL_KEY_FALLING_EDGE
    138          
    139          /* Joy move interrupts */
    140          #define HAL_KEY_JOY_MOVE_IEN      IEN2  /* CPU interrupt mask register */
    141          #define HAL_KEY_JOY_MOVE_IENBIT   BV(1) /* Mask bit for all of Port_2 */
    142          #define HAL_KEY_JOY_MOVE_ICTL     P2IEN /* Port Interrupt Control register */
    143          #define HAL_KEY_JOY_MOVE_ICTLBIT  BV(0) /* P2IENL - P2.0<->P2.3 enable/disable bit */
    144          #define HAL_KEY_JOY_MOVE_PXIFG    P2IFG /* Interrupt flag at source */
    145          
    146          #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    147          
    148          
    149          /**************************************************************************************************
    150           *                                            TYPEDEFS
    151           **************************************************************************************************/
    152          
    153          
    154          /**************************************************************************************************
    155           *                                        GLOBAL VARIABLES
    156           **************************************************************************************************/
    157          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
    158          static halKeyCBack_t pHalKeyProcessFunction;
    159          static uint8 HalKeyConfigured;
    160          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
    161          
    162          /**************************************************************************************************
    163           *                                        FUNCTIONS - Local
    164           **************************************************************************************************/
    165          void halProcessKeyInterrupt(void);
    166          uint8 halGetJoyKeyInput(void);
    167          
    168          
    169          
    170          /**************************************************************************************************
    171           *                                        FUNCTIONS - API
    172           **************************************************************************************************/
    173          
    174          
    175          /**************************************************************************************************
    176           * @fn      HalKeyInit
    177           *
    178           * @brief   Initilize Key Service
    179           *
    180           * @param   none
    181           *
    182           * @return  None
    183           **************************************************************************************************/
    184          void HalKeyInit( void )
    185          {
    186            /* Initialize previous key to 0 */
    187            halKeySavedKeys = 0;
    188          
    189            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
    190            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
    191          
    192           HAL_KEY_JOY_MOVE_SEL &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin function to GPIO */
    193           HAL_KEY_JOY_MOVE_DIR &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin direction to Input */
    194          
    195          
    196            /* Initialize callback function */
    197            pHalKeyProcessFunction  = NULL;
    198          
    199            /* Start with key is not configured */
    200            HalKeyConfigured = FALSE;
    201          }
    202          
    203          
    204          /**************************************************************************************************
    205           * @fn      HalKeyConfig
    206           *
    207           * @brief   Configure the Key serivce
    208           *
    209           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    210           *          cback - pointer to the CallBack function
    211           *
    212           * @return  None
    213           **************************************************************************************************/
    214          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
    215          {
    216            /* Enable/Disable Interrupt or */
    217            Hal_KeyIntEnable = interruptEnable;
    218          
    219            /* Register the callback fucntion */
    220            pHalKeyProcessFunction = cback;
    221          
    222            /* Determine if interrupt is enable or not */
    223            if (Hal_KeyIntEnable)
    224            {
    225              /* Rising/Falling edge configuratinn */
    226          
    227              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);    /* Clear the edge bit */
    228              /* For falling edge, the bit must be set. */
    229            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    230              PICTL |= HAL_KEY_SW_6_EDGEBIT;
    231            #endif
    232          
    233          
    234              /* Interrupt configuration:
    235               * - Enable interrupt generation at the port
    236               * - Enable CPU interrupt
    237               * - Clear any pending interrupt
    238               */
    239              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;
    240              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
    241              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);
    242          
    243          
    244          
    245              /* Rising/Falling edge configuratinn */
    246          
    247              HAL_KEY_JOY_MOVE_ICTL &= ~(HAL_KEY_JOY_MOVE_EDGEBIT);    /* Clear the edge bit */
    248              /* For falling edge, the bit must be set. */
    249            #if (HAL_KEY_JOY_MOVE_EDGE == HAL_KEY_FALLING_EDGE)
    250              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_EDGEBIT;
    251            #endif
    252          
    253          
    254              /* Interrupt configuration:
    255               * - Enable interrupt generation at the port
    256               * - Enable CPU interrupt
    257               * - Clear any pending interrupt
    258               */
    259              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_ICTLBIT;
    260              HAL_KEY_JOY_MOVE_IEN |= HAL_KEY_JOY_MOVE_IENBIT;
    261              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT);
    262          
    263          
    264              /* Do this only after the hal_key is configured - to work with sleep stuff */
    265              if (HalKeyConfigured == TRUE)
    266              {
    267                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
    268              }
    269            }
    270            else    /* Interrupts NOT enabled */
    271            {
    272              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT); /* don't generate interrupt */
    273              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);   /* Clear interrupt enable bit */
    274          
    275              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
    276            }
    277          
    278            /* Key now is configured */
    279            HalKeyConfigured = TRUE;
    280          }
    281          
    282          
    283          /**************************************************************************************************
    284           * @fn      HalKeyRead
    285           *
    286           * @brief   Read the current value of a key
    287           *
    288           * @param   None
    289           *
    290           * @return  keys - current keys status
    291           **************************************************************************************************/
    292          uint8 HalKeyRead ( void )
    293          {
    294            uint8 keys = 0;
    295          
    296            if (HAL_PUSH_BUTTON1())
    297            {
    298              keys |= HAL_KEY_SW_6;
    299            }
    300          
    301            if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active low */
    302            {
    303              keys |= halGetJoyKeyInput();
    304            }
    305          
    306            return keys;
    307          }
    308          
    309          
    310          /**************************************************************************************************
    311           * @fn      HalKeyPoll
    312           *
    313           * @brief   Called by hal_driver to poll the keys
    314           *
    315           * @param   None
    316           *
    317           * @return  None
    318           **************************************************************************************************/
    319          void HalKeyPoll (void)
    320          {
    321            uint8 keys = 0;
    322          
    323            if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active HIGH */
    324            {
    325              keys = halGetJoyKeyInput();
    326            }
    327          
    328            /* If interrupts are not enabled, previous key status and current key status
    329             * are compared to find out if a key has changed status.
    330             */
    331            if (!Hal_KeyIntEnable)
    332            {
    333              if (keys == halKeySavedKeys)
    334              {
    335                /* Exit - since no keys have changed */
    336                return;
    337              }
    338              /* Store the current keys for comparation next time */
    339              halKeySavedKeys = keys;
    340            }
    341            else
    342            {
    343              /* Key interrupt handled here */
    344            }
    345          
    346            if (HAL_PUSH_BUTTON1())
    347            {
    348              keys |= HAL_KEY_SW_6;
    349            }
    350          
    351            /* Invoke Callback if new keys were depressed */
    352            if (keys && (pHalKeyProcessFunction))
    353            {
    354              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
    355            }
    356          }
    357          
    358          /**************************************************************************************************
    359           * @fn      halGetJoyKeyInput
    360           *
    361           * @brief   Map the ADC value to its corresponding key.
    362           *
    363           * @param   None
    364           *
    365           * @return  keys - current joy key status
    366           **************************************************************************************************/
    367          uint8 halGetJoyKeyInput(void)
    368          {
    369            /* The joystick control is encoded as an analog voltage.
    370             * Read the JOY_LEVEL analog value and map it to joy movement.
    371             */
    372            uint8 adc;
    373            uint8 ksave0 = 0;
    374            uint8 ksave1;
    375          
    376            /* Keep on reading the ADC until two consecutive key decisions are the same. */
    377            do
    378            {
    379              ksave1 = ksave0;    /* save previouse key reading */
    380          
    381              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
    382          
    383              if ((adc >= 2) && (adc <= 38))
    384              {
    385                 ksave0 |= HAL_KEY_UP;
    386              }
    387              else if ((adc >= 74) && (adc <= 88))
    388              {
    389                ksave0 |= HAL_KEY_RIGHT;
    390              }
    391              else if ((adc >= 60) && (adc <= 73))
    392              {
    393                ksave0 |= HAL_KEY_LEFT;
    394              }
    395              else if ((adc >= 39) && (adc <= 59))
    396              {
    397                ksave0 |= HAL_KEY_DOWN;
    398              }
    399              else if ((adc >= 89) && (adc <= 100))
    400              {
    401                ksave0 |= HAL_KEY_CENTER;
    402              }
    403            } while (ksave0 != ksave1);
    404          
    405            return ksave0;
    406          }
    407          
    408          
    409          
    410          
    411          
    412          /**************************************************************************************************
    413           * @fn      halProcessKeyInterrupt
    414           *
    415           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    416           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    417           *
    418           * @param
    419           *
    420           * @return
    421           **************************************************************************************************/
    422          void halProcessKeyInterrupt (void)
    423          {
    424            bool valid=FALSE;
    425          
    426            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)  /* Interrupt Flag has been set */
    427            {
    428              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT); /* Clear Interrupt Flag */
    429              valid = TRUE;
    430            }
    431          
    432            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)  /* Interrupt Flag has been set */
    433            {
    434              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT); /* Clear Interrupt Flag */
    435              valid = TRUE;
    436            }
    437          
    438            if (valid)
    439            {
    440              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
    441            }
    442          }
    443          
    444          /**************************************************************************************************
    445           * @fn      HalKeyEnterSleep
    446           *
    447           * @brief  - Get called to enter sleep mode
    448           *
    449           * @param
    450           *
    451           * @return
    452           **************************************************************************************************/
    453          void HalKeyEnterSleep ( void )
    454          {
    455          }
    456          
    457          /**************************************************************************************************
    458           * @fn      HalKeyExitSleep
    459           *
    460           * @brief   - Get called when sleep is over
    461           *
    462           * @param
    463           *
    464           * @return  - return saved keys
    465           **************************************************************************************************/
    466          uint8 HalKeyExitSleep ( void )
    467          {
    468            /* Wake up and read keys */
    469            return ( HalKeyRead () );
    470          }
    471          
    472          /***************************************************************************************************
    473           *                                    INTERRUPT SERVICE ROUTINE
    474           ***************************************************************************************************/
    475          
    476          /**************************************************************************************************
    477           * @fn      halKeyPort0Isr
    478           *
    479           * @brief   Port0 ISR
    480           *
    481           * @param
    482           *
    483           * @return
    484           **************************************************************************************************/
    485           #if 0
    486          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
    487          {
    488            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
    489            {
    490              halProcessKeyInterrupt();
    491            }
    492          
    493            /*
    494              Clear the CPU interrupt flag for Port_0
    495              PxIFG has to be cleared before PxIF
    496            */
    497            HAL_KEY_SW_6_PXIFG = 0;
    498            HAL_KEY_CPU_PORT_0_IF = 0;
    499          }
    500           #endif
    501          
    502          #if 0
    503          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
    504          {
    505          	  if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
    506          	  {
    507          	    halProcessKeyInterrupt();
    508          	  }
    509          
    510          	  /*
    511          	    Clear the CPU interrupt flag for Port_0
    512          	    PxIFG has to be cleared before PxIF
    513          	  */
    514          	  HAL_KEY_SW_6_PXIFG = 0;
    515          	  HAL_KEY_CPU_PORT_0_IF = 0;
    516          }
    517          #endif
    518          
    519          
    520          
    521          /**************************************************************************************************
    522           * @fn      halKeyPort2Isr
    523           *
    524           * @brief   Port2 ISR
    525           *
    526           * @param
    527           *
    528           * @return
    529           **************************************************************************************************/
    530          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
    531          {
    532            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)
    533            {
    534              halProcessKeyInterrupt();
    535            }
    536          
    537            /*
    538              Clear the CPU interrupt flag for Port_2
    539              PxIFG has to be cleared before PxIF
    540              Notes: P2_1 and P2_2 are debug lines.
    541            */
    542            HAL_KEY_JOY_MOVE_PXIFG = 0;
    543            HAL_KEY_CPU_PORT_2_IF = 0;
    544          }
    545          
    546          #else
    547          
    548          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    549          void HalKeyInit(void){}
   \                     HalKeyInit:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    550          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
   \                     HalKeyConfig:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          uint8 HalKeyRead(void){ return 0;}
   \                     HalKeyRead:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    552          void HalKeyPoll(void){}
   \                     HalKeyPoll:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll
    553          
    554          #endif /* HAL_KEY */
    555          
    556          
    557          
    558          
    559          
    560          /**************************************************************************************************
    561          **************************************************************************************************/
    562          
    563          
    564          

   Maximum stack usage in bytes:

     Function     ISTACK PSTACK XSTACK
     --------     ------ ------ ------
     HalKeyConfig     0      0      0
     HalKeyInit       0      0      0
     HalKeyPoll       0      0      0
     HalKeyRead       0      0      0


   Segment part sizes:

     Function/Label       Bytes
     --------------       -----
     HalKeyInit              3
     HalKeyConfig            3
     HalKeyRead              5
     HalKeyPoll              3
     ??HalKeyInit?relay      6
     ??HalKeyConfig?relay    6
     ??HalKeyRead?relay      6
     ??HalKeyPoll?relay      6

 
 14 bytes in segment BANKED_CODE
 24 bytes in segment BANK_RELAYS
 
 38 bytes of CODE memory

Errors: none
Warnings: none
