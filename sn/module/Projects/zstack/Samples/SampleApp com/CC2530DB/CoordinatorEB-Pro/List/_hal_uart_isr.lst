###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             30/May/2013  21:07:56 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\_hal_uart_isr.c             #
#    Command line       =  -f "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Proj #
#                          ects\zstack\Samples\SampleApp                      #
#                          com\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg #
#                          " (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR    #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF0                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440)   #
#                          E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\_hal_uart_isr.c -D          #
#                          ZIGBEEPRO -D ZTOOL_P1 -D NONWK -lC                 #
#                          "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\CoordinatorEB-Pro\List\" -lA          #
#                          "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\CoordinatorEB-Pro\List\"              #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\CoordinatorEB-Pro\Obj\" -e            #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "E:\workplace\NewStep\Rf\C #
#                          an_Rf\CanMstOsal\Projects\zstack\Samples\SampleApp #
#                           com\CC2530DB\" -I "E:\workplace\NewStep\Rf\Can_Rf #
#                          \CanMstOsal\Projects\zstack\Samples\SampleApp      #
#                          com\CC2530DB\..\SOURCE\" -I                        #
#                          "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\ZMAIN\TI2530DB\" -I          #
#                          "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I     #
#                          "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE #
#                          \" -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\P #
#                          rojects\zstack\Samples\SampleApp                   #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\ #
#                          CC2530EB\" -I "E:\workplace\NewStep\Rf\Can_Rf\CanM #
#                          stOsal\Projects\zstack\Samples\SampleApp           #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CC #
#                          SOC\" -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsa #
#                          l\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUD #
#                          E\" -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\ #
#                          Projects\zstack\Samples\SampleApp                  #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\"  #
#                          -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Proj #
#                          ects\zstack\Samples\SampleApp                      #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\" #
#                           -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\" #
#                           -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ #
#                          " -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Pr #
#                          ojects\zstack\Samples\SampleApp                    #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\" #
#                           -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\" #
#                           -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"  #
#                          -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Proj #
#                          ects\zstack\Samples\SampleApp                      #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I   #
#                          "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Project #
#                          s\zstack\Samples\SampleApp                         #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SA #
#                          DDR\" -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsa #
#                          l\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SD #
#                          ATA\" -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsa #
#                          l\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE #
#                          \" -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\P #
#                          rojects\zstack\Samples\SampleApp                   #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LE #
#                          VEL\" -I "E:\workplace\NewStep\Rf\Can_Rf\CanMstOsa #
#                          l\Projects\zstack\Samples\SampleApp                #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\" -I "E:\workplace\NewStep\Rf\Can_Rf\CanM #
#                          stOsal\Projects\zstack\Samples\SampleApp           #
#                          com\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\SINGLE_CHIP\" -I "D:\Program Files\IAR    #
#                          Systems\Embedded Workbench 5.4\8051\INC\" -I       #
#                          "D:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.4\8051\INC\CLIB\" -Ohz                           #
#    List file          =  E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Samples\SampleApp                          #
#                          com\CC2530DB\CoordinatorEB-Pro\List\_hal_uart_isr. #
#                          lst                                                #
#    Object file        =  E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Projects #
#                          \zstack\Samples\SampleApp                          #
#                          com\CC2530DB\CoordinatorEB-Pro\Obj\_hal_uart_isr.r #
#                          51                                                 #
#                                                                             #
#                                                                             #
###############################################################################

E:\workplace\NewStep\Rf\Can_Rf\CanMstOsal\Components\hal\target\CC2530EB\_hal_uart_isr.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart_isr.c
      3            Revised:        $Date: 2009-12-10 14:22:39 -0800 (Thu, 10 Dec 2009) $
      4            Revision:       $Revision: 21313 $
      5          
      6            Description: This file contains the interface to the H/W UART driver by ISR.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_types.h"
     45          #include "hal_assert.h"
     46          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1
     47          #include "hal_defs.h"
     48          #include "hal_mcu.h"
     49          #include "hal_uart.h"
     50          #if defined MT_TASK
     51          #include "mt_uart.h"
     52          #endif
     53          #include "osal.h"
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          
     59          //#define HAL_UART_ASSERT(expr)        HAL_ASSERT((expr))
     60          #define HAL_UART_ASSERT(expr)
     61          
     62          #define HAL_UART_ISR_RX_AVAIL() \
     63            (isrCfg.rxTail >= isrCfg.rxHead) ? \
     64            (isrCfg.rxTail - isrCfg.rxHead) : \
     65            (HAL_UART_ISR_RX_MAX - isrCfg.rxHead + isrCfg.rxTail)
     66          
     67          #define HAL_UART_ISR_TX_AVAIL() \
     68            (isrCfg.txHead > isrCfg.txTail) ? \
     69            (isrCfg.txHead - isrCfg.txTail - 1) : \
     70            (HAL_UART_ISR_TX_MAX - isrCfg.txTail + isrCfg.txHead - 1)
     71          
     72          /*********************************************************************
     73           * CONSTANTS
     74           */
     75          
     76          // UxCSR - USART Control and Status Register.
     77          #define CSR_MODE                   0x80
     78          #define CSR_RE                     0x40
     79          #define CSR_SLAVE                  0x20
     80          #define CSR_FE                     0x10
     81          #define CSR_ERR                    0x08
     82          #define CSR_RX_BYTE                0x04
     83          #define CSR_TX_BYTE                0x02
     84          #define CSR_ACTIVE                 0x01
     85          
     86          // UxUCR - USART UART Control Register.
     87          #define UCR_FLUSH                  0x80
     88          #define UCR_FLOW                   0x40
     89          #define UCR_D9                     0x20
     90          #define UCR_BIT9                   0x10
     91          #define UCR_PARITY                 0x08
     92          #define UCR_SPB                    0x04
     93          #define UCR_STOP                   0x02
     94          #define UCR_START                  0x01
     95          
     96          #define UTX0IE                     0x04
     97          #define UTX1IE                     0x08
     98          
     99          #define P2DIR_PRIPO                0xC0
    100          
    101          // Incompatible redefinitions between the 2 UART driver sub-modules:
    102          #undef PxSEL
    103          #undef UxCSR
    104          #undef UxUCR
    105          #undef UxDBUF
    106          #undef UxBAUD
    107          #undef UxGCR
    108          #undef URXxIE
    109          #undef UTXxIE
    110          #undef UTXxIF
    111          #if (HAL_UART_ISR == 1)
    112          #define PxOUT                      P0
    113          #define PxDIR                      P0DIR
    114          #define PxSEL                      P0SEL
    115          #define UxCSR                      U0CSR
    116          #define UxUCR                      U0UCR
    117          #define UxDBUF                     U0DBUF
    118          #define UxBAUD                     U0BAUD
    119          #define UxGCR                      U0GCR
    120          #define URXxIE                     URX0IE
    121          #define UTXxIE                     UTX0IE
    122          #define UTXxIF                     UTX0IF
    123          #else
    124          #define PxOUT                      P1
    125          #define PxDIR                      P1DIR
    126          #define PxSEL                      P1SEL
    127          #define UxCSR                      U1CSR
    128          #define UxUCR                      U1UCR
    129          #define UxDBUF                     U1DBUF
    130          #define UxBAUD                     U1BAUD
    131          #define UxGCR                      U1GCR
    132          #define URXxIE                     URX1IE
    133          #define UTXxIE                     UTX1IE
    134          #define UTXxIF                     UTX1IF
    135          #endif
    136          
    137          #if (HAL_UART_ISR == 1)
    138          #define HAL_UART_PERCFG_BIT        0x01         // USART0 on P0, Alt-1; so clear this bit.
    139          #define HAL_UART_Px_RX_TX          0x0C         // Peripheral I/O Select for Rx/Tx.
    140          #define HAL_UART_Px_RTS            0x20         // Peripheral I/O Select for RTS.
    141          #define HAL_UART_Px_CTS            0x10         // Peripheral I/O Select for CTS.
    142          #else
    143          #define HAL_UART_PERCFG_BIT        0x02         // USART1 on P1, Alt-2; so set this bit.
    144          #define HAL_UART_Px_RTS            0x20         // Peripheral I/O Select for RTS.
    145          #define HAL_UART_Px_CTS            0x10         // Peripheral I/O Select for CTS.
    146          #define HAL_UART_Px_RX_TX          0xC0         // Peripheral I/O Select for Rx/Tx.
    147          #endif
    148          
    149          // The timeout tick is at 32-kHz, so multiply msecs by 33.
    150          #define HAL_UART_MSECS_TO_TICKS    33
    151          
    152          #if defined MT_TASK
    153          #define HAL_UART_ISR_TX_MAX        MT_UART_DEFAULT_MAX_TX_BUFF
    154          #define HAL_UART_ISR_RX_MAX        MT_UART_DEFAULT_MAX_RX_BUFF
    155          #define HAL_UART_ISR_HIGH          MT_UART_DEFAULT_THRESHOLD
    156          #define HAL_UART_ISR_IDLE         (MT_UART_DEFAULT_IDLE_TIMEOUT * HAL_UART_MSECS_TO_TICKS)
    157          #else
    158          #if !defined HAL_UART_ISR_RX_MAX
    159          #define HAL_UART_ISR_RX_MAX        128
    160          #endif
    161          #if !defined HAL_UART_ISR_TX_MAX
    162          #define HAL_UART_ISR_TX_MAX        HAL_UART_ISR_RX_MAX
    163          #endif
    164          #if !defined HAL_UART_ISR_HIGH
    165          #define HAL_UART_ISR_HIGH         (HAL_UART_ISR_RX_MAX / 2 - 16)
    166          #endif
    167          #if !defined HAL_UART_ISR_IDLE
    168          #define HAL_UART_ISR_IDLE         (6 * HAL_UART_MSECS_TO_TICKS)
    169          #endif
    170          #endif
    171          
    172          /*********************************************************************
    173           * TYPEDEFS
    174           */
    175          
    176          typedef struct
    177          {
    178            uint8 rxBuf[HAL_UART_ISR_RX_MAX];
    179          #if HAL_UART_ISR_RX_MAX < 256
    180            uint8 rxHead;
    181            volatile uint8 rxTail;
    182          #else
    183            uint16 rxHead;
    184            volatile uint16 rxTail;
    185          #endif
    186            uint8 rxTick;
    187            uint8 rxShdw;
    188          
    189            uint8 txBuf[HAL_UART_ISR_TX_MAX];
    190          #if HAL_UART_ISR_TX_MAX < 256
    191            volatile uint8 txHead;
    192            uint8 txTail;
    193          #else
    194            volatile uint16 txHead;
    195            uint16 txTail;
    196          #endif
    197            uint8 txMT;
    198          
    199            halUARTCBack_t uartCB;
    200          } uartISRCfg_t;
    201          
    202          /*********************************************************************
    203           * GLOBAL VARIABLES
    204           */
    205          
    206          /*********************************************************************
    207           * GLOBAL FUNCTIONS
    208           */
    209          
    210          /*********************************************************************
    211           * LOCAL VARIABLES
    212           */
    213          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    214          static uartISRCfg_t isrCfg;
   \                     isrCfg:
   \   000000                DS 265
   \   000109                REQUIRE __INIT_XDATA_Z
    215          
    216          /*********************************************************************
    217           * LOCAL FUNCTIONS
    218           */
    219          
    220          static void HalUARTInitISR(void);
    221          static void HalUARTOpenISR(halUARTCfg_t *config);
    222          static uint16 HalUARTReadISR(uint8 *buf, uint16 len);
    223          static uint16 HalUARTWriteISR(uint8 *buf, uint16 len);
    224          static void HalUARTPollISR(void);
    225          static uint16 HalUARTRxAvailISR(void);
    226          static void HalUARTSuspendISR(void);
    227          static void HalUARTResumeISR(void);
    228          
    229          /******************************************************************************
    230           * @fn      HalUARTInitISR
    231           *
    232           * @brief   Initialize the UART
    233           *
    234           * @param   none
    235           *
    236           * @return  none
    237           *****************************************************************************/
    238          static void HalUARTInitISR(void)
                             ^
Warning[Pe177]: function "HalUARTInitISR" was declared but never referenced
    239          {
    240            // Set P2 priority - USART0 over USART1 if both are defined.
    241            P2DIR &= ~P2DIR_PRIPO;
    242            P2DIR |= HAL_UART_PRIPO;
    243          
    244          #if (HAL_UART_ISR == 1)
    245            PERCFG &= ~HAL_UART_PERCFG_BIT;    // Set UART0 I/O location to P0.
    246          #else
    247            PERCFG |= HAL_UART_PERCFG_BIT;     // Set UART1 I/O location to P1.
    248          #endif
    249            PxSEL  |= HAL_UART_Px_RX_TX;       // Enable Tx and Rx on P1.
    250            ADCCFG &= ~HAL_UART_Px_RX_TX;      // Make sure ADC doesnt use this.
    251            UxCSR = CSR_MODE;                  // Mode is UART Mode.
    252            UxUCR = UCR_FLUSH;                 // Flush it.
    253          }
    254          
    255          /******************************************************************************
    256           * @fn      HalUARTOpenISR
    257           *
    258           * @brief   Open a port according tp the configuration specified by parameter.
    259           *
    260           * @param   config - contains configuration information
    261           *
    262           * @return  none
    263           *****************************************************************************/
    264          static void HalUARTOpenISR(halUARTCfg_t *config)
                             ^
Warning[Pe177]: function "HalUARTOpenISR" was declared but never referenced
    265          {
    266            isrCfg.uartCB = config->callBackFunc;
    267            // Only supporting subset of baudrate for code size - other is possible.
    268            HAL_UART_ASSERT((config->baudRate == HAL_UART_BR_9600) ||
    269                            (config->baudRate == HAL_UART_BR_19200) ||
    270                            (config->baudRate == HAL_UART_BR_38400) ||
    271                            (config->baudRate == HAL_UART_BR_57600) ||
    272                            (config->baudRate == HAL_UART_BR_115200));
    273            
    274            if (config->baudRate == HAL_UART_BR_57600 ||
    275                config->baudRate == HAL_UART_BR_115200)
    276            {
    277              UxBAUD = 216;
    278            }
    279            else
    280            {
    281              UxBAUD = 59;
    282            }
    283            
    284            switch (config->baudRate)
    285            {
    286              case HAL_UART_BR_9600:
    287                UxGCR = 8;
    288                break;
    289              case HAL_UART_BR_19200:
    290                UxGCR = 9;
    291                break;
    292              case HAL_UART_BR_38400:
    293              case HAL_UART_BR_57600:
    294                UxGCR = 10;
    295                break;
    296              default:
    297                UxGCR = 11;
    298                break;
    299            }
    300          
    301            // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    302            if (config->flowControl)
    303            {
    304              UxUCR = UCR_FLOW | UCR_STOP;
    305              PxSEL |= HAL_UART_Px_RTS | HAL_UART_Px_CTS;
    306            }
    307            else
    308            {
    309              UxUCR = UCR_STOP;
    310            }
    311          
    312            UxCSR |= CSR_RE;
    313            URXxIE = 1;
    314            UTXxIF = 1;  // Prime the ISR pump.
    315          }
    316          
    317          /*****************************************************************************
    318           * @fn      HalUARTReadISR
    319           *
    320           * @brief   Read a buffer from the UART
    321           *
    322           * @param   buf  - valid data buffer at least 'len' bytes in size
    323           *          len  - max length number of bytes to copy to 'buf'
    324           *
    325           * @return  length of buffer that was read
    326           *****************************************************************************/
    327          static uint16 HalUARTReadISR(uint8 *buf, uint16 len)
                               ^
Warning[Pe177]: function "HalUARTReadISR" was declared but never referenced
    328          {
    329            uint16 cnt = 0;
    330          
    331            while ((isrCfg.rxHead != isrCfg.rxTail) && (cnt < len))
    332            {
    333              *buf++ = isrCfg.rxBuf[isrCfg.rxHead++];
    334              if (isrCfg.rxHead >= HAL_UART_ISR_RX_MAX)
    335              {
    336                isrCfg.rxHead = 0;
    337              }
    338              cnt++;
    339            }
    340          
    341            return cnt;
    342          }
    343          
    344          /******************************************************************************
    345           * @fn      HalUARTWriteISR
    346           *
    347           * @brief   Write a buffer to the UART.
    348           *
    349           * @param   buf - pointer to the buffer that will be written, not freed
    350           *          len - length of
    351           *
    352           * @return  length of the buffer that was sent
    353           *****************************************************************************/
    354          static uint16 HalUARTWriteISR(uint8 *buf, uint16 len)
                               ^
Warning[Pe177]: function "HalUARTWriteISR" was declared but never referenced
    355          {
    356            uint16 cnt;
    357          
    358            // Enforce all or none.
    359            if (HAL_UART_ISR_TX_AVAIL() < len)
    360            {
    361              return 0;
    362            }
    363          
    364            for (cnt = 0; cnt < len; cnt++)
    365            {
    366              isrCfg.txBuf[isrCfg.txTail] = *buf++;
    367              isrCfg.txMT = 0;
    368          
    369              if (isrCfg.txTail >= HAL_UART_ISR_TX_MAX-1)
    370              {
    371                isrCfg.txTail = 0;
    372              }
    373              else
    374              {
    375                isrCfg.txTail++;
    376              }
    377          
    378              // Keep re-enabling ISR as it might be keeping up with this loop due to other ints.
    379              IEN2 |= UTXxIE;  
    380            }
    381          
    382            return cnt;
    383          }
    384          
    385          /******************************************************************************
    386           * @fn      HalUARTPollISR
    387           *
    388           * @brief   Poll a USART module implemented by ISR.
    389           *
    390           * @param   none
    391           *
    392           * @return  none
    393           *****************************************************************************/
    394          static void HalUARTPollISR(void)
                             ^
Warning[Pe177]: function "HalUARTPollISR" was declared but never referenced
    395          {
    396            if (isrCfg.uartCB != NULL)
    397            {
    398              uint16 cnt = HAL_UART_ISR_RX_AVAIL();
    399              uint8 evt = 0;
    400          
    401              if (isrCfg.rxTick)
    402              {
    403                // Use the LSB of the sleep timer (ST0 must be read first anyway).
    404                uint8 decr = ST0 - isrCfg.rxShdw;
    405          
    406                if (isrCfg.rxTick > decr)
    407                {
    408                  isrCfg.rxTick -= decr;
    409                }
    410                else
    411                {
    412                  isrCfg.rxTick = 0;
    413                }
    414              }
    415              isrCfg.rxShdw = ST0;
    416          
    417              if (cnt >= HAL_UART_ISR_RX_MAX-1)
    418              {
    419                evt = HAL_UART_RX_FULL;
    420              }
    421              else if (cnt >= HAL_UART_ISR_HIGH)
    422              {
    423                evt = HAL_UART_RX_ABOUT_FULL;
    424              }
    425              else if (cnt && !isrCfg.rxTick)
    426              {
    427                evt = HAL_UART_RX_TIMEOUT;
    428              }
    429          
    430              if (isrCfg.txMT)
    431              {
    432                isrCfg.txMT = 0;
    433                evt |= HAL_UART_TX_EMPTY;
    434              }
    435          
    436              if (evt)
    437              {
    438                isrCfg.uartCB(HAL_UART_ISR-1, evt);
    439              }
    440            }
    441          }
    442          
    443          /**************************************************************************************************
    444           * @fn      HalUARTRxAvailISR()
    445           *
    446           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    447           *
    448           * @param   none
    449           *
    450           * @return  length of current Rx Buffer
    451           **************************************************************************************************/
    452          static uint16 HalUARTRxAvailISR(void)
                               ^
Warning[Pe177]: function "HalUARTRxAvailISR" was declared but never referenced
    453          {
    454            return HAL_UART_ISR_RX_AVAIL();
    455          }
    456          
    457          /******************************************************************************
    458           * @fn      HalUARTSuspendISR
    459           *
    460           * @brief   Suspend UART hardware before entering PM mode 1, 2 or 3.
    461           *
    462           * @param   None
    463           *
    464           * @return  None
    465           *****************************************************************************/
    466          static void HalUARTSuspendISR( void )
                             ^
Warning[Pe177]: function "HalUARTSuspendISR" was declared but never referenced
    467          {
    468            UxCSR &= ~CSR_RE;
    469          }
    470          
    471          /******************************************************************************
    472           * @fn      HalUARTResumeISR
    473           *
    474           * @brief   Resume UART hardware after exiting PM mode 1, 2 or 3.
    475           *
    476           * @param   None
    477           *
    478           * @return  None
    479           *****************************************************************************/
    480          static void HalUARTResumeISR( void )
                             ^
Warning[Pe177]: function "HalUARTResumeISR" was declared but never referenced
    481          {
    482            UxUCR |= UCR_FLUSH;
    483            UxCSR |= CSR_RE;
    484          }
    485          
    486          /***************************************************************************************************
    487           * @fn      halUartRxIsr
    488           *
    489           * @brief   UART Receive Interrupt
    490           *
    491           * @param   None
    492           *
    493           * @return  None
    494           ***************************************************************************************************/
    495          #if (HAL_UART_ISR == 1)

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    496          HAL_ISR_FUNCTION( halUart0RxIsr, URX0_VECTOR )
   \                     halUart0RxIsr:
    497          #else
    498          HAL_ISR_FUNCTION( halUart1RxIsr, URX1_VECTOR )
    499          #endif
    500          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007   E9           MOV     A,R1
   \   000008   C0E0         PUSH    A
   \   00000A   EA           MOV     A,R2
   \   00000B   C0E0         PUSH    A
   \   00000D   C082         PUSH    DPL
   \   00000F   C083         PUSH    DPH
   \   000011                ; Saved register size: 7
   \   000011                ; Auto size: 0
    501            uint8 tmp = UxDBUF;
   \   000011   E5C1         MOV     A,0xc1
    502            isrCfg.rxBuf[isrCfg.rxTail] = tmp;
   \   000013   C0E0         PUSH    A
   \   000015   90....       MOV     DPTR,#(isrCfg + 129)
   \   000018   E0           MOVX    A,@DPTR
   \   000019   24..         ADD     A,#(isrCfg & 0xff)
   \   00001B   F582         MOV     DPL,A
   \   00001D   E4           CLR     A
   \   00001E   34..         ADDC    A,#((isrCfg >> 8) & 0xff)
   \   000020   F583         MOV     DPH,A
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
    503          
    504            // Re-sync the shadow on any 1st byte received.
    505            if (isrCfg.rxHead == isrCfg.rxTail)
   \   000025   90....       MOV     DPTR,#(isrCfg + 128)
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FA           MOV     R2,A
   \   00002A   90....       MOV     DPTR,#(isrCfg + 129)
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6A           XRL     A,R2
   \   00002F   7006         JNZ     ??halUart0RxIsr_0
    506            {
    507              isrCfg.rxShdw = ST0;
   \   000031   E595         MOV     A,0x95
   \   000033   90....       MOV     DPTR,#(isrCfg + 131)
   \   000036   F0           MOVX    @DPTR,A
    508            }
    509          
    510            if (++isrCfg.rxTail >= HAL_UART_ISR_RX_MAX)
   \                     ??halUart0RxIsr_0:
   \   000037   90....       MOV     DPTR,#(isrCfg + 129)
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   04           INC     A
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   C3           CLR     C
   \   00003E   9480         SUBB    A,#-0x80
   \   000040   4002         JC      ??halUart0RxIsr_1
    511            {
    512              isrCfg.rxTail = 0;
   \   000042   E4           CLR     A
   \   000043   F0           MOVX    @DPTR,A
    513            }
    514          
    515            isrCfg.rxTick = HAL_UART_ISR_IDLE;
   \                     ??halUart0RxIsr_1:
   \   000044   74C6         MOV     A,#-0x3a
   \   000046   90....       MOV     DPTR,#(isrCfg + 130)
   \   000049   F0           MOVX    @DPTR,A
    516          }
   \   00004A   D083         POP     DPH
   \   00004C   D082         POP     DPL
   \   00004E   D0E0         POP     A
   \   000050   FA           MOV     R2,A
   \   000051   D0E0         POP     A
   \   000053   F9           MOV     R1,A
   \   000054   D0E0         POP     A
   \   000056   F8           MOV     R0,A
   \   000057                REQUIRE ?Subroutine0
   \   000057                REQUIRE U0DBUF
   \   000057                REQUIRE ST0
   \   000057                ; // Fall through to label ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D0D0         POP     PSW
   \   000002   D0E0         POP     A
   \   000004   32           RETI
    517          
    518          /***************************************************************************************************
    519           * @fn      halUartTxIsr
    520           *
    521           * @brief   UART Transmit Interrupt
    522           *
    523           * @param   None
    524           *
    525           * @return  None
    526           ***************************************************************************************************/
    527          #if (HAL_UART_ISR == 1)

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    528          HAL_ISR_FUNCTION( halUart0TxIsr, UTX0_VECTOR )
   \                     halUart0TxIsr:
    529          #else
    530          HAL_ISR_FUNCTION( halUart1TxIsr, UTX1_VECTOR )
    531          #endif
    532          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   EA           MOV     A,R2
   \   000005   C0E0         PUSH    A
   \   000007   C0..         PUSH    ?V0 + 0
   \   000009   C0..         PUSH    ?V0 + 1
   \   00000B   C082         PUSH    DPL
   \   00000D   C083         PUSH    DPH
   \   00000F                ; Saved register size: 7
   \   00000F                ; Auto size: 0
    533            if (isrCfg.txHead == isrCfg.txTail)
   \   00000F   90....       MOV     DPTR,#(isrCfg + 260)
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FA           MOV     R2,A
   \   000014   90....       MOV     DPTR,#(isrCfg + 261)
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6A           XRL     A,R2
   \   000019   700A         JNZ     ??halUart0TxIsr_0
    534            {
    535              IEN2 &= ~UTXxIE;
   \   00001B   539AFB       ANL     0x9a,#0xfb
    536              isrCfg.txMT = 1;
   \   00001E   7401         MOV     A,#0x1
   \   000020   90....       MOV     DPTR,#(isrCfg + 262)
   \   000023   8025         SJMP    ??halUart0TxIsr_1
    537            }
    538            else
    539            {
    540              UTXxIF = 0;
   \                     ??halUart0TxIsr_0:
   \   000025   C2E9         CLR     0xe8.1
    541              UxDBUF = isrCfg.txBuf[isrCfg.txHead++];
   \   000027   90....       MOV     DPTR,#(isrCfg + 260)
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 0,A
   \   00002D   7401         MOV     A,#0x1
   \   00002F   25..         ADD     A,?V0 + 0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   E5..         MOV     A,?V0 + 0
   \   000034   24..         ADD     A,#((isrCfg + 132) & 0xff)
   \   000036   F582         MOV     DPL,A
   \   000038   E4           CLR     A
   \   000039   34..         ADDC    A,#(((isrCfg + 132) >> 8) & 0xff)
   \   00003B   F583         MOV     DPH,A
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F5C1         MOV     0xc1,A
    542          
    543              if (isrCfg.txHead >= HAL_UART_ISR_TX_MAX)
   \   000040   90....       MOV     DPTR,#(isrCfg + 260)
   \   000043   E0           MOVX    A,@DPTR
   \   000044   C3           CLR     C
   \   000045   9480         SUBB    A,#-0x80
   \   000047   4002         JC      ??halUart0TxIsr_2
    544              {
    545                isrCfg.txHead = 0;
   \   000049   E4           CLR     A
   \                     ??halUart0TxIsr_1:
   \   00004A   F0           MOVX    @DPTR,A
    546              }
    547            }
    548          }
   \                     ??halUart0TxIsr_2:
   \   00004B   D083         POP     DPH
   \   00004D   D082         POP     DPL
   \   00004F   D0..         POP     ?V0 + 1
   \   000051   D0..         POP     ?V0 + 0
   \   000053   D0E0         POP     A
   \   000055   FA           MOV     R2,A
   \   000056   80..         SJMP    ?Subroutine0
   \   000058                REQUIRE U0DBUF
   \   000058                REQUIRE IEN2
   \   000058                REQUIRE _A_IRCON2

   \                                 In  segment INTVEC, offset 0x13, root
   \                     `??halUart0RxIsr??INTVEC 19`:
   \   000013   02....       LJMP       (halUart0RxIsr)

   \                                 In  segment INTVEC, offset 0x3b, root
   \                     `??halUart0TxIsr??INTVEC 59`:
   \   00003B   02....       LJMP       (halUart0TxIsr)
    549          
    550          /******************************************************************************
    551          ******************************************************************************/

   Maximum stack usage in bytes:

     Function      ISTACK PSTACK XSTACK
     --------      ------ ------ ------
     halUart0RxIsr     8      0      0
     halUart0TxIsr     7      0      0


   Segment part sizes:

     Function/Label             Bytes
     --------------             -----
     ST0                           1
     IEN2                          1
     U0DBUF                        1
     _A_IRCON2                     1
     isrCfg                      265
     halUart0RxIsr                87
     ?Subroutine0                  5
     halUart0TxIsr                88
     ??halUart0RxIsr??INTVEC 19    3
     ??halUart0TxIsr??INTVEC 59    3

 
   6 bytes in segment INTVEC
 180 bytes in segment NEAR_CODE
   4 bytes in segment SFR_AN
 265 bytes in segment XDATA_Z
 
 180 bytes of CODE  memory (+ 6 bytes shared)
   0 bytes of DATA  memory (+ 4 bytes shared)
 265 bytes of XDATA memory

Errors: none
Warnings: 8
