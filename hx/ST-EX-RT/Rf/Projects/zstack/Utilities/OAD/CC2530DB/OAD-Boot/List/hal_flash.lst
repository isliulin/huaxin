###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.40338/W32 for 8051         14/Feb/2016  19:44:44 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\hal_flash.c                 #
#    Command line       =  C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\hal_flash.c -D              #
#                          HAL_OAD_BOOT_CODE -lC C:\Users\freeman\Work\ST-EX- #
#                          RT\CanMstOsal\Projects\zstack\Utilities\OAD\CC2530 #
#                          DB\OAD-Boot\List\ -lA C:\Users\freeman\Work\ST-EX- #
#                          RT\CanMstOsal\Projects\zstack\Utilities\OAD\CC2530 #
#                          DB\OAD-Boot\List\ --remarks -o                     #
#                          C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\Obj\ -e    #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=near               #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 16 -I     #
#                          C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\ -I                 #
#                          C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\SOURCE\ -I          #
#                          C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\..\..\..\Tools\CC25 #
#                          30DB\ -I C:\Users\freeman\Work\ST-EX-RT\CanMstOsal #
#                          \Projects\zstack\Utilities\OAD\CC2530DB\..\..\..\Z #
#                          MAIN\TI2530DB\ -I C:\Users\freeman\Work\ST-EX-RT\C #
#                          anMstOsal\Projects\zstack\Utilities\OAD\CC2530DB\. #
#                          .\..\..\..\..\COMPONENTS\HAL\INCLUDE\ -I           #
#                          C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\OSAL\INCLUDE\ -Ohz --require_prototypes     #
#                          --mfc --discard_unused_publics                     #
#                          C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\hal_oad.c                   #
#                          C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Componen #
#                          ts\hal\target\CC2530EB\hal_uart.c                  #
#    List file          =  C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\List\hal_f #
#                          lash.lst                                           #
#    Object file        =  C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Projects #
#                          \zstack\Utilities\OAD\CC2530DB\OAD-Boot\Obj\hal_fl #
#                          ash.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Components\hal\target\CC2530EB\hal_flash.c
      1          /**************************************************************************************************
      2            Filename:       _hal_flash.c
      3            Revised:        $Date:$
      4            Revision:       $Revision:$
      5          
      6            Description: This file contains the interface to the H/W Flash driver.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb1
   \   unsigned char volatile __sfr ENCDI
   \                     ENCDI:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb2
   \   unsigned char volatile __sfr ENCDO
   \                     ENCDO:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb3
   \   unsigned char volatile __sfr ENCCS
   \                     ENCCS:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc7
   \   unsigned char volatile __sfr MEMCTR
   \                     MEMCTR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf8
   \   union <unnamed> volatile __sfr _A_U1CSR
   \                     _A_U1CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfa
   \   unsigned char volatile __sfr U1BAUD
   \                     U1BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfc
   \   unsigned char volatile __sfr U1GCR
   \                     U1GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     46          #include "hal_dma.h"
     47          #include "hal_flash.h"
     48          #include "hal_types.h"
     49          
     50          /* ------------------------------------------------------------------------------------------------
     51           *                                           Macros
     52           * ------------------------------------------------------------------------------------------------
     53           */
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                          Constants
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          // These values depend on RAM_CODE_FLASH in the .xcl file used.
     61          #if defined CC2530F64     // RemoTI is using 0x01DDD --> pg 3, offset 0x5DD.
     62          #define OSET_OF_RAM_CODE  0x5DD
     63          #define PAGE_OF_RAM_CODE  3
     64          #define SIZE_OF_RAM_CODE  0x23
     65          #elif defined HAL_OAD_BOOT_CODE
     66                                    // OAD boot code is using 0x7E3 --> pg 0, so same as offset 0x7E3.
     67          #define OSET_OF_RAM_CODE  0x7E3
     68          #define PAGE_OF_RAM_CODE  0
     69          #define SIZE_OF_RAM_CODE  0x1D
     70          #elif defined HAL_USB_BOOT_CODE
     71                                    // USB boot code is using 0x7DD --> pg 0, so same as offset 0x7DD.
     72          #define OSET_OF_RAM_CODE  0x7DD
     73          #define PAGE_OF_RAM_CODE  0
     74          #define SIZE_OF_RAM_CODE  0x23
     75          #else                     // Z-Stack is using 0x39EDD --> pg 51, offset 0x6DD.
     76          #define OSET_OF_RAM_CODE  0x6DD
     77          #define PAGE_OF_RAM_CODE  51
     78          #define SIZE_OF_RAM_CODE  0x23
     79          #endif
     80          
     81          /* ------------------------------------------------------------------------------------------------
     82           *                                          Typedefs
     83           * ------------------------------------------------------------------------------------------------
     84           */
     85          
     86          /* ------------------------------------------------------------------------------------------------
     87           *                                       Global Variables
     88           * ------------------------------------------------------------------------------------------------
     89           */
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                       Global Functions
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          
     96          /* ------------------------------------------------------------------------------------------------
     97           *                                       Local Variables
     98           * ------------------------------------------------------------------------------------------------
     99           */
    100          
    101          #pragma location="RAM_CODE_XDATA"

   \                                 In  segment RAM_CODE_XDATA, align 1
    102          static __no_init uint8 ramCode[SIZE_OF_RAM_CODE];
   \                     ??ramCode:
   \   000000                DS 29
    103          
    104          /* ------------------------------------------------------------------------------------------------
    105           *                                       Local Functions
    106           * ------------------------------------------------------------------------------------------------
    107           */
    108          
    109          #pragma location="RAM_CODE_FLASH"
    110          #if defined HAL_OAD_BOOT_CODE
    111          static void HalFlashWriteTrigger(void);
    112          #else
    113          static __monitor void HalFlashWriteTrigger(void);
    114          #endif
    115          
    116          /**************************************************************************************************
    117           * @fn          HalFlashInit
    118           *
    119           * @brief       This function initializes the environment for this module.
    120           *
    121           * input parameters
    122           *
    123           * None.
    124           *
    125           * output parameters
    126           *
    127           * None.
    128           *
    129           * @return      None.
    130           **************************************************************************************************
    131           */
    132          void HalFlashInit(void)
    133          {
    134            // Load the code to run from RAM into its reserved area of RAM once at startup.
    135            HalFlashRead(PAGE_OF_RAM_CODE, OSET_OF_RAM_CODE, ramCode, SIZE_OF_RAM_CODE);
    136          }
    137          
    138          
    139          /**************************************************************************************************
    140           * @fn          HalFlashRead
    141           *
    142           * @brief       This function reads 'cnt' bytes from the internal flash.
    143           *
    144           * input parameters
    145           *
    146           * @param       pg - A valid flash page number.
    147           * @param       offset - A valid offset into the page.
    148           * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
    149           * @param       cnt - A valid number of bytes to read.
    150           *
    151           * output parameters
    152           *
    153           * None.
    154           *
    155           * @return      None.
    156           **************************************************************************************************
    157           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    158          void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
   \                     HalFlashRead:
    159          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   740B         MOV     A,#0xb
   \   000009   12....       LCALL   ?XSTACK_DISP0_8
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   FE           MOV     R6,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FF           MOV     R7,A
    160            // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
    161            uint8 *ptr = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
    162                         ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
   \   000011   740F         MOV     A,#0xf
   \   000013   55..         ANL     A,?V0 + 0
   \   000015   F5..         MOV     ?V0 + 2,A
   \   000017   75..00       MOV     ?V0 + 3,#0x0
   \   00001A   740B         MOV     A,#0xb
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?S_SHL
   \   000021   EA           MOV     A,R2
   \   000022   2400         ADD     A,#0x0
   \   000024   F8           MOV     R0,A
   \   000025   EB           MOV     A,R3
   \   000026   3480         ADDC    A,#-0x80
   \   000028   F9           MOV     R1,A
   \   000029   E8           MOV     A,R0
   \   00002A   2400         ADD     A,#0x0
   \   00002C   E9           MOV     A,R1
   \   00002D   35..         ADDC    A,?V0 + 3
   \   00002F   F9           MOV     R1,A
    163            uint8 memctr = MEMCTR;  // Save to restore.
   \   000030   E5C7         MOV     A,0xc7
   \   000032   F5..         MOV     ?V0 + 1,A
    164          
    165          #if !defined HAL_OAD_BOOT_CODE
    166            halIntState_t is;
    167          #endif
    168          
    169            pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
    170          
    171          #if !defined HAL_OAD_BOOT_CODE
    172            HAL_ENTER_CRITICAL_SECTION(is);
    173          #endif
    174          
    175            // Calculate and map the containing flash bank into XDATA.
    176            MEMCTR = (MEMCTR & 0xF8) | pg;
   \   000034   E5..         MOV     A,?V0 + 0
   \   000036   C4           SWAP    A
   \   000037   540F         ANL     A,#0xf
   \   000039   FA           MOV     R2,A
   \   00003A   E5C7         MOV     A,0xc7
   \   00003C   54F8         ANL     A,#0xf8
   \   00003E   4A           ORL     A,R2
   \   00003F   F5C7         MOV     0xc7,A
   \   000041   801C         SJMP    ??HalFlashRead_0
    177          
    178            while (cnt--)
    179            {
    180              *buf++ = *ptr++;
   \                     ??HalFlashRead_1:
   \   000043   8882         MOV     DPL,R0
   \   000045   8983         MOV     DPH,R1
   \   000047   E0           MOVX    A,@DPTR
   \   000048   8C82         MOV     DPL,R4
   \   00004A   8D83         MOV     DPH,R5
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   8882         MOV     DPL,R0
   \   00004F   8983         MOV     DPH,R1
   \   000051   A3           INC     DPTR
   \   000052   A882         MOV     R0,DPL
   \   000054   A983         MOV     R1,DPH
   \   000056   8C82         MOV     DPL,R4
   \   000058   8D83         MOV     DPH,R5
   \   00005A   A3           INC     DPTR
   \   00005B   AC82         MOV     R4,DPL
   \   00005D   AD83         MOV     R5,DPH
    181            }
   \                     ??HalFlashRead_0:
   \   00005F   EE           MOV     A,R6
   \   000060   FA           MOV     R2,A
   \   000061   EF           MOV     A,R7
   \   000062   FB           MOV     R3,A
   \   000063   EA           MOV     A,R2
   \   000064   24FF         ADD     A,#-0x1
   \   000066   1E           DEC     R6
   \   000067   EB           MOV     A,R3
   \   000068   34FF         ADDC    A,#-0x1
   \   00006A   FF           MOV     R7,A
   \   00006B   EA           MOV     A,R2
   \   00006C   4B           ORL     A,R3
   \   00006D   70D4         JNZ     ??HalFlashRead_1
    182          
    183            MEMCTR = memctr;
   \   00006F   85..C7       MOV     0xc7,?V0 + 1
    184          
    185          #if !defined HAL_OAD_BOOT_CODE
    186            HAL_EXIT_CRITICAL_SECTION(is);
    187          #endif
    188          }
   \   000072   7F04         MOV     R7,#0x4
   \   000074   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000077                REQUIRE MEMCTR
    189          
    190          /**************************************************************************************************
    191           * @fn          HalFlashWrite
    192           *
    193           * @brief       This function writes 'cnt' bytes to the internal flash.
    194           *
    195           * input parameters
    196           *
    197           * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
    198           * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
    199           * @param       cnt - Number of 4-byte blocks to write.
    200           *
    201           * output parameters
    202           *
    203           * None.
    204           *
    205           * @return      None.
    206           **************************************************************************************************
    207           */
    208           #if HAL_DMA
    209          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
    210          {
    211            halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
    212          
    213            HAL_DMA_SET_SOURCE(ch, buf);
    214            HAL_DMA_SET_DEST(ch, &FWDATA);
    215            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
    216            HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
    217            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    218            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    219            HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
    220            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
    221            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
    222            // The DMA is to be polled and shall not issue an IRQ upon completion.
    223            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
    224            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
    225            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
    226            HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
    227            HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
    228          
    229            FADDRL = (uint8)addr;
    230            FADDRH = (uint8)(addr >> 8);
    231            HalFlashWriteTrigger();
    232          }
    233          #else
    234          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
    235          {
    236            return;
    237          }
    238           #endif
    239          
    240          /**************************************************************************************************
    241           * @fn          HalFlashErase
    242           *
    243           * @brief       This function erases the specified page of the internal flash.
    244           *
    245           * input parameters
    246           *
    247           * @param       pg - A valid flash page number to erase.
    248           *
    249           * output parameters
    250           *
    251           * None.
    252           *
    253           * @return      None.
    254           **************************************************************************************************
    255           */
    256          void HalFlashErase(uint8 pg)
    257          {
    258            FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
    259            FCTL |= 0x01;
    260          }
    261          
    262          /**************************************************************************************************
    263           * @fn          HalFlashWriteTrigger
    264           *
    265           * @brief       This function must be copied to RAM before running because it triggers and then
    266           *              awaits completion of Flash write, which can only be done from RAM.
    267           *
    268           * input parameters
    269           *
    270           * None.
    271           *
    272           * output parameters
    273           *
    274           * None.
    275           *
    276           * @return      None.
    277           **************************************************************************************************
    278           */
    279          #if defined HAL_OAD_BOOT_CODE
    280          #pragma optimize=medium

   \                                 In  segment RAM_CODE_FLASH, align 1, keep-with-next
    281          static void HalFlashWriteTrigger(void)
   \                     ??HalFlashWriteTrigger:
    282          #else
    283          static __monitor void HalFlashWriteTrigger(void)
    284          #endif
    285          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    286            MEMCTR |= 0x08;       // Start the Memory Arbiter running CODE from RAM.
   \   000004   43C708       ORL     0xc7,#0x8
    287            FCTL |= 0x02;         // Trigger the DMA writes.
   \   000007   906270       MOV     DPTR,#0x6270
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   D2E1         SETB    0xE0 /* A   */.1
   \   00000D   F0           MOVX    @DPTR,A
    288            while (FCTL & 0x80);  // Wait until writing is done.
   \                     ??HalFlashWriteTrigger_1:
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000011   40FB         JC      ??HalFlashWriteTrigger_1
    289            MEMCTR &= ~0x08;      // Stop the Memory Arbiter.
   \   000013   53C7F7       ANL     0xc7,#0xf7
    290          }
   \   000016   D083         POP     DPH
   \   000018   D082         POP     DPL
   \   00001A   22           RET
   \   00001B                REQUIRE MEMCTR
    291          
    292          /**************************************************************************************************
    293          */
C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Components\hal\target\CC2530EB\hal_oad.c
      1          /**************************************************************************************************
      2            Filename:       _hal_oad.c
      3            Revised:        $Date: 2008-01-17 12:32:06 -0800 (Thu, 17 Jan 2008) $
      4            Revision:       $Revision: 16224 $
      5          
      6            Description:    This module contains optionally-compiled Boot Code to support OAD.
      7                            The rest of the functionality is the H/W specific drivers to read/write
      8                            the flash/NV containing the ACTIVE and the DOWNLOADED images.
      9            Notes:          This version targets the Texas Instruments CC2x3x family of processors.
     10          
     11          
     12            Copyright 2008-2009 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com.
     41          **************************************************************************************************/
     42          
     43          /* ------------------------------------------------------------------------------------------------
     44           *                                          Includes
     45           * ------------------------------------------------------------------------------------------------
     46           */
     47          #include <ioCC2530.h>
     48          #include "comdef.h"
     49          #include "hal_board_cfg.h"
     50          #include "hal_dma.h"
     51          #include "hal_flash.h"
     52          #include "hal_oad.h"
     53          #include "hal_types.h"
     54          //#include "hal_aes.h"
     55          
     56          /* ------------------------------------------------------------------------------------------------
     57           *                                           Macros
     58           * ------------------------------------------------------------------------------------------------
     59           */
     60          
     61          /* ------------------------------------------------------------------------------------------------
     62           *                                          Constants
     63           * ------------------------------------------------------------------------------------------------
     64           */
     65          
     66          /* ------------------------------------------------------------------------------------------------
     67           *                                          Typedefs
     68           * ------------------------------------------------------------------------------------------------
     69           */
     70          
     71          /* ------------------------------------------------------------------------------------------------
     72           *                                       Global Variables
     73           * ------------------------------------------------------------------------------------------------
     74           */
     75          
     76          /* ------------------------------------------------------------------------------------------------
     77           *                                       Global Functions
     78           * ------------------------------------------------------------------------------------------------
     79           */
     80          
     81          /* ------------------------------------------------------------------------------------------------
     82           *                                       Local Variables
     83           * ------------------------------------------------------------------------------------------------
     84           */
     85          
     86          #if HAL_OAD_BOOT_CODE

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     87          halDMADesc_t dmaCh0;
   \                     dmaCh0:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
     88          #endif
     89          
     90          /* ------------------------------------------------------------------------------------------------
     91           *                                       Local Functions
     92           * ------------------------------------------------------------------------------------------------
     93           */
     94          
     95          static uint16 runPoly(uint16 crc, uint8 val);
     96          
     97          #define	 ucLDR_Security_F	(*(unsigned char *)0x100)	
     98          #define	 start_flag	(*(unsigned char *)0x101)	
     99          #define	 ucLDR_Ret	(*(unsigned char *)0x102)
    100          #define	 ucLDR_Message	(*(Uart_message *)0x110)
    101          #define	 stCommand	(*(union  u_stCommand *)0x1E0)	
    102          #define	 ucLDR_WorkRam	(*(unsigned char *)0x200)
    103          //#define 	 dmaCh0		(*(halDMADesc_t*)0x201)
    104          
    105          #define LED_1 P1_3
    106          #define LED_2 P1_4
    107          
    108          // _mode_ is one of
    109          #define CBC         0x00
    110          #define CFB         0x10
    111          #define OFB         0x20
    112          #define CTR         0x30
    113          #define ECB         0x40
    114          #define CBC_MAC     0x50
    115          
    116          #define AES_BUSY    0x08
    117          #define ENCRYPT     0x00
    118          #define DECRYPT     0x01
    119          
    120          // Macro for starting or stopping encryption or decryption
    121          #define AES_SET_ENCR_DECR_KEY_IV(mode) \
    122             do {                                \
    123              ENCCS = (ENCCS & ~0x07) | mode     \
    124             } while(0)
    125          
    126          // Where _mode_ is one of
    127          #define AES_ENCRYPT     0x00;
    128          #define AES_DECRYPT     0x02;
    129          #define AES_LOAD_KEY    0x04;
    130          #define AES_LOAD_IV     0x06;
    131          
    132          #define LENGTH_IV  16
    133          #define LENGTH_KEY 16
    134          
    135          #define STRING_LENGTH       16
    136          
    137          
    138          // Macro for setting the mode of the AES operation
    139          #define AES_SETMODE(mode) do { ENCCS &= ~0x70; ENCCS |= mode; } while (0)
    140          
    141          // Macro for starting the AES module for either encryption, decryption,
    142          // key or initialisation vector loading.
    143          #define AES_START()     ENCCS |= 0x01
    144          
    145          #define DELAY 0x0F
    146          
    147          typedef unsigned char       BOOL;
    148          
    149          // Data
    150          typedef unsigned char       BYTE;
    151          typedef unsigned short      WORD;
    152          typedef unsigned long       DWORD;
    153          
    154          // Unsigned numbers
    155          typedef unsigned char       UINT8;
    156          typedef unsigned short      UINT16;
    157          typedef unsigned long       UINT32;
    158          
    159          // Signed numbers
    160          typedef signed char         INT8;
    161          typedef signed short        INT16;
    162          typedef signed long         INT32;
    163          
    164          #if HAL_OAD_XNV_IS_SPI
    165          //static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len);
    166          //static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len);
    167          static unsigned char RcvData(void);
    168          static unsigned char Message_Rcv(void);
    169          static void Message_Send(void);
    170          static void SendData(char dat);
    171          static void delay(unsigned int de);
    172          static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key);
    173          static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr);
    174          #endif
    175          
    176          #if HAL_OAD_BOOT_CODE
    177          static void dl2rc(void);
    178          static uint16 crcCalc(void);
    179          static void InitUart(void);
    180          static void Uart_Send_String(char *Data,int len);
    181          #endif
    182          
    183          /**************************************************************************************************
    184           * @fn          main
    185           *
    186           * @brief       ISR for the reset vector.
    187           *
    188           * input parameters
    189           *
    190           * None.
    191           *
    192           * output parameters
    193           *
    194           * None.
    195           *
    196           * @return      None.
    197           **************************************************************************************************
    198           */
    199           
    200          //#pragma location="RAM_CODE_XDATA"
    201          
    202          //unsigned char ucLDR_Security_F;
    203          //unsigned char start_flag;
    204          //unsigned char ucLDR_Ret;
    205          //Uart_message ucLDR_Message;
    206          //unsigned char ucLDR_WorkRam;
    207          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    208           char *g_decKey = "WorkForYourDream";
   \                     g_decKey:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for g_decKey>`
   \   000002                REQUIRE __INIT_XDATA_I
    209           //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    210          
    211          #pragma location="NEAR_CODE"
    212          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    213          void main(void)
   \                     main:
    214          {
   \   000000                ; Auto size: 0
    215            //uint16 crc[2];
    216            //uint8 g_extAddr[8] = {0x38,0x15,0xC6,0xFE,0xFF,0x17,0x87,0x88};
    217            uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;
   \   000000   7E00         MOV     R6,#0x0
   \   000002   7F02         MOV     R7,#0x2
    218            uint16 oset;
    219            uint8 page=HAL_OAD_RC_START/HAL_FLASH_PAGE_SIZE;
   \   000004   75..01       MOV     ?V0 + 2,#0x1
    220            uint8 buf[16];
    221           // char *g_decKey = "WorkForYourDream";
    222           //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    223            //uint8 buf[8] = {0};  
    224          
    225            HAL_BOARD_INIT();
   \   000007   53BEFB       ANL     0xbe,#0xfb
   \                     ??main_0:
   \   00000A   E59D         MOV     A,0x9d
   \   00000C   A2E6         MOV     C,0xE0 /* A   */.6
   \   00000E   50FA         JNC     ??main_0
   \   000010   00           NOP
   \   000011   78F8         MOV     R0,#-0x8
   \   000013   7901         MOV     R1,#0x1
   \                     ??main_1:
   \   000015   00           NOP
   \   000016   E8           MOV     A,R0
   \   000017   24FF         ADD     A,#-0x1
   \   000019   18           DEC     R0
   \   00001A   E9           MOV     A,R1
   \   00001B   34FF         ADDC    A,#-0x1
   \   00001D   F9           MOV     R1,A
   \   00001E   E8           MOV     A,R0
   \   00001F   49           ORL     A,R1
   \   000020   70F3         JNZ     ??main_1
   \   000022   75C680       MOV     0xc6,#-0x80
   \                     ??main_2:
   \   000025   7480         MOV     A,#-0x80
   \   000027   659E         XRL     A,0x9e
   \   000029   70FA         JNZ     ??main_2
   \   00002B   43BE04       ORL     0xbe,#0x4
   \   00002E   906270       MOV     DPTR,#0x6270
   \   000031   7408         MOV     A,#0x8
   \   000033   F0           MOVX    @DPTR,A
   \   000034   43FE04       ORL     0xfe,#0x4
   \   000037   43FD80       ORL     0xfd,#0x80
   \   00003A   438F01       ORL     0x8f,#0x1
   \   00003D   43FE04       ORL     0xfe,#0x4
   \   000040   43FE08       ORL     0xfe,#0x8
    226          #if HAL_OAD_XNV_IS_SPI
    227            XNV_SPI_INIT(); 
   \   000043   75F800       MOV     0xf8,#0x0
   \   000046   75FC0B       MOV     0xfc,#0xb
   \   000049   75FAD8       MOV     0xfa,#-0x28
   \   00004C   43FC20       ORL     0xfc,#0x20
   \   00004F   43F102       ORL     0xf1,#0x2
   \   000052   43F4E0       ORL     0xf4,#0xe0
   \   000055   53F4F1       ANL     0xf4,#0xf1
   \   000058   43900E       ORL     0x90,#0xe
   \   00005B   C291         CLR     0x90.1
   \   00005D   43FE0E       ORL     0xfe,#0xe
   \   000060   53F5DF       ANL     0xf5,#0xdf
   \   000063   D2FE         SETB    0xf8.6
   \   000065   D291         SETB    0x90.1
    228          #endif
    229            /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
    230             * descriptors in addition to just Channel 0.
    231             */
    232            HAL_DMA_SET_ADDR_DESC0( &dmaCh0 );
                   ^
Warning[Pe069]: integer conversion resulted in truncation
   \   000067   74..         MOV     A,#(dmaCh0 >> 8) & 0xff
   \   000069   F5D5         MOV     0xd5,A
   \   00006B   75D4..       MOV     0xd4,#dmaCh0 & 0xff
    233            HalFlashInit();
   \   00006E                ; Setup parameters for call to function HalFlashRead
   \   00006E   75..1D       MOV     ?V0 + 0,#0x1d
   \   000071   8E..         MOV     ?V0 + 1,R6
   \   000073   78..         MOV     R0,#?V0 + 0
   \   000075   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000078   7C..         MOV     R4,#??ramCode & 0xff
   \   00007A   7D..         MOV     R5,#(??ramCode >> 8) & 0xff
   \   00007C   7AE3         MOV     R2,#-0x1d
   \   00007E   7B07         MOV     R3,#0x7
   \   000080   7900         MOV     R1,#0x0
   \   000082   12....       LCALL   HalFlashRead
   \   000085   EF           MOV     A,R7
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
    234          
    235          #ifdef _USER_OAD_FLASH_WRITE_
    236            HalFlashRead(HAL_OAD_CRC_ADDR / HAL_FLASH_PAGE_SIZE,
    237                         HAL_OAD_CRC_ADDR % HAL_FLASH_PAGE_SIZE,
    238                         (uint8 *)crc, sizeof(crc));
    239          
    240          
    241            if (crc[0] != crc[1])
    242            {
    243              // If the CRC is erased or the RC code fails a sanity check, instantiate the DL code (again).
    244              if ((crc[0] == 0) || (crc[0] != crcCalc()))
    245              {
    246                dl2rc();
    247          
    248                /* If dl2rc() fails, a flawed image is allowed to run - 
    249                 * maybe the damage is not fatal to OTA ops?
    250                 */
    251              }
    252              else
    253              {
    254                crc[1] = crc[0];
    255                HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
    256              }
    257            }
    258          #endif
    259          
    260            //InitUart();
    261            //Uart_Send_String("boot",4);
    262            
    263            //P1DIR &=( ~0x04);
    264            //P1DIR |= 0x08;				//P1_3
    265            //P1DIR |= 0x08;
    266            //P1DIR |= 0x10;
    267            //P1DIR |= 0x18;
    268            //P1_3 = 0;
    269            //P1_4 = 0;
    270            P0DIR &= 0xDF;
   \   000089   53FDDF       ANL     0xfd,#0xdf
    271            //P0DIR |= 0x20;					//P05
    272            InitUart();
   \   00008C   53C6BF       ANL     0xc6,#0xbf
   \                     ??main_3:
   \   00008F   E59E         MOV     A,0x9e
   \   000091   A2E6         MOV     C,0xE0 /* A   */.6
   \   000093   40FA         JC      ??main_3
   \   000095   53C6B8       ANL     0xc6,#0xb8
   \   000098   75F100       MOV     0xf1,#0x0
   \   00009B   75F33C       MOV     0xf3,#0x3c
   \   00009E   53FF3F       ANL     0xff,#0x3f
   \   0000A1   438680       ORL     0x86,#0x80
   \   0000A4   43C50B       ORL     0xc5,#0xb
   \   0000A7   43C2D8       ORL     0xc2,#0xd8
   \   0000AA   C2E9         CLR     0xe8.1
   \   0000AC   438640       ORL     0x86,#0x40
   \   0000AF   C28B         CLR     0x88.3
    273            AES_SETMODE(ECB);
   \   0000B1   53B38F       ANL     0xb3,#0x8f
   \   0000B4   43B340       ORL     0xb3,#0x40
    274            halAesLoadKeyOrInitVector(g_decKey, TRUE);
                                             ^
Warning[Pe167]: argument of type "char *" is incompatible with parameter of
          type "BYTE *"

    uint8 buf[16];
          ^
"C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Components\hal\target\CC2530EB\hal_oad.c",220  Warning[Pe177]: 
          variable "buf" was declared but never referenced
   \   0000B7   90....       MOV     DPTR,#g_decKey
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F8           MOV     R0,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   F9           MOV     R1,A
   \   0000BF   E5B3         MOV     A,0xb3
   \   0000C1   54F8         ANL     A,#0xf8
   \   0000C3   4404         ORL     A,#0x4
   \   0000C5   F5B3         MOV     0xb3,A
   \   0000C7   43B301       ORL     0xb3,#0x1
   \   0000CA   7A00         MOV     R2,#0x0
   \                     ??main_4:
   \   0000CC   8A..         MOV     ?V0 + 0,R2
   \   0000CE   E8           MOV     A,R0
   \   0000CF   25..         ADD     A,?V0 + 0
   \   0000D1   F582         MOV     DPL,A
   \   0000D3   E9           MOV     A,R1
   \   0000D4   3400         ADDC    A,#0x0
   \   0000D6   F583         MOV     DPH,A
   \   0000D8   E0           MOVX    A,@DPTR
   \   0000D9   F5B1         MOV     0xb1,A
   \   0000DB   0A           INC     R2
   \   0000DC   EA           MOV     A,R2
   \   0000DD   C3           CLR     C
   \   0000DE   9410         SUBB    A,#0x10
   \   0000E0   40EA         JC      ??main_4
    275            
    276           //if(!P1_2)
    277            if(!P0_5)
   \   0000E2   A285         MOV     C,0x80.5
   \   0000E4   7C04         MOV     R4,#0x4
   \   0000E6   7D00         MOV     R5,#0x0
   \   0000E8   5003         JNC     $+5
   \   0000EA   02....       LJMP    ??main_5
    278            {
    279          
    280          	Uart_Send_String("boot",4);
   \   0000ED                ; Setup parameters for call to function Uart_Send_String
   \   0000ED   7A..         MOV     R2,#`?<Constant "boot">` & 0xff
   \   0000EF   7B..         MOV     R3,#(`?<Constant "boot">` >> 8) & 0xff
   \   0000F1   12....       LCALL   ??Uart_Send_String
    281                  P1DIR |= 0x18;
   \   0000F4   43FE18       ORL     0xfe,#0x18
    282                  P1_4 = 0;
   \   0000F7   C294         CLR     0x90.4
   \   0000F9   803F         SJMP    ??main_6
    283          	
    284          	while(1)
    285          	{
    286          		if(Message_Rcv())
    287          		{	
    288          			//P1_3 = !P1_3;
    289          			ucLDR_Security_F = 0;
    290          			ucLDR_Ret = 0x00;
    291          			//Uart_Send_String("rcv",3);
    292          #if 1
    293          			switch(ucLDR_Message.protocol_command )
    294          			{
    295          
    296          				case AM1_IAP_READ_64BYTE:
    297          #if 1
    298          					//P1_3 = !P1_3;
    299                                             //     P1_4 = !P1_4;
    300          				  	for (oset = 0; oset < HAL_FLASH_PAGE_SIZE; oset += 64)
   \                     ??main_7:
   \   0000FB   75..00       MOV     ?V0 + 0,#0x0
   \   0000FE   75..00       MOV     ?V0 + 1,#0x0
    301          				  	{
    302          						HalFlashRead(page,oset,ucLDR_Message.com_data,64);
   \                     ??main_8:
   \   000101                ; Setup parameters for call to function HalFlashRead
   \   000101   75..40       MOV     ?V0 + 4,#0x40
   \   000104   75..00       MOV     ?V0 + 5,#0x0
   \   000107   78..         MOV     R0,#?V0 + 4
   \   000109   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010C   7C14         MOV     R4,#0x14
   \   00010E   7D01         MOV     R5,#0x1
   \   000110   AA..         MOV     R2,?V0 + 0
   \   000112   AB..         MOV     R3,?V0 + 1
   \   000114   A9..         MOV     R1,?V0 + 2
   \   000116   12....       LCALL   HalFlashRead
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
    303          						ucLDR_Message.data_length=64;
   \   00011E   900113       MOV     DPTR,#0x113
   \   000121   7440         MOV     A,#0x40
   \   000123   F0           MOVX    @DPTR,A
    304          						Message_Send();		
   \   000124                ; Setup parameters for call to function Message_Send
   \   000124   12....       LCALL   ??Message_Send
    305          						//Uart_Send_String(buf,4);
    306          					
    307          				  	}
   \   000127   E5..         MOV     A,?V0 + 0
   \   000129   2440         ADD     A,#0x40
   \   00012B   F5..         MOV     ?V0 + 0,A
   \   00012D   E5..         MOV     A,?V0 + 1
   \   00012F   3400         ADDC    A,#0x0
   \   000131   F5..         MOV     ?V0 + 1,A
   \   000133   C3           CLR     C
   \   000134   9408         SUBB    A,#0x8
   \   000136   40C9         JC      ??main_8
    308          					page++;
   \   000138   05..         INC     ?V0 + 2
    309          #endif
    310          				break;
   \                     ??main_6:
   \   00013A                ; Setup parameters for call to function Message_Rcv
   \   00013A   12....       LCALL   ??Message_Rcv
   \   00013D   E9           MOV     A,R1
   \   00013E   60FA         JZ      ??main_6
   \   000140   900100       MOV     DPTR,#0x100
   \   000143   E4           CLR     A
   \   000144   F0           MOVX    @DPTR,A
   \   000145   900102       MOV     DPTR,#0x102
   \   000148   F0           MOVX    @DPTR,A
   \   000149   900111       MOV     DPTR,#0x111
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   24BF         ADD     A,#-0x41
   \   00014F   600C         JZ      ??main_9
   \   000151   14           DEC     A
   \   000152   7003         JNZ     $+5
   \   000154   02....       LJMP    ??main_10
   \   000157   24FB         ADD     A,#-0x5
   \   000159   60A0         JZ      ??main_7
   \   00015B   80DD         SJMP    ??main_6
    311          /*
    312          				case BOOT_FIRMWARE_VERSION:
    313          					ucLDR_Message.com_data[0]=1;
    314          					ucLDR_Message.com_data[1]=0;      
    315          					ucLDR_Message.com_data[12]=5;	//for AM1_IAP
    316          					ucLDR_Message.data_length=20;
    317          					Message_Send();
    318          					break;
    319          					
    320          				case AM1_IAP_READ_64BYTE:
    321          					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
    322          					stCommand.Program_Lib.dst_adr	+= 64;
    323          					if( stCommand.Program_Lib.dst_adr == 0x00 )
    324          					stCommand.Program_Lib.dst_bank++;	
    325          					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
    326          					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
    327          					ucLDR_Read_64Byte_Ram();
    328          					ucLDR_Message.data_length=64;
    329          					Message_Send();
    330          					break;
    331          
    332          						
    333          				case AM1_IAP_READ_STATUS:
    334          					stCommand.ReadStatus_Lib.ram_adr = (unsigned char*)&ucLDR_WorkRam;
    335          					ucLDR_Ret=0;//test
    336          					ucLDR_ReadStatus_Ram();//test
    337          					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
    338          					ucLDR_Message.data_length=2;
    339          					Message_Send();
    340          					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
    341          					stCommand.Program_Lib.dst_bank	= 0;	
    342          					break;
    343          
    344          					  
    345          				case AM1_IAP_SECURITYCHECK:
    346          		 			stCommand.Security_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam;
    347          			 		stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
    348          					ucLDR_Ret = 0x00;
    349          					ucLDR_SecurityCheck_Ram();
    350          					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
    351          					ucLDR_Message.data_length=2;		
    352          					Message_Send();
    353          					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
    354          					stCommand.Program_Lib.dst_bank	= 0;	
    355          				      break;
    356          */
    357          						
    358          	//=================================================================================
    359          				case AM1_IAP_WRITE_PAGE:	
    360          /*
    361          					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
    362          					stCommand.Program_Lib.dst_adr	+= 64;
    363          					if( stCommand.Program_Lib.dst_adr == 0x00 )
    364          					stCommand.Program_Lib.dst_bank++;	
    365          					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
    366          					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
    367          					ucLDR_Ret=0x00;//test	
    368          					ucLDR_Program_Ram();//test
    369          */
    370          					halAesEncrDecr((BYTE *)ucLDR_Message.com_data, STRING_LENGTH, (BYTE *)ucLDR_Message.com_data/*, ucLDR_Message.com_data*/, DECRYPT);
   \                     ??main_9:
   \   00015D                ; Setup parameters for call to function halAesEncrDecr
   \   00015D   75..14       MOV     ?V0 + 0,#0x14
   \   000160   75..01       MOV     ?V0 + 1,#0x1
   \   000163   78..         MOV     R0,#?V0 + 0
   \   000165   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000168   7901         MOV     R1,#0x1
   \   00016A   7C10         MOV     R4,#0x10
   \   00016C   7D00         MOV     R5,#0x0
   \   00016E   7A14         MOV     R2,#0x14
   \   000170   7B01         MOV     R3,#0x1
   \   000172   12....       LCALL   ??halAesEncrDecr
   \   000175   7402         MOV     A,#0x2
   \   000177   12....       LCALL   ?DEALLOC_XSTACK8
    371          					//Uart_Send_String((BYTE *)buf,16);
    372          					if ((addr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
   \   00017A   EE           MOV     A,R6
   \   00017B   F8           MOV     R0,A
   \   00017C   EF           MOV     A,R7
   \   00017D   5401         ANL     A,#0x1
   \   00017F   F9           MOV     R1,A
   \   000180   E8           MOV     A,R0
   \   000181   49           ORL     A,R1
   \   000182   701A         JNZ     ??main_11
    373          					{
    374          						HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
   \   000184   8E..         MOV     ?V0 + 0,R6
   \   000186   8F..         MOV     ?V0 + 1,R7
   \   000188   7409         MOV     A,#0x9
   \   00018A   78..         MOV     R0,#?V0 + 0
   \   00018C   12....       LCALL   ?US_SHR
   \   00018F   E5..         MOV     A,?V0 + 0
   \   000191   C3           CLR     C
   \   000192   33           RLC     A
   \   000193   906272       MOV     DPTR,#0x6272
   \   000196   F0           MOVX    @DPTR,A
   \   000197   906270       MOV     DPTR,#0x6270
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   D2E0         SETB    0xE0 /* A   */.0
   \   00019D   F0           MOVX    @DPTR,A
    375          					}
    376          					//HalFlashWrite(addr++, ucLDR_Message.com_data, 1);
    377          					HalFlashWrite(addr, ucLDR_Message.com_data, ucLDR_Message.data_length/4);
   \                     ??main_11:
   \   00019E   900113       MOV     DPTR,#0x113
   \   0001A1   E0           MOVX    A,@DPTR
   \   0001A2   13           RRC     A
   \   0001A3   13           RRC     A
   \   0001A4   543F         ANL     A,#0x3f
   \   0001A6   F8           MOV     R0,A
   \   0001A7   90....       MOV     DPTR,#dmaCh0
   \   0001AA   7401         MOV     A,#0x1
   \   0001AC   F0           MOVX    @DPTR,A
   \   0001AD   A3           INC     DPTR
   \   0001AE   7414         MOV     A,#0x14
   \   0001B0   F0           MOVX    @DPTR,A
   \   0001B1   A3           INC     DPTR
   \   0001B2   7462         MOV     A,#0x62
   \   0001B4   F0           MOVX    @DPTR,A
   \   0001B5   A3           INC     DPTR
   \   0001B6   7473         MOV     A,#0x73
   \   0001B8   F0           MOVX    @DPTR,A
   \   0001B9   A3           INC     DPTR
   \   0001BA   E0           MOVX    A,@DPTR
   \   0001BB   541F         ANL     A,#0x1f
   \   0001BD   F0           MOVX    @DPTR,A
   \   0001BE   E8           MOV     A,R0
   \   0001BF   33           RLC     A
   \   0001C0   33           RLC     A
   \   0001C1   54FC         ANL     A,#0xfc
   \   0001C3   A3           INC     DPTR
   \   0001C4   F0           MOVX    @DPTR,A
   \   0001C5   90....       MOV     DPTR,#dmaCh0 + 4
   \   0001C8   E4           CLR     A
   \   0001C9   F0           MOVX    @DPTR,A
   \   0001CA   90....       MOV     DPTR,#dmaCh0 + 6
   \   0001CD   7412         MOV     A,#0x12
   \   0001CF   F0           MOVX    @DPTR,A
   \   0001D0   A3           INC     DPTR
   \   0001D1   7442         MOV     A,#0x42
   \   0001D3   F0           MOVX    @DPTR,A
   \   0001D4   53D1FE       ANL     0xd1,#0xfe
   \   0001D7   75D601       MOV     0xd6,#0x1
   \   0001DA   EE           MOV     A,R6
   \   0001DB   906271       MOV     DPTR,#0x6271
   \   0001DE   F0           MOVX    @DPTR,A
   \   0001DF   EF           MOV     A,R7
   \   0001E0   A3           INC     DPTR
   \   0001E1   F0           MOVX    @DPTR,A
   \   0001E2                ; Setup parameters for call to function HalFlashWriteTrigger
   \   0001E2   12....       LCALL   ??HalFlashWriteTrigger
    378          					addr+=(ucLDR_Message.data_length/4);
   \   0001E5   900113       MOV     DPTR,#0x113
   \   0001E8   E0           MOVX    A,@DPTR
   \   0001E9   13           RRC     A
   \   0001EA   13           RRC     A
   \   0001EB   543F         ANL     A,#0x3f
   \   0001ED   F8           MOV     R0,A
   \   0001EE   EE           MOV     A,R6
   \   0001EF   28           ADD     A,R0
   \   0001F0   FE           MOV     R6,A
   \   0001F1   EF           MOV     A,R7
   \   0001F2   3400         ADDC    A,#0x0
   \   0001F4   FF           MOV     R7,A
    379          					delay(1000);
    380          				    //ucLDR_Read_64Byte_Ram();
    381          					ucLDR_Message.com_data[0]=0x00;
   \   0001F5   A3           INC     DPTR
   \   0001F6   E4           CLR     A
   \   0001F7   F0           MOVX    @DPTR,A
    382          					ucLDR_Message.data_length=2;
   \   0001F8   900113       MOV     DPTR,#0x113
   \   0001FB   7402         MOV     A,#0x2
   \                     ??main_12:
   \   0001FD   F0           MOVX    @DPTR,A
    383          					Message_Send();					
   \   0001FE                ; Setup parameters for call to function Message_Send
   \   0001FE   12....       LCALL   ??Message_Send
    384          					break;
   \   000201   02....       LJMP    ??main_6
    385          
    386          				case AM1_IAP_ERASE_DEVICE:
    387          					ucLDR_Message.com_data[0]=0x55;
   \                     ??main_10:
   \   000204   900114       MOV     DPTR,#0x114
   \   000207   7455         MOV     A,#0x55
   \   000209   F0           MOVX    @DPTR,A
    388          					ucLDR_Message.com_data[1]=0x00;
   \   00020A   A3           INC     DPTR
   \   00020B   E4           CLR     A
   \   00020C   F0           MOVX    @DPTR,A
    389          					ucLDR_Message.data_length=3;
   \   00020D   900113       MOV     DPTR,#0x113
   \   000210   7403         MOV     A,#0x3
   \   000212   80E9         SJMP    ??main_12
    390          					Message_Send();	
    391          				break;
    392          	//=================================================================================
    393          /*
    394          				case AM1_IAP_ERASE_DEVICE:		
    395          					ucLDR_Security_F = 0;
    396          					stCommand.ReadStatus_Lib.ram_adr = &ucLDR_WorkRam;
    397          					ucLDR_Ret=0;//test
    398          					ucLDR_ReadStatus_Ram();//test
    399          					if( (ucLDR_Ret&0x01) == 0x01 )
    400          						{
    401          						ucLDR_Message.com_data[0]=0x55;// No Key	
    402          						ucLDR_Security_F=1;
    403          					     }
    404          					else
    405          						{
    406          						ucLDR_Ret = 0x00;
    407          			 			stCommand.Security_Lib.ram_adr	= &ucLDR_WorkRam;
    408          			 			stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
    409          						ucLDR_SecurityCheck_Ram();
    410          						if( ucLDR_Ret != 0x00 )
    411          							{
    412          							ucLDR_Message.com_data[0]=0xEE;   //Key Verify error
    413          			
    414          							}
    415          						else
    416          							{
    417          							 ucLDR_Message.com_data[0]=0xaa ;//Key Verify Pass
    418          		                                 ucLDR_Security_F=1;
    419          						       }
    420          						}
    421          
    422          						 if(ucLDR_Security_F==1)
    423          							{
    424          								stCommand.Erase_Lib.ram_adr	= &ucLDR_WorkRam;
    425          								ucLDR_Ret=0x00;//test
    426          								ucLDR_Erase_Ram();//test
    427          								ucLDR_Message.com_data[1]= ucLDR_Ret;
    428          								#if 0
    429          								if(ucLDR_Ret==0)
    430          								{
    431          								stCommand.Secter_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam[0];
    432          								ucLDR_Ret=0x00;//test
    433          								ucLDR_BankCheck_Ram();  //test 
    434          								ucLDR_Message.com_data[2]=ucLDR_Ret;
    435          								}
    436          								#endif
    437          							}
    438          					delay(60000);		
    439          					stCommand.Program_Lib.dst_adr	= (unsigned char*)(0x4000-64);	   
    440          					stCommand.Program_Lib.dst_bank	= 0;
    441          					Message_Send();	
    442          					break;
    443          */
    444          //=================================================================================
    445          				  default:
    446          					//Message_Send();		
    447          					break;
    448          				}
    449          #endif
    450          		}
    451          		//start_flag = 0;
    452          		//InitUart();
    453          		//Uart_Send_String("test",4);
    454          		//P1_3 = !P1_3;
    455          
    456          	}
    457            }else
    458            {
    459            	Uart_Send_String("jump",4);
   \                     ??main_5:
   \   000214                ; Setup parameters for call to function Uart_Send_String
   \   000214   7A..         MOV     R2,#`?<Constant "jump">` & 0xff
   \   000216   7B..         MOV     R3,#(`?<Constant "jump">` >> 8) & 0xff
   \   000218   12....       LCALL   ??Uart_Send_String
    460          	//asm("LJMP 0x2000\n");
    461          	asm("LJMP 0x800\n");
   \   00021B   020800       LJMP 0x800
    462          	//asm("LJMP 0x2000\n");
    463          	//asm("LJMP 0x1000\n");
    464          	//asm("LJMP 0x5000\n");
    465            }
    466            
    467            //Uart_Send_String("boot",4);
    468            /*
    469            for(page=0;page<10;page++)
    470            {
    471            	for (oset = 0; oset < 512; oset += HAL_FLASH_WORD_SIZE)
    472            	{
    473          		HalFlashRead(page,oset,buf,4);
    474          		Uart_Send_String(buf,4);
    475          	
    476            	}
    477            }*/
    478            //HalFlashInit();
    479            //HalFlashWrite(addr++, buf, 1);
    480          
    481            //HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
    482            //HalFlashWrite(addr, g_extAddr, 1);
    483            //HalFlashWrite(addr+1, g_extAddr+4, 2);
    484            //HalFlashRead(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE),0,g_extAddr,8);
    485            //Uart_Send_String(g_extAddr,8);
    486            
    487            // Simulate a reset for the Application code by an absolute jump to location 0x0800.
    488            //asm("LJMP 0x800\n");
    489          }
   \   00021E   22           RET
   \   00021F                REQUIRE SLEEPCMD
   \   00021F                REQUIRE SLEEPSTA
   \   00021F                REQUIRE CLKCONCMD
   \   00021F                REQUIRE CLKCONSTA
   \   00021F                REQUIRE P1DIR
   \   00021F                REQUIRE P0DIR
   \   00021F                REQUIRE P0INP
   \   00021F                REQUIRE _A_U1CSR
   \   00021F                REQUIRE U1GCR
   \   00021F                REQUIRE U1BAUD
   \   00021F                REQUIRE PERCFG
   \   00021F                REQUIRE P1SEL
   \   00021F                REQUIRE _A_P1
   \   00021F                REQUIRE P2SEL
   \   00021F                REQUIRE DMA0CFGH
   \   00021F                REQUIRE DMA0CFGL
   \   00021F                REQUIRE ENCCS
   \   00021F                REQUIRE _A_P0
   \   00021F                REQUIRE ENCDI
   \   00021F                REQUIRE P0SEL
   \   00021F                REQUIRE P2DIR
   \   00021F                REQUIRE U0CSR
   \   00021F                REQUIRE U0GCR
   \   00021F                REQUIRE U0BAUD
   \   00021F                REQUIRE _A_IRCON2
   \   00021F                REQUIRE _A_TCON
   \   00021F                REQUIRE DMAIRQ
   \   00021F                REQUIRE DMAARM
    490          
    491          static void InitUart(void)
    492          {
    493              CLKCONCMD &= ~0x40; // ÉèÖÃÏµÍ³Ê±ÖÓÔ´Îª 32MHZ¾§Õñ
    494              while(CLKCONSTA & 0x40);                     // µÈ´ý¾§ÕñÎÈ¶¨ 
    495              CLKCONCMD &= ~0x47;                          // ÉèÖÃÏµÍ³Ö÷Ê±ÖÓÆµÂÊÎª 32MHZ
    496          
    497              PERCFG = 0x00;        //Î»ÖÃ1 P0¿Ú 
    498              P0SEL = 0x3c;        //P0_2,P0_3,P0_4,P0_5ÓÃ×÷´®¿Ú,µÚ¶þ¹¦ÄÜ 
    499              //P0DIR |= 0x08;
    500              P2DIR &= ~0XC0;      //P0 ÓÅÏÈ×÷ÎªUART0 £¬ÓÅÏÈ¼¶
    501              //PERCFG &= ~(BV(0)); //Ñ¡ÔñP0¶Ë¿Úuart
    502              //P0SEL |=BV(5)|BV(4)|BV(3)|BV(2);
    503              //P2DIR &=~(BV(7)|BV(6));
    504          
    505              U0CSR |= 0x80;       //UART ·½Ê½ 
    506              U0GCR |= 11;         //U0GCRÓëU0BAUDÅäºÏ     
    507              U0BAUD |= 216;       // ²¨ÌØÂÊÉèÎª115200 
    508              UTX0IF = 0;          //UART0 TX ÖÐ¶Ï±êÖ¾³õÊ¼ÖÃÎ»1  £¨ÊÕ·¢Ê±ºò£©
    509              U0CSR |= 0X40;       //ÔÊÐí½ÓÊÕ 
    510             // IEN0 |= 0x84;        // ¿ª×ÜÖÐ¶Ï£¬½ÓÊÕÖÐ¶Ï    
    511          
    512             URX0IF = 0;
    513          
    514            // P1_3 = !P1_3;
    515          }
    516          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    517          static void SendData(char dat)
   \                     ??SendData:
    518          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    519          	U0DBUF = dat;
   \   000000   89C1         MOV     0xc1,R1
    520          	while(!UTX0IF);
   \                     ??SendData_1:
   \   000002   A2E9         MOV     C,0xe8.1
   \   000004   50FC         JNC     ??SendData_1
    521          	UTX0IF = 0; 	
   \   000006   C2E9         CLR     0xe8.1
    522          }
   \   000008   22           RET
   \   000009                REQUIRE U0DBUF
   \   000009                REQUIRE _A_IRCON2
    523          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    524          static void Uart_Send_String(char *Data,int len) 
   \                     ??Uart_Send_String:
    525          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
    526          	  int j; 
    527          	  for(j=0;j<len;j++) 
   \   000005   7800         MOV     R0,#0x0
   \   000007   7900         MOV     R1,#0x0
   \   000009   801A         SJMP    ??Uart_Send_String_1
    528          	  { 
    529          		    U0DBUF = *Data++; 
   \                     ??Uart_Send_String_2:
   \   00000B   8A82         MOV     DPL,R2
   \   00000D   8B83         MOV     DPH,R3
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F5C1         MOV     0xc1,A
   \   000012   A3           INC     DPTR
   \   000013   AA82         MOV     R2,DPL
   \   000015   AB83         MOV     R3,DPH
    530          		    while(UTX0IF == 0); //·¢ËÍÍê³É±êÖ¾Î»
   \                     ??Uart_Send_String_3:
   \   000017   A2E9         MOV     C,0xe8.1
   \   000019   50FC         JNC     ??Uart_Send_String_3
    531          		    UTX0IF = 0; 
   \   00001B   C2E9         CLR     0xe8.1
    532          	  } 
   \   00001D   E8           MOV     A,R0
   \   00001E   2401         ADD     A,#0x1
   \   000020   08           INC     R0
   \   000021   E9           MOV     A,R1
   \   000022   3400         ADDC    A,#0x0
   \   000024   F9           MOV     R1,A
   \                     ??Uart_Send_String_1:
   \   000025   C3           CLR     C
   \   000026   E8           MOV     A,R0
   \   000027   9C           SUBB    A,R4
   \   000028   E9           MOV     A,R1
   \   000029   9D           SUBB    A,R5
   \   00002A   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00002C   65D0         XRL     A,PSW
   \   00002E   33           RLC     A
   \   00002F   40DA         JC      ??Uart_Send_String_2
    533          }
   \   000031   7F01         MOV     R7,#0x1
   \   000033   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000036                REQUIRE U0DBUF
   \   000036                REQUIRE _A_IRCON2
    534          
    535          static void delay(unsigned int de)
    536          {
    537          	//while(de--);
    538          	 uint16 i,j;
    539          	 for(i=de;i>0;i--)
    540          	   for(j=587;j>0;j--);
    541          }
    542          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    543          static unsigned char RcvData(void)
   \                     ??RcvData:
    544          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    545          	unsigned char count1=0;
   \   000004   7900         MOV     R1,#0x0
    546          	unsigned char count2=0;
   \   000006   7800         MOV     R0,#0x0
    547          
    548          	while( !URX0IF )
   \                     ??RcvData_1:
   \   000008   A28B         MOV     C,0x88.3
   \   00000A   401B         JC      ??RcvData_2
    549          	{
    550          		count1++;
   \   00000C   09           INC     R1
    551          		if(count1==252)
   \   00000D   74FC         MOV     A,#-0x4
   \   00000F   69           XRL     A,R1
   \   000010   7003         JNZ     ??RcvData_3
    552          		{
    553          		count1=0;
   \   000012   7900         MOV     R1,#0x0
    554          		count2++;
   \   000014   08           INC     R0
    555          		}
    556          		if((count2==252)&&(start_flag==1))
   \                     ??RcvData_3:
   \   000015   74FC         MOV     A,#-0x4
   \   000017   68           XRL     A,R0
   \   000018   70EE         JNZ     ??RcvData_1
   \   00001A   900101       MOV     DPTR,#0x101
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6401         XRL     A,#0x1
   \   000020   70E6         JNZ     ??RcvData_1
    557          		{
    558          			start_flag=0;
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
    559          			
    560          			return 0;
   \   000024   F9           MOV     R1,A
   \   000025   8004         SJMP    ??RcvData_4
    561          		}
    562          	}
    563          	URX0IF = 0;
   \                     ??RcvData_2:
   \   000027   C28B         CLR     0x88.3
    564          	return U0DBUF;
   \   000029   A9C1         MOV     R1,0xc1
   \                     ??RcvData_4:
   \   00002B   D083         POP     DPH
   \   00002D   D082         POP     DPL
   \   00002F   22           RET
   \   000030                REQUIRE _A_TCON
   \   000030                REQUIRE U0DBUF
    565          }
    566          
    567          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    568          static unsigned char Message_Rcv(void)
   \                     ??Message_Rcv:
    569          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    570          	unsigned char	ucdata;
    571          	unsigned char 	rcvdat;
    572          	unsigned char	uci;
    573          	start_flag=0;
   \   000005   900101       MOV     DPTR,#0x101
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
    574          
    575          	//P1_3 = !P1_3;
    576          	
    577               ucdata=RcvData();
    578          	if(ucdata!=0x7E)
   \   00000A                ; Setup parameters for call to function RcvData
   \   00000A   12....       LCALL   ??RcvData
   \   00000D   E9           MOV     A,R1
   \   00000E   647E         XRL     A,#0x7e
   \   000010   6004         JZ      ??Message_Rcv_1
    579          	   return 0;
   \                     ??Message_Rcv_2:
   \   000012   7900         MOV     R1,#0x0
   \   000014   8062         SJMP    ??Message_Rcv_3
    580          	start_flag=1;
   \                     ??Message_Rcv_1:
   \   000016   7401         MOV     A,#0x1
   \   000018   F0           MOVX    @DPTR,A
    581          	ucdata=RcvData();
   \   000019                ; Setup parameters for call to function RcvData
   \   000019   12....       LCALL   ??RcvData
   \   00001C   E9           MOV     A,R1
    582          	ucLDR_Message.com_number=  ucdata;
   \   00001D   900110       MOV     DPTR,#0x110
   \   000020   F0           MOVX    @DPTR,A
    583          	ucLDR_Message.msg_cks=ucdata;
   \   000021   900164       MOV     DPTR,#0x164
   \   000024   12....       LCALL   ??Subroutine7_0
    584          	
    585                ucdata=RcvData();
    586          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_14:
   \   000027   60E9         JZ      ??Message_Rcv_2
    587          		return 0;
    588          	ucLDR_Message.protocol_command=  ucdata;
   \   000029   E8           MOV     A,R0
   \   00002A   900111       MOV     DPTR,#0x111
   \   00002D   12....       LCALL   ?Subroutine1
    589          	ucLDR_Message.msg_cks+=ucdata;	
    590          	
    591          	ucdata=RcvData();
    592          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_12:
   \   000030   60E0         JZ      ??Message_Rcv_2
    593          		 return 0;
    594          	ucLDR_Message.no_used=  ucdata;
   \   000032   E8           MOV     A,R0
   \   000033   900112       MOV     DPTR,#0x112
   \   000036   12....       LCALL   ?Subroutine1
    595          	ucLDR_Message.msg_cks+=ucdata;	
    596          	
    597          	ucdata=RcvData();
    598          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_13:
   \   000039   60D7         JZ      ??Message_Rcv_2
    599          		 return 0;
    600          	ucLDR_Message.data_length=  ucdata;
   \   00003B   E8           MOV     A,R0
   \   00003C   900113       MOV     DPTR,#0x113
   \   00003F   12....       LCALL   ?Subroutine5
    601          	ucLDR_Message.msg_cks+=ucdata;
   \                     ??CrossCallReturnLabel_7:
   \   000042   F0           MOVX    @DPTR,A
    602          	
    603          	for( uci=0 ; uci<ucLDR_Message.data_length ; uci++ )
   \   000043   7E00         MOV     R6,#0x0
   \   000045   8019         SJMP    ??Message_Rcv_4
    604          	{
    605          		ucdata = RcvData();
   \                     ??Message_Rcv_5:
   \   000047                ; Setup parameters for call to function RcvData
   \   000047   12....       LCALL   ??Subroutine8_0
    606          		if(start_flag==0)
   \                     ??CrossCallReturnLabel_15:
   \   00004A   60C6         JZ      ??Message_Rcv_2
    607          			 return 0;
    608          		ucLDR_Message.com_data[uci] = ucdata;
   \   00004C   8E..         MOV     ?V0 + 0,R6
   \   00004E   7414         MOV     A,#0x14
   \   000050   25..         ADD     A,?V0 + 0
   \   000052   F582         MOV     DPL,A
   \   000054   7401         MOV     A,#0x1
   \   000056   3400         ADDC    A,#0x0
   \   000058   F583         MOV     DPH,A
   \   00005A   E8           MOV     A,R0
   \   00005B   12....       LCALL   ?Subroutine5
    609          		ucLDR_Message.msg_cks+=ucdata;
    610          	}
   \                     ??CrossCallReturnLabel_8:
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   0E           INC     R6
   \                     ??Message_Rcv_4:
   \   000060   900113       MOV     DPTR,#0x113
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F8           MOV     R0,A
   \   000065   EE           MOV     A,R6
   \   000066   C3           CLR     C
   \   000067   98           SUBB    A,R0
   \   000068   40DD         JC      ??Message_Rcv_5
    611          	ucdata = RcvData();
   \   00006A                ; Setup parameters for call to function RcvData
   \   00006A   12....       LCALL   ??Subroutine8_0
    612          	rcvdat = ucLDR_Message.msg_cks;
    613          	if(start_flag==0)
   \                     ??CrossCallReturnLabel_16:
   \   00006D   60A3         JZ      ??Message_Rcv_2
    614          		 return 0;
    615          	//if(ucLDR_Message.msg_cks==ucdata)
    616          	if(rcvdat==ucdata)
   \   00006F   900164       MOV     DPTR,#0x164
   \   000072   E0           MOVX    A,@DPTR
   \   000073   68           XRL     A,R0
   \   000074   709C         JNZ     ??Message_Rcv_2
    617                return 1;
   \   000076   7901         MOV     R1,#0x1
   \                     ??Message_Rcv_3:
   \   000078                REQUIRE ?Subroutine0
   \   000078                ; // Fall through to label ?Subroutine0
    618          	else
    619          	return 0;	
    620          
    621          }

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_9:
   \   000003                REQUIRE ??Subroutine7_0
   \   000003                ; // Fall through to label ??Subroutine7_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine7_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function RcvData
   \   000001                ; Setup parameters for call to function RcvData
   \   000001                ; Setup parameters for call to function RcvData
   \   000001                REQUIRE ??Subroutine8_0
   \   000001                ; // Fall through to label ??Subroutine8_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   12....       LCALL   ??RcvData
   \   000003   E9           MOV     A,R1
   \   000004   F8           MOV     R0,A
   \   000005   900101       MOV     DPTR,#0x101
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   900164       MOV     DPTR,#0x164
   \   000004   E0           MOVX    A,@DPTR
   \   000005   28           ADD     A,R0
   \   000006   22           RET
    622          
    623          
    624          /*********************************************************************
    625           * @fn      dl2rc
    626           *
    627           * @brief   Copy the DL image to the RC image location.
    628           *
    629           *  NOTE:   Assumes that DL image ends on a flash word boundary.
    630           *
    631           * @param   None.
    632           *
    633           * @return  None.
    634           *********************************************************************/
    635          #if 1

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    636          static void Message_Send(void)
   \                     ??Message_Send:
    637          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    638          	unsigned char  uci;
    639          	
    640          	SendData(0x7E);
   \   000005                ; Setup parameters for call to function SendData
   \   000005   797E         MOV     R1,#0x7e
   \   000007   12....       LCALL   ??SendData
    641              
    642          	ucLDR_Message.msg_cks =ucLDR_Message.com_number;
   \   00000A   900110       MOV     DPTR,#0x110
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   900164       MOV     DPTR,#0x164
   \   000011   F0           MOVX    @DPTR,A
    643              SendData(ucLDR_Message.com_number);
   \   000012                ; Setup parameters for call to function SendData
   \   000012   F9           MOV     R1,A
   \   000013   12....       LCALL   ??SendData
    644              
    645              ucLDR_Message.msg_cks+=ucLDR_Message.protocol_command;
   \   000016   900111       MOV     DPTR,#0x111
   \   000019   12....       LCALL   ?Subroutine6
    646          	SendData(ucLDR_Message.protocol_command);  
   \                     ??CrossCallReturnLabel_10:
   \   00001C                ; Setup parameters for call to function SendData
   \   00001C   900111       MOV     DPTR,#0x111
   \   00001F   12....       LCALL   ?Subroutine2
    647          	
    648              ucLDR_Message.msg_cks+=ucLDR_Message.no_used;
    649          	SendData(ucLDR_Message.no_used); 	
   \                     ??CrossCallReturnLabel_0:
   \   000022                ; Setup parameters for call to function SendData
   \   000022   900112       MOV     DPTR,#0x112
   \   000025   12....       LCALL   ?Subroutine2
    650          		
    651              ucLDR_Message.msg_cks+=ucLDR_Message.data_length;
    652          	SendData(ucLDR_Message.data_length); 
   \                     ??CrossCallReturnLabel_1:
   \   000028                ; Setup parameters for call to function SendData
   \   000028   900113       MOV     DPTR,#0x113
   \   00002B   12....       LCALL   ?Subroutine3
    653          		
    654          
    655              for(uci =0;uci<ucLDR_Message.data_length;uci++)
   \                     ??CrossCallReturnLabel_2:
   \   00002E   7E00         MOV     R6,#0x0
   \   000030   8020         SJMP    ??Message_Send_1
    656              {
    657                 ucLDR_Message.msg_cks+=ucLDR_Message.com_data[uci];  
   \                     ??Message_Send_2:
   \   000032   8E..         MOV     ?V0 + 0,R6
   \   000034   7414         MOV     A,#0x14
   \   000036   25..         ADD     A,?V0 + 0
   \   000038   F8           MOV     R0,A
   \   000039   7401         MOV     A,#0x1
   \   00003B   3400         ADDC    A,#0x0
   \   00003D   F9           MOV     R1,A
   \   00003E   8882         MOV     DPL,R0
   \   000040   8983         MOV     DPH,R1
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FA           MOV     R2,A
   \   000044   900164       MOV     DPTR,#0x164
   \   000047   E0           MOVX    A,@DPTR
   \   000048   2A           ADD     A,R2
   \   000049   F0           MOVX    @DPTR,A
    658                 SendData(ucLDR_Message.com_data[uci]); 	
   \   00004A                ; Setup parameters for call to function SendData
   \   00004A   8882         MOV     DPL,R0
   \   00004C   8983         MOV     DPH,R1
   \   00004E   12....       LCALL   ?Subroutine3
    659          	 }
   \                     ??CrossCallReturnLabel_3:
   \   000051   0E           INC     R6
   \                     ??Message_Send_1:
   \   000052   900113       MOV     DPTR,#0x113
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   EE           MOV     A,R6
   \   000058   C3           CLR     C
   \   000059   98           SUBB    A,R0
   \   00005A   40D6         JC      ??Message_Send_2
    660               ucLDR_Message.msg_cks+=0;
   \   00005C   900164       MOV     DPTR,#0x164
   \   00005F   12....       LCALL   ?Subroutine3
    661          	 SendData(ucLDR_Message.msg_cks); 		
    662          }
   \                     ??CrossCallReturnLabel_4:
   \   000062   80..         SJMP    ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                ; Setup parameters for call to function SendData
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??SendData
   \   000005   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   ??SendData
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_11:
   \   000009   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   900164       MOV     DPTR,#0x164
   \   000005   E0           MOVX    A,@DPTR
   \   000006   28           ADD     A,R0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET
    663          
    664          #endif
    665          
    666          static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key)
    667          {
    668             UINT8 i;
    669          
    670             // Checking whether to load a key or an initialisation vector.
    671             if(key){
    672                AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_KEY);
    673             }
    674             else {
    675                AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_IV);
    676             }
    677             // Starting loading of key or vector.
    678             AES_START();
    679          
    680             // loading the data (key or vector)
    681             for(i = 0; i < 16; i++){
    682                ENCDI = pData[i];
    683             }
    684          }
    685          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    686          static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr)
   \                     ??halAesEncrDecr:
    687          {
   \   000000   74EF         MOV     A,#-0x11
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 17
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 6,R1
   \   000007   7411         MOV     A,#0x11
   \   000009   12....       LCALL   ?XSTACK_DISP0_8
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   E8           MOV     A,R0
   \   000012   FE           MOV     R6,A
   \   000013   E9           MOV     A,R1
   \   000014   FF           MOV     R7,A
    688             UINT16  i;
    689             UINT8   j, k;
                               ^
Warning[Pe177]: variable "k" was declared but never referenced
    690             BYTE    mode;
    691             UINT16  nbrOfBlocks;
    692             UINT16  convertedBlock;
    693             UINT8   delay;
    694          
    695             nbrOfBlocks = length / 16;
   \   000015   8C..         MOV     ?V0 + 0,R4
   \   000017   8D..         MOV     ?V0 + 1,R5
   \   000019   7404         MOV     A,#0x4
   \   00001B   78..         MOV     R0,#?V0 + 0
   \   00001D   12....       LCALL   ?US_SHR
   \   000020   85....       MOV     ?V0 + 2,?V0 + 0
   \   000023   85....       MOV     ?V0 + 3,?V0 + 1
    696             mode = 0;
    697          
    698             if( (length % 16) != 0){
   \   000026   EC           MOV     A,R4
   \   000027   540F         ANL     A,#0xf
   \   000029   600C         JZ      ??halAesEncrDecr_1
    699                // length not multiplum of 16, convert one block extra with zeropadding
    700                nbrOfBlocks++;
   \   00002B   E5..         MOV     A,?V0 + 2
   \   00002D   2401         ADD     A,#0x1
   \   00002F   F5..         MOV     ?V0 + 2,A
   \   000031   E5..         MOV     A,?V0 + 3
   \   000033   3400         ADDC    A,#0x0
   \   000035   F5..         MOV     ?V0 + 3,A
    701             }
    702          
    703             // Loading the IV.
    704             //halAesLoadKeyOrInitVector(pInitVector, FALSE);
    705          
    706             // Starting either encryption or decryption
    707             if(decr){
   \                     ??halAesEncrDecr_1:
   \   000037   E5..         MOV     A,?V0 + 6
   \   000039   600A         JZ      ??halAesEncrDecr_2
    708                AES_SET_ENCR_DECR_KEY_IV(AES_DECRYPT);
   \   00003B   E5B3         MOV     A,0xb3
   \   00003D   54F8         ANL     A,#0xf8
   \   00003F   4402         ORL     A,#0x2
   \   000041   F5B3         MOV     0xb3,A
   \   000043   8003         SJMP    ??halAesEncrDecr_3
    709             } else {
    710                AES_SET_ENCR_DECR_KEY_IV(AES_ENCRYPT);
   \                     ??halAesEncrDecr_2:
   \   000045   53B3F8       ANL     0xb3,#0xf8
    711             }
    712          
    713             // Getting the operation mode.
    714             mode = ENCCS & 0x70;
   \                     ??halAesEncrDecr_3:
   \   000048   E5B3         MOV     A,0xb3
   \   00004A   5470         ANL     A,#0x70
   \   00004C   F5..         MOV     ?V0 + 7,A
    715          
    716             for(convertedBlock = 0; convertedBlock < nbrOfBlocks; convertedBlock++){
   \   00004E   75..00       MOV     ?V0 + 0,#0x0
   \   000051   75..00       MOV     ?V0 + 1,#0x0
   \   000054   8047         SJMP    ??halAesEncrDecr_4
    717                // Starting the conversion.
    718                AES_START();
    719          
    720                i = convertedBlock * 16;
    721                // Counter, Output Feedback and Cipher Feedback operates on 4 bytes and not 16 bytes.
    722                if((mode == CFB) || (mode == OFB) || (mode == CTR))
    723          	 {
    724          /*
    725                   for(j = 0; j < 4; j++){
    726                      // Writing the input data
    727                      // Zeropadding the remainder of the block
    728                      for(k = 0; k < 4; k++){
    729                         ENCDI = ((i + 4*j + k < length) ? pDataIn[i + 4*j + k] : 0x00 );
    730                      }
    731                      // wait for data ready
    732                      delay = DELAY;
    733                      while(delay--);
    734                      // Read out data for every 4th byte
    735                      for(k = 0; k < 4; k++){
    736                         pDataOut[i + 4*j + k] = ENCDO;
    737                      }
    738                   }
    739          */
    740                }
    741                else if(mode == CBC_MAC){/*
    742                   // Writing the input data
    743                   // Zeropadding the remainder of the block
    744                   for(j = 0; j < 16; j++){
    745                      ENCDI = ((i + j < length) ? pDataIn[i + j] : 0x00 );
    746                   }
    747                   // The last block of the CBC-MAC is computed by using CBC mode.
    748                   if(convertedBlock == nbrOfBlocks - 2){
    749                      AES_SETMODE(CBC);
    750                      delay = DELAY;
    751                      while(delay--);
    752                   }
    753                   // The CBC-MAC does not produce an output on the n-1 first blocks
    754                   // only the last block is read out
    755                   else if(convertedBlock == nbrOfBlocks - 1){
    756                      // wait for data ready
    757                      delay = DELAY;
    758                      while(delay--);
    759                      for(j = 0; j < 16; j++){
    760                         pDataOut[j] = ENCDO;
    761                      }
    762                   }*/
    763                }
    764                else{
    765                   // Writing the input data
    766                   // Zeropadding the remainder of the block
    767                   for(j = 0; j < 16; j++){
    768                      ENCDI = ((i+j < length) ? pDataIn[i+j] : 0x00 );
   \                     ??halAesEncrDecr_5:
   \   000056   E4           CLR     A
   \                     ??halAesEncrDecr_6:
   \   000057   F5B1         MOV     0xb1,A
   \   000059   05..         INC     ?V0 + 9
   \   00005B   E5..         MOV     A,?V0 + 9
   \   00005D   C3           CLR     C
   \   00005E   9410         SUBB    A,#0x10
   \   000060   4075         JC      ??halAesEncrDecr_7
    769                   }
    770                   // wait for data ready
    771                   delay = DELAY;
   \   000062   75..0F       MOV     ?V0 + 4,#0xf
    772                   while(delay--);
   \                     ??halAesEncrDecr_8:
   \   000065   85....       MOV     ?V0 + 8,?V0 + 4
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   25..         ADD     A,?V0 + 8
   \   00006C   F5..         MOV     ?V0 + 4,A
   \   00006E   04           INC     A
   \   00006F   70F4         JNZ     ??halAesEncrDecr_8
    773                   // Read out data
    774                   for(j = 0; j < 16; j++){
   \   000071   75..00       MOV     ?V0 + 9,#0x0
    775                      pDataOut[i+j] = ENCDO;
   \                     ??halAesEncrDecr_9:
   \   000074   E5B2         MOV     A,0xb2
   \   000076   C0E0         PUSH    A
   \   000078   12....       LCALL   ?Subroutine4
    776                   }
   \                     ??CrossCallReturnLabel_5:
   \   00007B   EE           MOV     A,R6
   \   00007C   25..         ADD     A,?V0 + 4
   \   00007E   F582         MOV     DPL,A
   \   000080   EF           MOV     A,R7
   \   000081   35..         ADDC    A,?V0 + 5
   \   000083   F583         MOV     DPH,A
   \   000085   D0E0         POP     A
   \   000087   F0           MOVX    @DPTR,A
   \   000088   05..         INC     ?V0 + 9
   \   00008A   E5..         MOV     A,?V0 + 9
   \   00008C   C3           CLR     C
   \   00008D   9410         SUBB    A,#0x10
   \   00008F   40E3         JC      ??halAesEncrDecr_9
   \                     ??halAesEncrDecr_10:
   \   000091   E5..         MOV     A,?V0 + 0
   \   000093   2401         ADD     A,#0x1
   \   000095   F5..         MOV     ?V0 + 0,A
   \   000097   E5..         MOV     A,?V0 + 1
   \   000099   3400         ADDC    A,#0x0
   \   00009B   F5..         MOV     ?V0 + 1,A
   \                     ??halAesEncrDecr_4:
   \   00009D   C3           CLR     C
   \   00009E   E5..         MOV     A,?V0 + 0
   \   0000A0   95..         SUBB    A,?V0 + 2
   \   0000A2   E5..         MOV     A,?V0 + 1
   \   0000A4   95..         SUBB    A,?V0 + 3
   \   0000A6   504C         JNC     ??halAesEncrDecr_11
   \   0000A8   43B301       ORL     0xb3,#0x1
   \   0000AB   85....       MOV     ?V0 + 4,?V0 + 0
   \   0000AE   85....       MOV     ?V0 + 5,?V0 + 1
   \   0000B1   7404         MOV     A,#0x4
   \   0000B3   78..         MOV     R0,#?V0 + 4
   \   0000B5   12....       LCALL   ?S_SHL
   \   0000B8   A8..         MOV     R0,?V0 + 4
   \   0000BA   A9..         MOV     R1,?V0 + 5
   \   0000BC   7410         MOV     A,#0x10
   \   0000BE   65..         XRL     A,?V0 + 7
   \   0000C0   60CF         JZ      ??halAesEncrDecr_10
   \   0000C2   7420         MOV     A,#0x20
   \   0000C4   65..         XRL     A,?V0 + 7
   \   0000C6   60C9         JZ      ??halAesEncrDecr_10
   \   0000C8   7430         MOV     A,#0x30
   \   0000CA   65..         XRL     A,?V0 + 7
   \   0000CC   60C3         JZ      ??halAesEncrDecr_10
   \   0000CE   7450         MOV     A,#0x50
   \   0000D0   65..         XRL     A,?V0 + 7
   \   0000D2   60BD         JZ      ??halAesEncrDecr_10
   \   0000D4   75..00       MOV     ?V0 + 9,#0x0
   \                     ??halAesEncrDecr_7:
   \   0000D7   12....       LCALL   ?Subroutine4
    777                }
    778             }
   \                     ??CrossCallReturnLabel_6:
   \   0000DA   C3           CLR     C
   \   0000DB   E5..         MOV     A,?V0 + 4
   \   0000DD   9C           SUBB    A,R4
   \   0000DE   E5..         MOV     A,?V0 + 5
   \   0000E0   9D           SUBB    A,R5
   \   0000E1   4003         JC      $+5
   \   0000E3   02....       LJMP    ??halAesEncrDecr_5
   \   0000E6   EA           MOV     A,R2
   \   0000E7   25..         ADD     A,?V0 + 4
   \   0000E9   F582         MOV     DPL,A
   \   0000EB   EB           MOV     A,R3
   \   0000EC   35..         ADDC    A,?V0 + 5
   \   0000EE   F583         MOV     DPH,A
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   02....       LJMP    ??halAesEncrDecr_6
    779          }
   \                     ??halAesEncrDecr_11:
   \   0000F4   7F0A         MOV     R7,#0xa
   \   0000F6   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   0000F9                REQUIRE ENCCS
   \   0000F9                REQUIRE ENCDI
   \   0000F9                REQUIRE ENCDO

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   85....       MOV     ?V0 + 4,?V0 + 9
   \   000003   E8           MOV     A,R0
   \   000004   25..         ADD     A,?V0 + 4
   \   000006   F5..         MOV     ?V0 + 4,A
   \   000008   E9           MOV     A,R1
   \   000009   3400         ADDC    A,#0x0
   \   00000B   F5..         MOV     ?V0 + 5,A
   \   00000D   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "WorkForYourDream"`:
   \   000000   576F726B     DB "WorkForYourDream"
   \            466F7259
   \            6F757244
   \            7265616D
   \            00      

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "boot">>`:
   \   000000   626F6F74     DB "boot"
   \            00      

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "jump">>`:
   \   000000   6A756D70     DB "jump"
   \            00      

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for g_decKey>`:
   \   000000   ....         DW `?<Constant "WorkForYourDream">`

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "WorkForYourDream">`:
   \   000000                DS 17
   \   000011                REQUIRE `?<Initializer for <Constant "WorkForYourDream"`
   \   000011                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "boot">`:
   \   000000                DS 5
   \   000005                REQUIRE `?<Initializer for <Constant "boot">>`
   \   000005                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "jump">`:
   \   000000                DS 5
   \   000005                REQUIRE `?<Initializer for <Constant "jump">>`
   \   000005                REQUIRE __INIT_XDATA_I
    780          
    781          
    782           #ifdef _USER_OAD_FLASH_WRITE_
    783          static void dl2rc(void)
    784          {
    785            preamble_t preamble;
    786            uint32 oset;
    787            uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;				//0x0800/4		user code start address
    788            uint8 buf[4];
    789          
    790            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
    791            //preamble.len = 65536;
    792          
    793            for (oset = 0; oset < preamble.len; oset += HAL_FLASH_WORD_SIZE)
    794            {
    795              HalOADRead(oset, buf, HAL_FLASH_WORD_SIZE, HAL_OAD_DL);
    796              if ((addr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
    797              {
    798                HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
    799              }
    800              HalFlashWrite(addr++, buf, 1);
    801            }
    802          }  
    803          
    804          /*********************************************************************
    805           * @fn      crcCalc
    806           *
    807           * @brief   Run the CRC16 Polynomial calculation over the RC image.
    808           *
    809           * @param   None.
    810           *
    811           * @return  The CRC16 calculated.
    812           */
    813          static uint16 crcCalc(void)
    814          {
    815            preamble_t preamble;
    816            uint32 oset;
    817            uint16 crc = 0;
    818          
    819            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    820          
    821            // Run the CRC calculation over the active body of code.
    822            for (oset = 0; oset < preamble.len; oset++)
    823            {
    824              if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
    825              {
    826                uint8 buf;
    827                HalOADRead(oset, &buf, 1, HAL_OAD_RC);
    828                crc = runPoly(crc, buf);
    829              }
    830            }
    831          
    832            // IAR note explains that poly must be run with value zero for each byte of crc.
    833            crc = runPoly(crc, 0);
    834            crc = runPoly(crc, 0);
    835          
    836            return crc;
    837          }
    838          #endif
    839          //#endif
    840          
    841          /*********************************************************************
    842           * @fn      runPoly
    843           *
    844           * @brief   Run the CRC16 Polynomial calculation over the byte parameter.
    845           *
    846           * @param   crc - Running CRC calculated so far.
    847           * @param   val - Value on which to run the CRC16.
    848           *
    849           * @return  crc - Updated for the run.
    850           */
    851           #if _USER_OAD_FLASH_WRITE_
                      ^
Remark[Pe193]: zero used for undefined preprocessing identifier
          "_USER_OAD_FLASH_WRITE_"

  static uint16 runPoly(uint16 crc, uint8 val);
                ^
"C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Components\hal\target\CC2530EB\hal_oad.c",95  Warning[Pe177]: 
          function "runPoly" was declared but never referenced

  static void dl2rc(void);
              ^
"C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Components\hal\target\CC2530EB\hal_oad.c",177  Warning[Pe177]: 
          function "dl2rc" was declared but never referenced

  static uint16 crcCalc(void);
                ^
"C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Components\hal\target\CC2530EB\hal_oad.c",178  Warning[Pe177]: 
          function "crcCalc" was declared but never referenced
    852          static uint16 runPoly(uint16 crc, uint8 val)
    853          {
    854            const uint16 poly = 0x1021;
    855            uint8 cnt;
    856          
    857            for (cnt = 0; cnt < 8; cnt++, val <<= 1)
    858            {
    859              uint8 msb = (crc & 0x8000) ? 1 : 0;
    860          
    861              crc <<= 1;
    862              if (val & 0x80)  crc |= 0x0001;
    863              if (msb)         crc ^= poly;
    864            }
    865          
    866            return crc;
    867          }
    868          
    869          /*********************************************************************
    870           * @fn      HalOADChkDL
    871           *
    872           * @brief   Run the CRC16 Polynomial calculation over the DL image.
    873           *
    874           * @param   dlImagePreambleOffset - Offset into the monolithic DL image to read the preamble.
    875           *
    876           * @return  SUCCESS or FAILURE.
    877           *********************************************************************/
    878          uint8 HalOADChkDL(uint8 dlImagePreambleOffset)
    879          {
    880            preamble_t preamble;
    881            uint32 oset;
    882            uint16 crc = 0, crc2;
    883          
    884            HalOADRead(dlImagePreambleOffset, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
    885          
    886            // Run the CRC calculation over the downloaded image.
    887            for (oset = 0; oset < preamble.len; oset++)
    888            {
    889              if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
    890              {
    891                uint8 buf;
    892                HalOADRead(oset, &buf, 1, HAL_OAD_DL);
    893                crc = runPoly(crc, buf);
    894              }
    895            }
    896          
    897            // IAR note explains that poly must be run with value zero for each byte of crc.
    898            crc = runPoly(crc, 0);
    899            crc = runPoly(crc, 0);
    900          
    901            HalOADRead(HAL_OAD_CRC_OSET, (uint8 *)&crc2, sizeof(crc2), HAL_OAD_DL);
    902            return (crc2 == crc) ? SUCCESS : FAILURE;
    903          }
    904          
    905          /*********************************************************************
    906           * @fn      HalOADInvRC
    907           *
    908           * @brief   Invalidate the active image so that the boot code will instantiate the DL image on the
    909           *          next reset.
    910           *
    911           * @param   None.
    912           *
    913           * @return  None.
    914           *********************************************************************/
    915          void HalOADInvRC(void)
    916          {
    917            uint16 crc[2] = {0,0xFFFF};
    918            HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
    919          }
    920          
    921          /*********************************************************************
    922           * @fn      HalOADRead
    923           *
    924           * @brief   Read from the storage medium according to image type.
    925           *
    926           * @param   oset - Offset into the monolithic image.
    927           * @param   pBuf - Pointer to the buffer in which to copy the bytes read.
    928           * @param   len - Number of bytes to read.
    929           * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
    930           *
    931           * @return  None.
    932           *********************************************************************/
    933          void HalOADRead(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
    934          {
    935            if (HAL_OAD_RC != type)
    936            {
    937          #if HAL_OAD_XNV_IS_INT
    938              preamble_t preamble;
    939          
    940              HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    941              //oset += HAL_OAD_RC_START + preamble.len;
    942              oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
    943          #elif HAL_OAD_XNV_IS_SPI
    944              oset += HAL_OAD_DL_OSET;
    945              HalSPIRead(oset, pBuf, len);
    946              return;
    947          #endif
    948            }
    949            else
    950            {
    951              oset += HAL_OAD_RC_START;
    952            }
    953          
    954            HalFlashRead(oset / HAL_FLASH_PAGE_SIZE, oset % HAL_FLASH_PAGE_SIZE, pBuf, len);
    955          }
    956          
    957          /*********************************************************************
    958           * @fn      HalOADWrite
    959           *
    960           * @brief   Write to the storage medium according to the image type.
    961           *
    962           *  NOTE:   Destructive write on page boundary! When writing to the first flash word
    963           *          of a page boundary, the page is erased without saving/restoring the bytes not written.
    964           *          Writes anywhere else on a page assume that the location written to has been erased.
    965           *
    966           * @param   oset - Offset into the monolithic image, aligned to HAL_FLASH_WORD_SIZE.
    967           * @param   pBuf - Pointer to the buffer in from which to write.
    968           * @param   len - Number of bytes to write. If not an even multiple of HAL_FLASH_WORD_SIZE,
    969           *                remainder bytes are overwritten with garbage.
    970           * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
    971           *
    972           * @return  None.
    973           *********************************************************************/
    974          void HalOADWrite(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
    975          {
    976            if (HAL_OAD_RC != type)
    977            {
    978          #if HAL_OAD_XNV_IS_INT
    979              preamble_t preamble;
    980          
    981              HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
    982              //oset += HAL_OAD_RC_START + preamble.len;
    983              oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
    984          #elif HAL_OAD_XNV_IS_SPI
    985              oset += HAL_OAD_DL_OSET;
    986              HalSPIWrite(oset, pBuf, len);
    987              return;
    988          #endif
    989            }
    990            else
    991            {
    992              oset += HAL_OAD_RC_START;
    993            }
    994          
    995            if ((oset % HAL_FLASH_PAGE_SIZE) == 0)
    996            {
    997              HalFlashErase(oset / HAL_FLASH_PAGE_SIZE);
    998            }
    999          
   1000            HalFlashWrite(oset / HAL_FLASH_WORD_SIZE, pBuf, len / HAL_FLASH_WORD_SIZE);
   1001          }
   1002          
   1003          #if HAL_OAD_XNV_IS_INT
   1004          /*********************************************************************
   1005           * @fn      HalOADAvail
   1006           *
   1007           * @brief   Determine the space available for downloading an image.
   1008           *
   1009           * @param   None.
   1010           *
   1011           * @return  Number of bytes available for storing an OAD image.
   1012           *********************************************************************/
   1013          uint32 HalOADAvail(void)
   1014          {
   1015            /*
   1016            preamble_t preamble;
   1017          
   1018            HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
   1019            return HAL_OAD_DL_MAX - preamble.len;
   1020             */
   1021            return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
   1022          }
   1023          
   1024          #elif HAL_OAD_XNV_IS_SPI
   1025          
   1026          /*********************************************************************
   1027           * CONSTANTS
   1028           */
   1029          
   1030          #define XNV_STAT_CMD  0x05
   1031          #define XNV_WREN_CMD  0x06
   1032          #define XNV_WRPG_CMD  0x0A
   1033          #define XNV_READ_CMD  0x0B
   1034          
   1035          #define XNV_STAT_WIP  0x01
   1036          
   1037          /*********************************************************************
   1038           * @fn      xnvSPIWrite
   1039           *
   1040           * @brief   SPI write sequence for code size savings.
   1041           *
   1042           * @param   ch - The byte to write to the SPI.
   1043           *
   1044           * @return  None.
   1045           *********************************************************************/
   1046          static void xnvSPIWrite(uint8 ch);
   1047          static void xnvSPIWrite(uint8 ch)
   1048          {
   1049            XNV_SPI_TX(ch);
   1050            XNV_SPI_WAIT_RXRDY();
   1051          }
   1052          
   1053          /*********************************************************************
   1054           * @fn      HalOADAvail
   1055           *
   1056           * @brief   Determine the space available for downloading an image.
   1057           *
   1058           * @param   None.
   1059           *
   1060           * @return  Number of bytes available for storing an OAD image.
   1061           *********************************************************************/
   1062          uint32 HalOADAvail(void)
   1063          {
   1064            return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
   1065          }
   1066          
   1067          /*********************************************************************
   1068           * @fn      HalSPIRead
   1069           *
   1070           * @brief   Read from the external NV storage via SPI.
   1071           *
   1072           * @param   addr - Offset into the external NV.
   1073           * @param   pBuf - Pointer to the buffer in which to copy the bytes read from external NV.
   1074           * @param   len - Number of bytes to read from external NV.
   1075           *
   1076           * @return  None.
   1077           *********************************************************************/
   1078          static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len)
   1079          {
   1080          #if !HAL_OAD_BOOT_CODE
   1081            uint8 shdw = P1DIR;
   1082            halIntState_t his;
   1083            HAL_ENTER_CRITICAL_SECTION(his);
   1084            P1DIR |= BV(3);
   1085          #endif
   1086          
   1087            XNV_SPI_BEGIN();
   1088            do {
   1089              xnvSPIWrite(XNV_STAT_CMD);
   1090            } while (XNV_SPI_RX() & XNV_STAT_WIP);
   1091            XNV_SPI_END();
   1092            asm("NOP"); asm("NOP");
   1093          
   1094            XNV_SPI_BEGIN();
   1095            xnvSPIWrite(XNV_READ_CMD);
   1096            xnvSPIWrite(addr >> 16);
   1097            xnvSPIWrite(addr >> 8);
   1098            xnvSPIWrite(addr);
   1099            xnvSPIWrite(0);
   1100          
   1101            while (len--)
   1102            {
   1103              xnvSPIWrite(0);
   1104              *pBuf++ = XNV_SPI_RX();
   1105            }
   1106            XNV_SPI_END();
   1107          
   1108          #if !HAL_OAD_BOOT_CODE
   1109            P1DIR = shdw;
   1110            HAL_EXIT_CRITICAL_SECTION(his);
   1111          #endif
   1112          }
   1113          
   1114          /*********************************************************************
   1115           * @fn      HalSPIWrite
   1116           *
   1117           * @brief   Write to the external NV storage via SPI.
   1118           *
   1119           * @param   addr - Offset into the external NV.
   1120           * @param   pBuf - Pointer to the buffer in from which to write bytes to external NV.
   1121           * @param   len - Number of bytes to write to external NV.
   1122           *
   1123           * @return  None.
   1124           *********************************************************************/
   1125          static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len)
   1126          {
   1127            uint8 cnt;
   1128          #if !HAL_OAD_BOOT_CODE
   1129            uint8 shdw = P1DIR;
   1130            halIntState_t his;
   1131            HAL_ENTER_CRITICAL_SECTION(his);
   1132            P1DIR |= BV(3);
   1133          #endif
   1134          
   1135            while (len)
   1136            {
   1137              XNV_SPI_BEGIN();
   1138              do {
   1139                xnvSPIWrite(XNV_STAT_CMD);
   1140              } while (XNV_SPI_RX() & XNV_STAT_WIP);
   1141              XNV_SPI_END();
   1142              asm("NOP"); asm("NOP");
   1143          
   1144              XNV_SPI_BEGIN();
   1145              xnvSPIWrite(XNV_WREN_CMD);
   1146              XNV_SPI_END();
   1147              asm("NOP"); asm("NOP");
   1148          
   1149              XNV_SPI_BEGIN();
   1150              xnvSPIWrite(XNV_WRPG_CMD);
   1151              xnvSPIWrite(addr >> 16);
   1152              xnvSPIWrite(addr >> 8);
   1153              xnvSPIWrite(addr);
   1154          
   1155              // Can only write within any one page boundary, so prepare for next page write if bytes remain.
   1156              cnt = 0 - (uint8)addr;
   1157              if (cnt)
   1158              {
   1159                addr += cnt;
   1160              }
   1161              else
   1162              {
   1163                addr += 256;
   1164              }
   1165          
   1166              do
   1167              {
   1168                xnvSPIWrite(*pBuf++);
   1169                cnt--;
   1170                len--;
   1171              } while (len && cnt);
   1172              XNV_SPI_END();
   1173            }
   1174          
   1175          #if !HAL_OAD_BOOT_CODE
   1176            P1DIR = shdw;
   1177            HAL_EXIT_CRITICAL_SECTION(his);
   1178          #endif
   1179          }
   1180          #else
   1181          #error Invalid Xtra-NV for OAD.
   1182          #endif
   1183          
   1184          #endif
   1185          
   1186          #if defined HAL_PA_LNA ||defined HAL_PA_LNA_CC2590
   1187          void MAC_RfFrontendSetup(void)
   1188          {}
   1189          #endif
   1190          
   1191          /**************************************************************************************************
   1192          */
C:\Users\freeman\Work\ST-EX-RT\CanMstOsal\Components\hal\target\CC2530EB\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       _hal_uart.c
      3            Revised:        $Date: 2009-06-12 09:16:43 -0700 (Fri, 12 Jun 2009) $
      4            Revision:       $Revision: 20142 $
      5          
      6            Description: This file contains the interface to the H/W UART driver.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_board_cfg.h"
     45          #include "hal_defs.h"
     46          #include "hal_types.h"
     47          #include "hal_uart.h"
     48          
     49          /*********************************************************************
     50           * MACROS
     51           */
     52          
     53          /*********************************************************************
     54           * TYPEDEFS
     55           */
     56          
     57          /*********************************************************************
     58           * CONSTANTS
     59           */
     60          
     61          /*********************************************************************
     62           * GLOBAL VARIABLES
     63           */
     64          
     65          /*********************************************************************
     66           * GLOBAL FUNCTIONS
     67           */
     68          
     69          /*********************************************************************
     70           * LOCAL VARIABLES
     71           */
     72          
     73          /*********************************************************************
     74           * LOCAL FUNCTIONS
     75           */
     76          
     77          #if HAL_UART_DMA
     78          #include "_hal_uart_dma.c"
     79          #endif
     80          #if HAL_UART_ISR
     81          #include "_hal_uart_isr.c"
     82          #endif
     83          #if HAL_UART_USB
     84          #include "_hal_uart_usb.c"
     85          #endif
     86          
     87          /******************************************************************************
     88           * @fn      HalUARTInit
     89           *
     90           * @brief   Initialize the UART
     91           *
     92           * @param   none
     93           *
     94           * @return  none
     95           *****************************************************************************/
     96          void HalUARTInit(void)
     97          {
     98          #if HAL_UART_DMA
     99            HalUARTInitDMA();
    100          #endif
    101          #if HAL_UART_ISR
    102            HalUARTInitISR();
    103          #endif
    104          #if HAL_UART_USB
    105            HalUARTInitUSB();
    106          #endif
    107          }
    108          
    109          /******************************************************************************
    110           * @fn      HalUARTOpen
    111           *
    112           * @brief   Open a port according tp the configuration specified by parameter.
    113           *
    114           * @param   port   - UART port
    115           *          config - contains configuration information
    116           *
    117           * @return  Status of the function call
    118           *****************************************************************************/
    119          uint8 HalUARTOpen(uint8 port, halUARTCfg_t *config)
    120          {
    121            (void)port;
    122            (void)config;
    123          
    124          #if (HAL_UART_DMA == 1)
    125            if (port == HAL_UART_PORT_0)  HalUARTOpenDMA(config);
    126          #endif
    127          #if (HAL_UART_DMA == 2)
    128            if (port == HAL_UART_PORT_1)  HalUARTOpenDMA(config);
    129          #endif
    130          #if (HAL_UART_ISR == 1)
    131            if (port == HAL_UART_PORT_0)  HalUARTOpenISR(config);
    132          #endif
    133          #if (HAL_UART_ISR == 2)
    134            if (port == HAL_UART_PORT_1)  HalUARTOpenISR(config);
    135          #endif
    136          #if (HAL_UART_USB)
    137            HalUARTOpenUSB(config);
    138          #endif
    139            
    140            return HAL_UART_SUCCESS;
    141          }
    142          
    143          /*****************************************************************************
    144           * @fn      HalUARTRead
    145           *
    146           * @brief   Read a buffer from the UART
    147           *
    148           * @param   port - USART module designation
    149           *          buf  - valid data buffer at least 'len' bytes in size
    150           *          len  - max length number of bytes to copy to 'buf'
    151           *
    152           * @return  length of buffer that was read
    153           *****************************************************************************/
    154          uint16 HalUARTRead(uint8 port, uint8 *buf, uint16 len)
    155          {
    156            (void)port;
    157            (void)buf;
    158            (void)len;
    159          
    160          #if (HAL_UART_DMA == 1)
    161            if (port == HAL_UART_PORT_0)  return HalUARTReadDMA(buf, len);
    162          #endif
    163          #if (HAL_UART_DMA == 2)
    164            if (port == HAL_UART_PORT_1)  return HalUARTReadDMA(buf, len);
    165          #endif
    166          #if (HAL_UART_ISR == 1)
    167            if (port == HAL_UART_PORT_0)  return HalUARTReadISR(buf, len);
    168          #endif
    169          #if (HAL_UART_ISR == 2)
    170            if (port == HAL_UART_PORT_1)  return HalUARTReadISR(buf, len);
    171          #endif
    172          
    173          #if HAL_UART_USB
    174            return HalUARTRx(buf, len);
    175          #else
    176            return 0;
    177          #endif
    178          }
    179          
    180          /******************************************************************************
    181           * @fn      HalUARTWrite
    182           *
    183           * @brief   Write a buffer to the UART.
    184           *
    185           * @param   port - UART port
    186           *          buf  - pointer to the buffer that will be written, not freed
    187           *          len  - length of
    188           *
    189           * @return  length of the buffer that was sent
    190           *****************************************************************************/
    191          uint16 HalUARTWrite(uint8 port, uint8 *buf, uint16 len)
    192          {
    193            (void)port;
    194            (void)buf;
    195            (void)len;
    196          
    197          #if (HAL_UART_DMA == 1)
    198            if (port == HAL_UART_PORT_0)  return HalUARTWriteDMA(buf, len);
    199          #endif
    200          #if (HAL_UART_DMA == 2)
    201            if (port == HAL_UART_PORT_1)  return HalUARTWriteDMA(buf, len);
    202          #endif
    203          #if (HAL_UART_ISR == 1)
    204            if (port == HAL_UART_PORT_0)  return HalUARTWriteISR(buf, len);
    205          #endif
    206          #if (HAL_UART_ISR == 2)
    207            if (port == HAL_UART_PORT_1)  return HalUARTWriteISR(buf, len);
    208          #endif
    209          
    210          #if HAL_UART_USB
    211            HalUARTTx(buf, len);
    212            return len;
    213          #else
    214            return 0;
    215          #endif
    216          }
    217          
    218          /******************************************************************************
    219           * @fn      HalUARTSuspend
    220           *
    221           * @brief   Suspend UART hardware before entering PM mode 1, 2 or 3.
    222           *
    223           * @param   None
    224           *
    225           * @return  None
    226           *****************************************************************************/
    227          void HalUARTSuspend( void )
    228          {
    229          #if HAL_UART_DMA
    230            HalUARTSuspendDMA();
    231          #endif
    232          #if HAL_UART_ISR
    233            HalUARTSuspendISR();
    234          #endif
    235          }
    236          
    237          /******************************************************************************
    238           * @fn      HalUARTResume
    239           *
    240           * @brief   Resume UART hardware after exiting PM mode 1, 2 or 3.
    241           *
    242           * @param   None
    243           *
    244           * @return  None
    245           *****************************************************************************/
    246          void HalUARTResume( void )
    247          {
    248          #if HAL_UART_DMA
    249            HalUARTResumeDMA();
    250          #endif
    251          #if HAL_UART_ISR
    252            HalUARTResumeISR();
    253          #endif
    254          }
    255          
    256          /***************************************************************************************************
    257           * @fn      HalUARTPoll
    258           *
    259           * @brief   Poll the UART.
    260           *
    261           * @param   none
    262           *
    263           * @return  none
    264           *****************************************************************************/
    265          void HalUARTPoll(void)
    266          {
    267          #if HAL_UART_DMA
    268            HalUARTPollDMA();
    269          #endif
    270          #if HAL_UART_ISR
    271            HalUARTPollISR();
    272          #endif
    273          #if HAL_UART_USB
    274            HalUARTPollUSB();
    275          #endif
    276          }
    277          
    278          /**************************************************************************************************
    279           * @fn      Hal_UART_RxBufLen()
    280           *
    281           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    282           *
    283           * @param   port - UART port
    284           *
    285           * @return  length of current Rx Buffer
    286           **************************************************************************************************/
    287          uint16 Hal_UART_RxBufLen( uint8 port )
    288          {
    289            (void)port;
    290          
    291          #if (HAL_UART_DMA == 1)
    292            if (port == HAL_UART_PORT_0)  return HalUARTRxAvailDMA();
    293          #endif
    294          #if (HAL_UART_DMA == 2)
    295            if (port == HAL_UART_PORT_1)  return HalUARTRxAvailDMA();
    296          #endif
    297          #if (HAL_UART_ISR == 1)
    298            if (port == HAL_UART_PORT_0)  return HalUARTRxAvailISR();
    299          #endif
    300          #if (HAL_UART_ISR == 2)
    301            if (port == HAL_UART_PORT_1)  return HalUARTRxAvailISR();
    302          #endif
    303          #if HAL_UART_USB
    304            return HalUARTRxAvailUSB();
    305          #else
    306            return 0;
    307          #endif
    308          }
    309          
    310          /******************************************************************************
    311          ******************************************************************************/

   Maximum stack usage in bytes:

     Function                  ISTACK PSTACK XSTACK
     --------                  ------ ------ ------
     HalFlashRead                  1      0     13
     HalFlashWriteTrigger          2      0      0
     Message_Rcv                   1      0      9
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
       -> RcvData                  0      0     18
     Message_Send                  0      0      9
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
       -> SendData                 0      0     18
     RcvData                       2      0      9
     SendData                      0      0      9
     Uart_Send_String              0      0      8
     halAesEncrDecr                1      0     19
     main                          0      0      2
       -> HalFlashRead             0      0      4
       -> Uart_Send_String         0      0      0
       -> HalFlashRead             0      0      4
       -> Message_Send             0      0      0
       -> Message_Rcv              0      0      0
       -> halAesEncrDecr           0      0      4
       -> HalFlashWriteTrigger     0      0      0
       -> Message_Send             0      0      0
       -> Message_Send             0      0      0
       -> Uart_Send_String         0      0      0


   Segment part sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     _A_P0                                             1
     U0CSR                                             1
     _A_TCON                                           1
     P0INP                                             1
     _A_P1                                             1
     SLEEPSTA                                          1
     CLKCONSTA                                         1
     ENCDI                                             1
     ENCDO                                             1
     ENCCS                                             1
     SLEEPCMD                                          1
     U0DBUF                                            1
     U0BAUD                                            1
     U0GCR                                             1
     CLKCONCMD                                         1
     MEMCTR                                            1
     DMAIRQ                                            1
     DMA0CFGL                                          1
     DMA0CFGH                                          1
     DMAARM                                            1
     _A_IRCON2                                         1
     PERCFG                                            1
     P0SEL                                             1
     P1SEL                                             1
     P2SEL                                             1
     _A_U1CSR                                          1
     U1BAUD                                            1
     U1GCR                                             1
     P0DIR                                             1
     P1DIR                                             1
     P2DIR                                             1
     ramCode                                          29
     HalFlashRead                                    119
     HalFlashWriteTrigger                             27
     dmaCh0                                            8
     g_decKey                                          2
     main                                            543
     SendData                                          9
     Uart_Send_String                                 54
     RcvData                                          48
     Message_Rcv                                     120
     ?Subroutine0                                      5
     ?Subroutine1                                      3
     ??Subroutine7_0                                   1
     ??Subroutine8_0                                  10
     ?Subroutine5                                      7
     Message_Send                                    100
     ?Subroutine3                                      6
     ?Subroutine2                                     10
     ?Subroutine6                                      9
     halAesEncrDecr                                  249
     ?Subroutine4                                     14
     ?<Initializer for <Constant "WorkForYourDream"   17
     ?<Initializer for <Constant "boot">>              5
     ?<Initializer for <Constant "jump">>              5
     ?<Initializer for g_decKey>                       2
     ?<Constant "WorkForYourDream">                   17
     ?<Constant "boot">                                5
     ?<Constant "jump">                                5

 
 1 307 bytes in segment NEAR_CODE
    27 bytes in segment RAM_CODE_FLASH
    29 bytes in segment RAM_CODE_XDATA
    31 bytes in segment SFR_AN
    29 bytes in segment XDATA_I
    29 bytes in segment XDATA_ID
     8 bytes in segment XDATA_Z
 
 1 363 bytes of CODE  memory
     0 bytes of DATA  memory (+ 31 bytes shared)
    66 bytes of XDATA memory

Errors: none
Warnings: 7
