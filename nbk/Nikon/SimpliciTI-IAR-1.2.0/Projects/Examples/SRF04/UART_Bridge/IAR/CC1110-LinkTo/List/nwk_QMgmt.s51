///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.4.40412/W32 for 8051        08/Jul/2016  22:45:53 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  near                                              /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  2,separate,16,inc                                 /
//    Source file        =  C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Compone /
//                          nts\simpliciti\nwk\nwk_QMgmt.c                    /
//    Command line       =  -f "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Pro /
//                          jects\Examples\SRF04\UART_Bridge\IAR\Configuratio /
//                          n\LinkTo\smpl_config.dat" (-DNUM_CONNECTIONS=2    /
//                          -DSIZE_INFRAME_Q=2 -DSIZE_OUTFRAME_Q=2            /
//                          "-DTHIS_DEVICE_ADDRESS={0x79, 0x56, 0x34, 0x12}"  /
//                          -DEND_DEVICE -DLINK_TO -DxNWK_PLL_REFERENCE_CLOCK /
//                          ) -f "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\P /
//                          rojects\Examples\SRF04\UART_Bridge\IAR\Configurat /
//                          ion\smpl_nwk_config.dat" (-DMAX_HOPS=3            /
//                          -DMAX_HOPS_FROM_AP=1 -DMAX_NWK_PAYLOAD=34         /
//                          -DMAX_APP_PAYLOAD=10 -DDEFAULT_LINK_TOKEN=0x01020 /
//                          304 -DDEFAULT_JOIN_TOKEN=0x05060708               /
//                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK              /
//                          -DxEXTENDED_API -DxSMPL_SECURE                    /
//                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                   /
//                          -DxFREQUENCY_HOPPING -DBSP_TIMER_USED=1           /
//                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                /
//                          -DUART_NUMBER=UART_NUMBER_0                       /
//                          -DUART_LOCATION=UART_LOCATION_1                   /
//                          -DUART_BAUD_RATE=9600 -DUART_FLOW_CONTROL=UART_FL /
//                          OW_CONTROL_OFF -DUART_PARITY_MODE=UART_PARITY_NON /
//                          E -DUART_STOP_BITS=UART_1_STOP_BIT) "C:\Texas     /
//                          Instruments\SimpliciTI-IAR-1.2.0\Components\simpl /
//                          iciti\nwk\nwk_QMgmt.c" -D "MCU_H=\"ioCC1110.h\""  /
//                          -D MRFI_CC1110 -lB "C:\Texas                      /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\CC1110-LinkTo\List\" -o   /
//                          "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF04\UART_Bridge\IAR\CC1110-LinkTo\O /
//                          bj\" -e --debug --core=plain                      /
//                          --dptr=16,2,separate,inc --data_model=large       /
//                          --code_model=near --calling_convention=xdata_reen /
//                          trant --place_constants=data --nr_virtual_regs 8  /
//                          -I "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Pro /
//                          jects\Examples\SRF04\UART_Bridge\IAR\..\..\..\..\ /
//                          ..\Components\bsp\" -I "C:\Texas                  /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\..\..\..\..\..\Components /
//                          \bsp\drivers\" -I "C:\Texas                       /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\..\..\..\..\..\Components /
//                          \bsp\boards\SRF04EB\" -I "C:\Texas                /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\..\..\..\..\..\Components /
//                          \mrfi\" -I "C:\Texas Instruments\SimpliciTI-IAR-1 /
//                          .2.0\Projects\Examples\SRF04\UART_Bridge\IAR\..\. /
//                          .\..\..\..\Components\SimpliciTI\nwk\" -I         /
//                          "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF04\UART_Bridge\IAR\..\..\..\..\..\ /
//                          Components\SimpliciTI\nwk_applications\" -Ohs     /
//                          --require_prototypes                              /
//    List file          =  C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF04\UART_Bridge\IAR\CC1110-LinkTo\Li /
//                          st\nwk_QMgmt.s51                                  /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME nwk_QMgmt

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ADD_XSTACK_DISP0_8
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?DPH1
        EXTERN ?DPL1
        EXTERN ?DPS
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_RESTORE_DPTRS_1
        EXTERN ?XSTACK_SAVE_DPTRS_1
        EXTERN __INIT_XDATA_Z

        PUBWEAK _A_IEN0
        PUBLIC nwk_QInit
        PUBLIC nwk_QadjustOrder
        PUBLIC nwk_QfindOldest
        PUBLIC nwk_QfindSlot
        PUBLIC nwk_getQ

        EXTERN memset
        EXTERN nwk_getConnInfo
        EXTERN memcmp

// C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\nwk_QMgmt.c
//    1 /**************************************************************************************************
//    2   Filename:       nwk_QMgmt.c
//    3   Revised:        $Date: 2011-10-26 15:44:58 -0700 (Wed, 26 Oct 2011) $
//    4   Revision:       $Revision: 28059 $
//    5   Author:         $Author: jnoxon $
//    6 
//    7   Description:    This file supports the SimpliciTI input and output frame queues
//    8 
//    9   Copyright 2007-2008 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights granted under
//   12   the terms of a software license agreement between the user who downloaded the software,
//   13   his/her employer (which must be your employer) and Texas Instruments Incorporated (the
//   14   "License"). You may not use this Software unless you agree to abide by the terms of the
//   15   License. The License limits your use, and you acknowledge, that the Software may not be
//   16   modified, copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio frequency
//   18   transceiver, which is integrated into your product. Other than for the foregoing purpose,
//   19   you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
//   20   perform, display or sell this Software and/or its documentation for any purpose.
//   21 
//   22   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS”
//   23   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
//   24   WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
//   25   IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   26   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
//   27   THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
//   28   INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
//   29   DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
//   30   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   31 
//   32   Should you have any questions regarding your right to use this Software,
//   33   contact Texas Instruments Incorporated at www.TI.com.
//   34 **************************************************************************************************/
//   35 
//   36 
//   37 /******************************************************************************
//   38  * INCLUDES
//   39  */
//   40 #include <intrinsics.h>
//   41 #include <string.h>
//   42 #include "bsp.h"  

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DATA8
        DS 1
//   43 #include "mrfi.h"
//   44 #include "nwk_types.h"
//   45 #include "nwk.h"
//   46 #include "nwk_frame.h"
//   47 #include "nwk_QMgmt.h"
//   48 #include "nwk_mgmt.h"     /* need offsets for poll frames */
//   49 #ifdef DEBUG_CRITICAL_SECTIONS
//   50   #include "bsp_leds.h"
//   51 #endif
//   52 
//   53 
//   54 /******************************************************************************
//   55  * MACROS
//   56  */
//   57 
//   58 /******************************************************************************
//   59  * CONSTANTS AND DEFINES
//   60  */
//   61 
//   62 /******************************************************************************
//   63  * TYPEDEFS
//   64  */
//   65 
//   66 /******************************************************************************
//   67  * LOCAL VARIABLES
//   68  */
//   69 
//   70 #if SIZE_INFRAME_Q > 0

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   71 static frameInfo_t   sInFrameQ[SIZE_INFRAME_Q];
sInFrameQ:
        DS 100
        REQUIRE __INIT_XDATA_Z
//   72 #else
//   73 static frameInfo_t  *sInFrameQ = NULL;
//   74 #endif  /* SIZE_INFRAME_Q > 0 */
//   75 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   76 static frameInfo_t   sOutFrameQ[SIZE_OUTFRAME_Q];
sOutFrameQ:
        DS 100
        REQUIRE __INIT_XDATA_Z
//   77 
//   78 /******************************************************************************
//   79  * LOCAL FUNCTIONS
//   80  */
//   81 
//   82 /******************************************************************************
//   83  * GLOBAL VARIABLES
//   84  */
//   85 
//   86 /******************************************************************************
//   87  * GLOBAL FUNCTIONS
//   88  */
//   89 
//   90 /******************************************************************************
//   91 * @fn          nwk_QInit
//   92 * 
//   93 * @brief     Initialize the input and output frame queues to hold no packets. 
//   94 * 
//   95 * input parameters
//   96 * 
//   97 * output parameters
//   98 * 
//   99 * @return   void
//  100 */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  101 void nwk_QInit(void)
nwk_QInit:
        CODE
//  102 {
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
//  103 #if SIZE_INFRAME_Q > 0
//  104   memset(sInFrameQ, 0, sizeof(sInFrameQ));
        ; Setup parameters for call to function memset
        MOV     ?V0 + 0,#0x64
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R2,#sInFrameQ & 0xff
        MOV     R3,#(sInFrameQ >> 8) & 0xff
        LCALL   memset
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  105 #endif  // SIZE_INFRAME_Q > 0
//  106   memset(sOutFrameQ, 0, sizeof(sOutFrameQ));
        ; Setup parameters for call to function memset
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R2,#sOutFrameQ & 0xff
        MOV     R3,#(sOutFrameQ >> 8) & 0xff
        LCALL   memset
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  107 }
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  108  
//  109 /******************************************************************************
//  110  * @fn          nwk_QfindSlot
//  111  *
//  112  * @brief       Finds a slot to use to retrieve the frame from the radio. It
//  113  *              uses a LRU cast-out scheme. It is possible that this routine
//  114  *              finds no slot. This can happen if the queue is of size 1 or 2
//  115  *              and the Rx interrupt occurs during a retrieval call from an
//  116  *              application. There are meta-states for frames as the application
//  117  *              looks for the oldest frame on the port being requested.
//  118  *
//  119  *              This routine is running in interrupt context.
//  120  *
//  121  * input parameters
//  122  * @param   which   - INQ or OUTQ to search
//  123  *
//  124  * output parameters
//  125  *
//  126  * @return      Pointer to oldest available frame in the queue
//  127  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  128 frameInfo_t *nwk_QfindSlot(uint8_t which)
nwk_QfindSlot:
        CODE
//  129 {
        MOV     A,#-0xa
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R1
        MOV     R4,A
//  130   frameInfo_t *pFI, *oldest= 0, *newFI = 0;
        MOV     R0,#0x0
        MOV     R1,#0x0
        MOV     R2,#0x0
        MOV     R3,#0x0
//  131   uint8_t        i, num, newOrder = 0, orderTest;
        MOV     R7,#0x0
//  132 
//  133   if (INQ == which)
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??nwk_QfindSlot_0
//  134   {
//  135     pFI  = sInFrameQ;
        MOV     DPL,#sInFrameQ & 0xff
        MOV     DPH,#(sInFrameQ >> 8) & 0xff
//  136     num  = SIZE_INFRAME_Q;
        SJMP    ??nwk_QfindSlot_1
//  137   }
//  138   else
//  139   {
//  140     pFI  = sOutFrameQ;
??nwk_QfindSlot_0:
        MOV     DPL,#sOutFrameQ & 0xff
        MOV     DPH,#(sOutFrameQ >> 8) & 0xff
//  141     num  = SIZE_OUTFRAME_Q;
//  142   }
//  143 
//  144   orderTest = num + 1;
??nwk_QfindSlot_1:
        MOV     R5,#0x3
//  145 
//  146   for (i=0; i<num; ++i, ++pFI)
        MOV     R6,#0x0
//  147   {
//  148     /* if frame is available it's a candidate. */
//  149     if (pFI->fi_usage != FI_AVAILABLE)
??nwk_QfindSlot_2:
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        MOVX    A,@DPTR
        JZ      ??nwk_QfindSlot_3
//  150     {
//  151       if (INQ == which)  /* TODO: do cast-out for Tx as well */
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??nwk_QfindSlot_4
//  152       {
//  153 
//  154         /* need to know the number of occupied slots so we know the age value
//  155          * for the unoccupied slot (if there is one).
//  156          */
//  157         newOrder++;
        INC     R7
//  158 
//  159         /* make sure nwk_retrieveFrame() is not processing this frame */
//  160         if (FI_INUSE_TRANSITION == pFI->fi_usage)
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??nwk_QfindSlot_4
//  161         {
//  162           continue;
//  163         }
//  164         /* is this frame older than any we've seen? */
//  165         if (orderTest > pFI->orderStamp)
        MOV     ?DPL1,DPL
        MOV     ?DPH1,DPH
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        INC     DPTR/*1*/
        MOVX    A,@DPTR/*1*/
        MOV     ?V0 + 0,A
        CLR     C
        SUBB    A,R5
        JNC     ??nwk_QfindSlot_4
//  166         {
//  167           /* yes. */
//  168           oldest    = pFI;
        MOV     R0,DPL
        MOV     R1,DPH
//  169           orderTest = pFI->orderStamp;
        MOV     R5,?V0 + 0
        SJMP    ??nwk_QfindSlot_4
//  170         }
//  171       }
//  172     }
//  173     else
//  174     {
//  175       if (OUTQ == which)  /* TODO: do cast-out for Tx as well */
??nwk_QfindSlot_3:
        MOV     A,#0x2
        XRL     A,R4
        MOV     R2,DPL
        MOV     R3,DPH
        JNZ     $+5
        LJMP    ??nwk_QfindSlot_5
//  176       {
//  177         return pFI;
//  178       }
//  179       newFI = pFI;
//  180     }
//  181   }
??nwk_QfindSlot_4:
        INC     R6
        MOV     A,DPL
        ADD     A,#0x32
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,R6
        CLR     C
        SUBB    A,#0x2
        JC      ??nwk_QfindSlot_2
//  182 
//  183   /* did we find anything? */
//  184   if (!newFI)
        MOV     A,R2
        ORL     A,R3
        JNZ     ??nwk_QfindSlot_6
//  185   {
//  186     /* queue was full. cast-out happens here...unless... */
//  187     if (!oldest)
        MOV     A,R0
        ORL     A,R1
        JNZ     ??nwk_QfindSlot_7
//  188     {
//  189       /* This can happen if the queue is only of size 1 or 2 and all
//  190        * the frames are in transition when the Rx interrupt occurs.
//  191        */
//  192       return (frameInfo_t *)0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??nwk_QfindSlot_5
//  193     }
//  194     newFI = oldest;
??nwk_QfindSlot_7:
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
//  195     nwk_QadjustOrder(which, newFI->orderStamp);
        MOV     ?DPL1,R2
        MOV     ?DPH1,R3
        ; Selecting DPTR 1 by inc-method (DPSEL=x)
        ORL     ?DPS,#0x1
        INC     DPTR/*1*/
        MOVX    A,@DPTR/*1*/
        MOV     ?V0 + 1,A
        MOV     A,#0x1
        XRL     A,R4
        JNZ     ??nwk_QfindSlot_8
        MOV     R0,#sInFrameQ & 0xff
        MOV     R1,#(sInFrameQ >> 8) & 0xff
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     ?V0 + 2,A
        CLR     0xa8.7
        MOV     R7,#0x2
??nwk_QfindSlot_9:
        MOV     DPL,R0
        MOV     DPH,R1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        MOVX    A,@DPTR
        JZ      ??nwk_QfindSlot_10
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        CLR     C
        SUBB    A,?V0 + 0
        JNC     ??nwk_QfindSlot_10
        MOVX    A,@DPTR
        DEC     A
        MOVX    @DPTR,A
??nwk_QfindSlot_10:
        MOV     A,R0
        ADD     A,#0x32
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        DEC     R7
        MOV     A,R7
        JNZ     ??nwk_QfindSlot_9
        MOV     A,?V0 + 2
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  196     newFI->orderStamp = i;
??nwk_QfindSlot_8:
        MOV     A,R6
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        SJMP    ??nwk_QfindSlot_11
//  197   }
//  198   else
//  199   {
//  200     /* mark the available slot. */
//  201     newFI->orderStamp = ++newOrder;
??nwk_QfindSlot_6:
        MOV     A,#0x1
        ADD     A,R7
        MOV     DPL,R2
        MOV     DPH,R3
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        INC     DPTR
??nwk_QfindSlot_11:
        MOVX    @DPTR,A
//  202   }
//  203 
//  204   return newFI;
??nwk_QfindSlot_5:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x3
        LJMP    ?FUNC_LEAVE_XDATA
        REQUIRE _A_IEN0
//  205 }
//  206 
//  207 /******************************************************************************
//  208  * @fn          nwk_QadjustOrder
//  209  *
//  210  * @brief       Adjusts the age of everyone in the queue newer than the frame
//  211  *              being removed.
//  212  *
//  213  * input parameters
//  214  * @param   which   - INQ or OUTQ to adjust
//  215  * @param   stamp   - value of frame being removed
//  216  *
//  217  * output parameters
//  218  *
//  219  * @return      void
//  220  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  221 void nwk_QadjustOrder(uint8_t which, uint8_t stamp)
nwk_QadjustOrder:
        CODE
//  222 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 10
        ; Auto size: 0
//  223   frameInfo_t *pFI;
//  224   uint8_t      i, num;
//  225   bspIState_t  intState;
//  226 
//  227   if (INQ == which)
        MOV     A,#0x1
        XRL     A,R1
        JNZ     ??nwk_QadjustOrder_0
//  228   {
//  229     pFI  = sInFrameQ;
        MOV     DPL,#sInFrameQ & 0xff
        MOV     DPH,#(sInFrameQ >> 8) & 0xff
//  230     num  = SIZE_INFRAME_Q;
//  231   }
//  232   else
//  233   {
//  234 /*    pFI  = sOutFrameQ; */
//  235 /*    num  = SIZE_OUTFRAME_Q; */
//  236     return;
//  237   }
//  238 
//  239   BSP_ENTER_CRITICAL_SECTION(intState);
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     R4,A
        CLR     0xa8.7
//  240 
//  241   for (i=0; i<num; ++i, ++pFI)
        MOV     R3,#0x2
//  242   {
//  243     if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
??nwk_QadjustOrder_1:
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        MOVX    A,@DPTR
        JZ      ??nwk_QadjustOrder_2
        MOV     ?DPL1,DPL
        MOV     ?DPH1,DPH
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        INC     DPTR/*1*/
        MOVX    A,@DPTR/*1*/
        MOV     R0,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        JNC     ??nwk_QadjustOrder_2
//  244     {
//  245       pFI->orderStamp--;
        MOVX    A,@DPTR/*1*/
        DEC     A
        MOVX    @DPTR/*1*/,A
//  246     }
//  247   }
??nwk_QadjustOrder_2:
        MOV     A,DPL
        ADD     A,#0x32
        MOV     DPL,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     DPH,A
        DEC     R3
        MOV     A,R3
        JNZ     ??nwk_QadjustOrder_1
//  248 
//  249   BSP_EXIT_CRITICAL_SECTION(intState);
        MOV     A,R4
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  250 
//  251   return;
??nwk_QadjustOrder_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
        REQUIRE _A_IEN0
//  252 }
//  253 
//  254 /******************************************************************************
//  255  * @fn          nwk_QfindOldest
//  256  *
//  257  * @brief       Look through frame queue and find the oldest available frame
//  258  *              in the context in question. Supports connection-based (user),
//  259  *              non-connection based (NWK applications), and the special case
//  260  *              of store-and-forward.
//  261  *
//  262  * input parameters
//  263  * @param   which      - INQ or OUTQ to adjust
//  264  * @param   rcvContext - context information for finding the oldest
//  265  * @param   usage      - normal usage or store-and-forward usage
//  266  *
//  267  * output parameters
//  268  *
//  269  * @return      Pointer to frame that is the oldsest on the requested port, or
//  270  *              0 if there are none.
//  271  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  272 frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
nwk_QfindOldest:
        CODE
//  273 {
        MOV     A,#-0xf
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 17
        ; Auto size: 10
        MOV     A,#-0xa
        LCALL   ?ALLOC_XSTACK8
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R4
        MOVX    @DPTR,A
//  274   uint8_t      i, oldest, num, port;
//  275   uint8_t      uType, addr12Compare;
//  276   bspIState_t  intState;
//  277   frameInfo_t *fPtr = 0, *wPtr;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  278   connInfo_t  *pCInfo = 0;
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
//  279   uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  280 
//  281   if (INQ == which)
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??nwk_QfindOldest_0
//  282   {
//  283     wPtr   = sInFrameQ;
        MOV     ?V0 + 4,#sInFrameQ & 0xff
        MOV     ?V0 + 5,#(sInFrameQ >> 8) & 0xff
//  284     num    = SIZE_INFRAME_Q;
//  285     oldest = SIZE_INFRAME_Q+1;
        MOV     R7,#0x3
//  286   }
//  287   else
//  288   {
//  289 /*    pFI  = sOutFrameQ; */
//  290 /*    num  = SIZE_OUTFRAME_Q; */
//  291     return 0;
//  292   }
//  293 
//  294   if (RCV_APP_LID == rcv->type)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     ?DPL1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?DPH1,A
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        MOVX    A,@DPTR/*1*/
        MOV     R0,A
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??nwk_QfindOldest_1
//  295   {
//  296     pCInfo = nwk_getConnInfo(rcv->t.lid);
        ; Setup parameters for call to function nwk_getConnInfo
        INC     DPTR/*1*/
        MOVX    A,@DPTR/*1*/
        MOV     R1,A
        LCALL   nwk_getConnInfo
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
//  297     if (!pCInfo)
        MOV     A,R2
        ORL     A,?V0 + 7
        JNZ     ??nwk_QfindOldest_2
??nwk_QfindOldest_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??nwk_QfindOldest_3
//  298     {
//  299       return (frameInfo_t *)0;
//  300     }
//  301     port   = pCInfo->portRx;
??nwk_QfindOldest_2:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
//  302     pAddr2 = pCInfo->peerAddr;
        MOV     ?DPL1,R2
        MOV     ?DPH1,R3
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        INC     DPTR/*1*/
        INC     DPTR/*1*/
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?DPL1
        ; Selecting DPTR 0 by inc-method (DPSEL=1)
        INC     ?DPS
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?DPH1
        MOVX    @DPTR,A
        SJMP    ??nwk_QfindOldest_4
//  303   }
//  304   else if (RCV_NWK_PORT == rcv->type)
??nwk_QfindOldest_1:
        MOV     A,R0
        JNZ     ??nwk_QfindOldest_0
//  305   {
//  306     port = rcv->t.port;
        INC     DPTR/*1*/
        MOVX    A,@DPTR/*1*/
        MOV     R6,A
//  307   }
//  308 #ifdef ACCESS_POINT
//  309   else if (RCV_RAW_POLL_FRAME == rcv->type)
//  310   {
//  311     port   = *(MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_PORT_OS);
//  312     pAddr2 = MRFI_P_SRC_ADDR(rcv->t.pkt);
//  313     pAddr3 = MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_ADDR_OS;
//  314   }
//  315 #endif
//  316   else
//  317   {
//  318     return (frameInfo_t *)0;
//  319   }
//  320 
//  321   uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
??nwk_QfindOldest_4:
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??nwk_QfindOldest_5
        MOV     ?V0 + 0,#0x1
        SJMP    ??nwk_QfindOldest_6
??nwk_QfindOldest_5:
        MOV     ?V0 + 0,R7
//  322 
//  323   for (i=0; i<num; ++i, ++wPtr)
??nwk_QfindOldest_6:
        MOV     ?V0 + 1,#0x2
//  324   {
//  325 
//  326     BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */
??nwk_QfindOldest_7:
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     R0,A
        CLR     0xa8.7
//  327 
//  328     /* only check entries in use and waiting for this port */
//  329     if (uType == wPtr->fi_usage)
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        XRL     A,?V0 + 0
        JZ      $+5
        LJMP    ??nwk_QfindOldest_8
//  330     {
//  331       wPtr->fi_usage = FI_INUSE_TRANSITION;
        MOV     A,#0x4
        MOVX    @DPTR,A
//  332 
//  333       BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  334       /* message sent to this device? */
//  335       if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
        MOV     A,?V0 + 4
        ADD     A,#0xb
        MOV     DPL,A
        MOV     A,?V0 + 5
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ANL     A,#0x3f
        XRL     A,R6
        JZ      $+5
        LJMP    ??nwk_QfindOldest_9
//  336       {
//  337         /* Port matches. If the port of interest is a NWK applicaiton we're a
//  338          * match...the NWK applications are not connection-based. If it is a
//  339          * NWK application we need to check the source address for disambiguation.
//  340          * Also need to check source address if it's a raw frame lookup (S&F frame)
//  341          */
//  342         if (RCV_APP_LID == rcv->type)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     ?DPL1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?DPH1,A
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        MOVX    A,@DPTR/*1*/
        XRL     A,#0x1
        JNZ     ??nwk_QfindOldest_10
//  343         {
//  344           if (SMPL_PORT_USER_BCAST == port)
        MOV     A,#0x3f
        XRL     A,R6
        JNZ     ??nwk_QfindOldest_11
//  345           {
//  346             /* guarantee a match... */
//  347             pAddr1 = pCInfo->peerAddr;
        MOV     ?DPL1,?V0 + 6
        MOV     ?DPH1,?V0 + 7
        SJMP    ??nwk_QfindOldest_12
//  348           }
//  349           else
//  350           {
//  351             pAddr1 = MRFI_P_SRC_ADDR(&wPtr->mrfiPkt);
??nwk_QfindOldest_11:
        MOV     ?DPL1,?V0 + 4
        MOV     ?DPH1,?V0 + 5
        INC     DPTR/*1*/
        INC     DPTR/*1*/
        INC     DPTR/*1*/
        INC     DPTR/*1*/
        INC     DPTR/*1*/
??nwk_QfindOldest_12:
        INC     DPTR/*1*/
        INC     DPTR/*1*/
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?DPL1
        ; Selecting DPTR 0 by inc-method (DPSEL=1)
        INC     ?DPS
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?DPH1
        MOVX    @DPTR,A
//  352           }
//  353         }
//  354 #ifdef ACCESS_POINT
//  355         else if (RCV_RAW_POLL_FRAME == rcv->type)
//  356         {
//  357           pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
//  358         }
//  359 #endif
//  360 
//  361         addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
??nwk_QfindOldest_10:
        ; Setup parameters for call to function memcmp
        MOV     ?V0 + 2,#0x4
        MOV     ?V0 + 3,#0x0
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   memcmp
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  362         if (  (RCV_NWK_PORT == rcv->type) ||
//  363               (!pAddr3 && !addr12Compare) ||
//  364               (pAddr3 && !memcmp(pAddr3, MRFI_P_SRC_ADDR(&wPtr->mrfiPkt), NET_ADDR_SIZE))
//  365            )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     ?DPL1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?DPH1,A
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        MOVX    A,@DPTR/*1*/
        JZ      ??nwk_QfindOldest_13
        MOV     A,R2
        JNZ     ??nwk_QfindOldest_9
//  366         {
//  367           if (wPtr->orderStamp < oldest)
??nwk_QfindOldest_13:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        ; Selecting DPTR 0 by inc-method (DPSEL=1)
        INC     ?DPS
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R7
        JNC     ??nwk_QfindOldest_9
//  368           {
//  369             if (fPtr)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        JZ      ??nwk_QfindOldest_14
//  370             {
//  371               /* restore previous oldest one */
//  372               fPtr->fi_usage = uType;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?DPL1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?DPH1,A
        MOV     A,?V0 + 0
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        MOVX    @DPTR/*1*/,A
//  373             }
//  374             oldest = wPtr->orderStamp;
??nwk_QfindOldest_14:
        MOV     DPL,R0
        MOV     DPH,R1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        MOVX    A,@DPTR
        MOV     R7,A
//  375             fPtr   = wPtr;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 5
??nwk_QfindOldest_15:
        MOVX    @DPTR,A
//  376             continue;
        SJMP    ??nwk_QfindOldest_16
//  377           }
//  378           else
//  379           {
//  380             /* not oldest. restore state */
//  381             wPtr->fi_usage = uType;
??nwk_QfindOldest_9:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOV     A,?V0 + 0
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        SJMP    ??nwk_QfindOldest_15
//  382           }
//  383         }
//  384         else
//  385         {
//  386           /* not a match. restore state */
//  387           wPtr->fi_usage = uType;
//  388         }
//  389       }
//  390       else
//  391       {
//  392         /* wrong port. restore state */
//  393         wPtr->fi_usage = uType;
//  394       }
//  395     }
//  396     else
//  397     {
//  398       BSP_EXIT_CRITICAL_SECTION(intState);
??nwk_QfindOldest_8:
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  399     }
//  400   }
??nwk_QfindOldest_16:
        MOV     A,?V0 + 4
        ADD     A,#0x32
        MOV     ?V0 + 4,A
        MOV     A,?V0 + 5
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
        DEC     ?V0 + 1
        MOV     A,?V0 + 1
        JZ      $+5
        LJMP    ??nwk_QfindOldest_7
//  401 
//  402   return fPtr;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
??nwk_QfindOldest_3:
        MOV     A,#0xa
        LCALL   ?DEALLOC_XSTACK8
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x8
        LJMP    ?FUNC_LEAVE_XDATA
        REQUIRE _A_IEN0
//  403 }
//  404 
//  405 /******************************************************************************
//  406  * @fn          nwk_getQ
//  407  *
//  408  * @brief       Get location of teh specified frame queue.
//  409  *
//  410  * input parameters
//  411  * @param   which   - INQ or OUTQ to get
//  412  *
//  413  * output parameters
//  414  *
//  415  * @return      Pointer to frame queue
//  416  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  417 frameInfo_t *nwk_getQ(uint8_t which)
nwk_getQ:
        CODE
//  418 {
        ; Saved register size: 0
        ; Auto size: 0
//  419   return (INQ == which) ? sInFrameQ : sOutFrameQ;
        MOV     A,#0x1
        XRL     A,R1
        JNZ     ??nwk_getQ_0
        MOV     R2,#sInFrameQ & 0xff
        MOV     R3,#(sInFrameQ >> 8) & 0xff
        SJMP    ??nwk_getQ_1
??nwk_getQ_0:
        MOV     R2,#sOutFrameQ & 0xff
        MOV     R3,#(sOutFrameQ >> 8) & 0xff
??nwk_getQ_1:
        ANL     ?DPS,#0xfe
        RET
//  420 }

        END
//  421 
// 
// 966 bytes in segment NEAR_CODE
//   1 byte  in segment SFR_AN
// 200 bytes in segment XDATA_Z
// 
// 966 bytes of CODE  memory
//   0 bytes of DATA  memory (+ 1 byte shared)
// 200 bytes of XDATA memory
//
//Errors: none
//Warnings: none
