///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.4.40412/W32 for 8051        22/Jul/2016  20:57:15 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\ /
//                          nwk_frame.c                                       /
//    Command line       =  -f C:\Users\freeman\Documents\work\NBK\Nikon\Niko /
//                          n_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05 /
//                          _8051\nik_sb5000\IAR\Configuration\LinkTo\smpl_co /
//                          nfig.dat ("-DTHIS_DEVICE_ADDRESS={0x79, 0x56,     /
//                          0x34, 0x12}" -DxNWK_PLL_REFERENCE_CLOCK           /
//                          -DLINK_TO) -f C:\Users\freeman\Documents\work\NBK /
//                          \Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exa /
//                          mples\SRF05_8051\nik_sb5000\IAR\Configuration\smp /
//                          l_nwk_config.dat (-DMAX_HOPS=3                    /
//                          -DMAX_HOPS_FROM_AP=1 -DMAX_NWK_PAYLOAD=34         /
//                          -DMAX_APP_PAYLOAD=10 -DDEFAULT_LINK_TOKEN=0x01020 /
//                          304 -DDEFAULT_JOIN_TOKEN=0x05060708               /
//                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK              /
//                          -DxEXTENDED_API -DxSMPL_SECURE                    /
//                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                   /
//                          -DNUM_CONNECTIONS=2 -DSIZE_INFRAME_Q=4            /
//                          -DSIZE_OUTFRAME_Q=2 -DxFREQUENCY_HOPPING          /
//                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                /
//                          -DUART_NUMBER=UART_NUMBER_0                       /
//                          -DUART_LOCATION=UART_LOCATION_1                   /
//                          -DUART_BAUD_RATE=115200                           /
//                          -DUART_FLOW_CONTROL=UART_FLOW_CONTROL_OFF         /
//                          -DUART_PARITY_MODE=UART_PARITY_NONE               /
//                          -DUART_STOP_BITS=UART_1_STOP_BIT                  /
//                          -DBSP_TIMER_USED=1 -DEND_DEVICE)                  /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\ /
//                          nwk_frame.c -D MCU_H=<ioCC2530.h> -D MRFI_CC2530  /
//                          -D ZTOOL_P1 -D MRFI_PA_LNA_ENABLED -lC            /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\ -lA                /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\ -o                 /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\Obj\ -e --debug          /
//                          --core=plain --dptr=16,1 --data_model=large       /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data --nr_virtual_regs  /
//                          16 -I C:\Users\freeman\Documents\work\NBK\Nikon\N /
//                          ikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SR /
//                          F05_8051\nik_sb5000\IAR\..\..\..\..\..\Components /
//                          \bsp\ -I C:\Users\freeman\Documents\work\NBK\Niko /
//                          n\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples /
//                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compone /
//                          nts\bsp\drivers\ -I C:\Users\freeman\Documents\wo /
//                          rk\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. /
//                          \..\Components\bsp\boards\CC2530EM\ -I            /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\mrfi\ /
//                           -I C:\Users\freeman\Documents\work\NBK\Nikon\Nik /
//                          on_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF0 /
//                          5_8051\nik_sb5000\IAR\..\..\..\..\..\Components\S /
//                          impliciTI\nwk\ -I C:\Users\freeman\Documents\work /
//                          \NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects /
//                          \Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\Appl /
//                          ications\ -I C:\Users\freeman\Documents\work\NBK\ /
//                          Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exam /
//                          ples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Com /
//                          ponents\SimpliciTI\nwk_applications\ -I           /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\OSAL\ /
//                          INCLUDE\ -I C:\Users\freeman\Documents\work\NBK\N /
//                          ikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp /
//                          les\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Comp /
//                          onents\OSAL\MCU\CCSOC\ -I                         /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\HAL\I /
//                          NCLUDE\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\HAL\TARGET\CC2530EB\ -I                     /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\SERVI /
//                          CES\SADDR\ -I C:\Users\freeman\Documents\work\NBK /
//                          \Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exa /
//                          mples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Co /
//                          mponents\SERVICES\SDATA\ -I                       /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MT\   /
//                          -I C:\Users\freeman\Documents\work\NBK\Nikon\Niko /
//                          n_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05 /
//                          _8051\nik_sb5000\IAR\..\..\..\..\..\Components\ST /
//                          ACK\AF\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\STACK\NWK\ -I C:\Users\freeman\Documents\wo /
//                          rk\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. /
//                          \..\Components\STACK\SEC\ -I                      /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\STACK /
//                          \SAPI\ -I C:\Users\freeman\Documents\work\NBK\Nik /
//                          on\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compon /
//                          ents\STACK\SYS\ -I C:\Users\freeman\Documents\wor /
//                          k\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\ /
//                          ..\Components\STACK\ZDO\ -I                       /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MAC\I /
//                          NCLUDE\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\MAC\HIGH_LEVEL\ -I                          /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MAC\L /
//                          OW_LEVEL\srf04\ -I C:\Users\freeman\Documents\wor /
//                          k\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\ /
//                          ..\Components\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\    /
//                          -Ohz --require_prototypes                         /
//    List file          =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\nwk_frame.s51       /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME nwk_frame

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?V0
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        PUBLIC ??MRFI_RxCompleteISR?relay
        FUNCTION ??MRFI_RxCompleteISR?relay,0203H
        PUBLIC ??nwk_buildFrame?relay
        FUNCTION ??nwk_buildFrame?relay,0203H
        PUBLIC ??nwk_frameInit?relay
        FUNCTION ??nwk_frameInit?relay,0203H
        PUBLIC ??nwk_getMyRxType?relay
        FUNCTION ??nwk_getMyRxType?relay,0203H
        PUBLIC ??nwk_retrieveFrame?relay
        FUNCTION ??nwk_retrieveFrame?relay,0203H
        PUBLIC ??nwk_sendFrame?relay
        FUNCTION ??nwk_sendFrame?relay,0203H
        PUBLIC MRFI_RxCompleteISR
        FUNCTION MRFI_RxCompleteISR,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC nwk_buildFrame
        FUNCTION nwk_buildFrame,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC nwk_frameInit
        FUNCTION nwk_frameInit,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC nwk_getMyRxType
        FUNCTION nwk_getMyRxType,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC nwk_retrieveFrame
        FUNCTION nwk_retrieveFrame,021203H
        ARGFRAME XSTACK, 6, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 24, STACK
        PUBLIC nwk_sendFrame
        FUNCTION nwk_sendFrame,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT SameValue
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
nwk_getMyAddress    SYMBOL "nwk_getMyAddress"
MRFI_RandomByte     SYMBOL "MRFI_RandomByte"
nwk_QfindSlot       SYMBOL "nwk_QfindSlot"
memcpy              SYMBOL "memcpy"
MRFI_Receive        SYMBOL "MRFI_Receive"
nwk_QfindOldest     SYMBOL "nwk_QfindOldest"
nwk_getConnInfo     SYMBOL "nwk_getConnInfo"
nwk_QadjustOrder    SYMBOL "nwk_QadjustOrder"
MRFI_Transmit       SYMBOL "MRFI_Transmit"
??MRFI_RandomByte?relay SYMBOL "?relay", MRFI_RandomByte
??MRFI_Receive?relay SYMBOL "?relay", MRFI_Receive
??MRFI_Transmit?relay SYMBOL "?relay", MRFI_Transmit
??memcpy?relay      SYMBOL "?relay", memcpy
??nwk_QadjustOrder?relay SYMBOL "?relay", nwk_QadjustOrder
??nwk_QfindOldest?relay SYMBOL "?relay", nwk_QfindOldest
??nwk_QfindSlot?relay SYMBOL "?relay", nwk_QfindSlot
??nwk_getConnInfo?relay SYMBOL "?relay", nwk_getConnInfo
??nwk_getMyAddress?relay SYMBOL "?relay", nwk_getMyAddress
MRFI_RxCompleteISR  SYMBOL "MRFI_RxCompleteISR"
??MRFI_RxCompleteISR?relay SYMBOL "?relay", MRFI_RxCompleteISR
nwk_buildFrame      SYMBOL "nwk_buildFrame"
??nwk_buildFrame?relay SYMBOL "?relay", nwk_buildFrame
nwk_frameInit       SYMBOL "nwk_frameInit"
??nwk_frameInit?relay SYMBOL "?relay", nwk_frameInit
nwk_getMyRxType     SYMBOL "nwk_getMyRxType"
??nwk_getMyRxType?relay SYMBOL "?relay", nwk_getMyRxType
nwk_retrieveFrame   SYMBOL "nwk_retrieveFrame"
??nwk_retrieveFrame?relay SYMBOL "?relay", nwk_retrieveFrame
nwk_sendFrame       SYMBOL "nwk_sendFrame"
??nwk_sendFrame?relay SYMBOL "?relay", nwk_sendFrame

        EXTERN nwk_getMyAddress
        FUNCTION nwk_getMyAddress,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN MRFI_RandomByte
        FUNCTION MRFI_RandomByte,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nwk_QfindSlot
        FUNCTION nwk_QfindSlot,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcpy
        FUNCTION memcpy,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN MRFI_Receive
        FUNCTION MRFI_Receive,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nwk_QfindOldest
        FUNCTION nwk_QfindOldest,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nwk_getConnInfo
        FUNCTION nwk_getConnInfo,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nwk_QadjustOrder
        FUNCTION nwk_QadjustOrder,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN MRFI_Transmit
        FUNCTION MRFI_Transmit,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??MRFI_RandomByte?relay
        FUNCTION ??MRFI_RandomByte?relay,00H
        EXTERN ??MRFI_Receive?relay
        FUNCTION ??MRFI_Receive?relay,00H
        EXTERN ??MRFI_Transmit?relay
        FUNCTION ??MRFI_Transmit?relay,00H
        EXTERN ??memcpy?relay
        FUNCTION ??memcpy?relay,00H
        EXTERN ??nwk_QadjustOrder?relay
        FUNCTION ??nwk_QadjustOrder?relay,00H
        EXTERN ??nwk_QfindOldest?relay
        FUNCTION ??nwk_QfindOldest?relay,00H
        EXTERN ??nwk_QfindSlot?relay
        FUNCTION ??nwk_QfindSlot?relay,00H
        EXTERN ??nwk_getConnInfo?relay
        FUNCTION ??nwk_getConnInfo?relay,00H
        EXTERN ??nwk_getMyAddress?relay
        FUNCTION ??nwk_getMyAddress?relay,00H
        EXTERN g_pRcvPkt
        EXTERN g_rcvPkt

// C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\nwk_frame.c
//    1 /**************************************************************************************************
//    2   Filename:       nwk_frame.c
//    3   Revised:        $Date: 2011-10-26 15:37:41 -0700 (Wed, 26 Oct 2011) $
//    4   Revision:       $Revision: 28058 $
//    5   Author          $Author: jnoxon $
//    6 
//    7   Description:    This file supports the SimpliciTI frame handling functions.
//    8 
//    9   Copyright 2007-2009 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights granted under
//   12   the terms of a software license agreement between the user who downloaded the software,
//   13   his/her employer (which must be your employer) and Texas Instruments Incorporated (the
//   14   "License"). You may not use this Software unless you agree to abide by the terms of the
//   15   License. The License limits your use, and you acknowledge, that the Software may not be
//   16   modified, copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio frequency
//   18   transceiver, which is integrated into your product. Other than for the foregoing purpose,
//   19   you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
//   20   perform, display or sell this Software and/or its documentation for any purpose.
//   21 
//   22   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS?  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
//   23   WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
//   24   IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   25   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
//   26   THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
//   27   INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
//   28   DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
//   29   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   30 
//   31   Should you have any questions regarding your right to use this Software,
//   32   contact Texas Instruments Incorporated at www.TI.com.
//   33 **************************************************************************************************/
//   34 
//   35 
//   36 /******************************************************************************
//   37  * INCLUDES
//   38  */
//   39 
//   40 #include <string.h>
//   41 #include "bsp.h"
//   42 #include "mrfi.h"
//   43 #include "nwk_types.h"
//   44 #include "nwk_frame.h"
//   45 #include "nwk.h"
//   46 #include "nwk_app.h"
//   47 #include "nwk_QMgmt.h"
//   48 #include "nwk_globals.h"
//   49 #include "nwk_mgmt.h"
//   50 #include "nwk_security.h"
//   51 
//   52 /******************************************************************************
//   53  * MACROS
//   54  */
//   55 
//   56 /******************************************************************************
//   57  * CONSTANTS AND DEFINES
//   58  */
//   59 
//   60 /******************************************************************************
//   61  * TYPEDEFS
//   62  */
//   63 
//   64 /******************************************************************************
//   65  * LOCAL VARIABLES
//   66  */
//   67 
//   68 #if SIZE_INFRAME_Q > 0
//   69 /* array of function pointers to handle NWK application frames */
//   70 static  fhStatus_t (* const func[])(mrfiPacket_t *) = { nwk_processPing,
//   71                                                         nwk_processLink,
//   72                                                         nwk_processJoin,
//   73                                                         nwk_processSecurity,
//   74                                                         nwk_processFreq,
//   75                                                         nwk_processMgmt
//   76 #ifdef NWK_PLL
//   77                                                           ,
//   78                                                         nwk_processPLL
//   79 #endif
//   80                                                       };
//   81 #endif  /* SIZE_INFRAME_Q > 0 */
//   82 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   83 static uint8_t sTRACTID = 0;
sTRACTID:
        DS 1
        REQUIRE __INIT_XDATA_Z
//   84 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//   85 static addr_t const *sMyAddr = NULL;
sMyAddr:
        DS 2
        REQUIRE __INIT_XDATA_Z
//   86 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   87 static uint8_t  sMyRxType = 0, sMyTxType = 0;
sMyRxType:
        DS 1
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
sMyTxType:
        DS 1
        REQUIRE __INIT_XDATA_Z
//   88 
//   89 #if !defined(RX_POLLS)

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//   90 static uint8_t  (*spCallback)(linkID_t) = NULL;
spCallback:
        DS 2
        REQUIRE __INIT_XDATA_Z
//   91 #endif
//   92 
//   93 /******************************************************************************
//   94  * LOCAL FUNCTIONS
//   95  */
//   96 
//   97 #if SIZE_INFRAME_Q > 0
//   98 /* local helper functions for Rx devices */
//   99 static void  dispatchFrame(frameInfo_t *);
//  100 static void GetDeviceInfo(frameInfo_t *fiPtr);
//  101 #if !defined(END_DEVICE)
//  102 #if defined(ACCESS_POINT)
//  103 /* only Access Points need to worry about duplicate S&F frames */
//  104 uint8_t  isDupSandFFrame(mrfiPacket_t *);
//  105 #endif /* ACCESS_POINT */
//  106 #endif  /* !END_DEVICE */
//  107 #endif  /* SIZE_INFRAME_Q > 0 */
//  108 
//  109 /******************************************************************************
//  110  * GLOBAL VARIABLES
//  111  */
//  112 extern uint8_t g_rcvPkt;
//  113 extern mrfiPacket_t * g_pRcvPkt;
//  114 /******************************************************************************
//  115  * GLOBAL FUNCTIONS
//  116  */
//  117 
//  118 /******************************************************************************
//  119  * @fn          nwk_frameInit
//  120  *
//  121  * @brief       Initialize network context.
//  122  *
//  123  * input parameters
//  124  *       pF - Pointer to callback function. If none intended should be NULL.
//  125  *
//  126  * output parameters
//  127  *
//  128  * @return    void
//  129  */
//  130 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  131 void nwk_frameInit(uint8_t (*pF)(linkID_t))
nwk_frameInit:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function nwk_frameInit
        CODE
//  132 {
        FUNCALL nwk_frameInit, nwk_getMyAddress
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_frameInit, MRFI_RandomByte
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  133 
//  134 /****** Fill static values for the DEVICEINFO byte that will go in each frame ******/
//  135   /* Rx type when frame originates from this device. Set in nwk_buildFrame() */
//  136   /* Tx type when frame sent from this device. Set in nwk_sendframe() */
//  137 #if !defined(END_DEVICE)
//  138     sMyRxType = F_RX_TYPE_USER_CTL;
//  139   #if defined(ACCESS_POINT)
//  140     sMyTxType = F_TX_DEVICE_AP;
//  141   #else
//  142     sMyTxType = F_TX_DEVICE_RE;
//  143   #endif
//  144 #else
//  145     sMyTxType = F_TX_DEVICE_ED;
        MOV     DPTR,#sMyTxType
        CLR     A
        MOVX    @DPTR,A
//  146   #if defined(RX_POLLS)
//  147     sMyRxType = F_RX_TYPE_POLLS;
//  148   #endif
//  149   #if defined(RX_USER)
//  150     sMyRxType = F_RX_TYPE_USER_CTL;
//  151   #endif
//  152 #endif
//  153 /****** DONE fill static values for the DEVICEINFO byte that will go in each frame ******/
//  154 
//  155 #if !defined(RX_POLLS)
//  156   spCallback = pF;
        MOV     DPTR,#spCallback
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  157 #else
//  158   (void) pF;
//  159 #endif
//  160 
//  161   sMyAddr = nwk_getMyAddress();
        ; Setup parameters for call to function nwk_getMyAddress
        LCALL   ??nwk_getMyAddress?relay
        MOV     DPTR,#sMyAddr
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  162 
//  163   while (!(sTRACTID=MRFI_RandomByte())) ;
??nwk_frameInit_0:
        ; Setup parameters for call to function MRFI_RandomByte
        LCALL   ??MRFI_RandomByte?relay
        MOV     A,R1
        MOV     DPTR,#sTRACTID
        MOVX    @DPTR,A
        JZ      ??nwk_frameInit_0
        CFI EndBlock cfiBlock0
//  164 
//  165   return;
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0
//  166 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-5
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        POP     DPH
        CFI CFA_SP SP+-4
        CFI DPH0 SameValue
        POP     DPL
        CFI CFA_SP SP+-3
        CFI DPL0 SameValue
        LJMP    ?BRET
        CFI EndBlock cfiBlock1
//  167 
//  168 /******************************************************************************
//  169  * @fn          nwk_buildFrame
//  170  *
//  171  * @brief       Builds an output frame for the port and message enclosed.
//  172  *              This routine prepends the frame header and populates the
//  173  *              frame in the output queue.
//  174  *
//  175  * input parameters
//  176  * @param   port    - port from application
//  177  * @param   msg     - pointer to message from app to be sent
//  178  * @param   len     - length of enclosed message
//  179  * @param   hops    - number of hops allowed. this is less than MAX_HOPS
//  180  *                    whenever the frame is being sent to the AP. this is to
//  181  *                    help mitigate the (short) broadcast storms
//  182  *
//  183  * output parameters
//  184  *
//  185  * @return   pointer to frameInfo_t structure created. NULL if there is
//  186  *           no room in output queue.
//  187  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  188 frameInfo_t *nwk_buildFrame(uint8_t port, uint8_t *msg, uint8_t len, uint8_t hops)
nwk_buildFrame:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function nwk_buildFrame
        CODE
//  189 {
        FUNCALL nwk_buildFrame, nwk_QfindSlot
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_buildFrame, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_buildFrame, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 1,R4
        MOV     ?V0 + 2,R5
//  190   frameInfo_t  *fInfoPtr;
//  191 
//  192   if (!(fInfoPtr=nwk_QfindSlot(OUTQ)))
        ; Setup parameters for call to function nwk_QfindSlot
        MOV     R1,#0x2
        LCALL   ??nwk_QfindSlot?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R0,?V0 + 6
        MOV     R1,?V0 + 7
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??nwk_buildFrame_0
//  193   {
//  194     return (frameInfo_t *)NULL;
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??nwk_buildFrame_1 & 0xFFFF
//  195   }
//  196 
//  197   MRFI_SET_PAYLOAD_LEN(&fInfoPtr->mrfiPkt, len+F_APP_PAYLOAD_OS);
??nwk_buildFrame_0:
        MOV     A,#0xe
        ADD     A,?V0 + 1
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
//  198 
//  199   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ENCRYPT_OS, 0);
//  200   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_PORT_OS, port);
        MOV     A,R6
        ADD     A,#0xe
        MOV     R0,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        ANL     A,#0x80
        ORL     A,?V0 + 0
        MOVX    @DPTR,A
//  201   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_TRACTID_OS, sTRACTID);
        MOV     DPTR,#sTRACTID
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     A,R6
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  202   while (!(++sTRACTID)) ;  /* transaction ID can't be 0 */
??nwk_buildFrame_2:
        MOV     DPTR,#sTRACTID
        MOVX    A,@DPTR
        INC     A
        MOVX    @DPTR,A
        JZ      ??nwk_buildFrame_2
//  203   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_RX_TYPE, sMyRxType);
//  204   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_HOP_COUNT, hops);
//  205 
//  206   /* reset ack-relevant bits */
//  207   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ACK_REQ, 0);
//  208   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ACK_RPLY, 0);
        MOV     A,R6
        ADD     A,#0xf
        MOV     R2,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        ANL     A,#0xbf
        MOV     DPH,#(sMyRxType >> 8) & 0xff
        MOV     DPL,#sMyRxType & 0xff
        MOV     R4,A
        MOVX    A,@DPTR
        ORL     A,R4
        ANL     A,#0xf8
        ORL     A,?V0 + 2
        ANL     A,#0x77
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
//  209 
//  210   /* reset forwarding bit */
//  211   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_FWD_FRAME, 0);
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.7
        MOVX    @DPTR,A
//  212 
//  213   memcpy(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt)+F_APP_PAYLOAD_OS, msg, len);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 6,?V0 + 1
        MOV     ?V0 + 7,#0x0
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     R4,?V0 + 4
        MOV     R5,?V0 + 5
        MOV     A,R6
        ADD     A,#0x11
        INC     R2
        INC     R2
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_2:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  214   memcpy(MRFI_P_SRC_ADDR(&fInfoPtr->mrfiPkt), sMyAddr, NET_ADDR_SIZE);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x4
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 18)
        MOV     DPTR,#sMyAddr
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R6
        ADD     A,#0xa
        MOV     R2,A
        LCALL   ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_3:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 16)
//  215 
//  216   return fInfoPtr;
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??nwk_buildFrame_1:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock2
//  217 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiCond3 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 18)
        CFI Block cfiCond4 Using cfiCommon0
        CFI (cfiCond4) NoFunction
        CFI (cfiCond4) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond4) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond4) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond4) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond4) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond4) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond4) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond4) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond4) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond4) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond4) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond4) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond4) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond4) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond4) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond4) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond4) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond4) CFA_SP SP+0
        CFI (cfiCond4) CFA_XSP16 add(XSP16, 18)
        CFI Block cfiPicker5 Using cfiCommon1
        CFI (cfiPicker5) NoFunction
        CFI (cfiPicker5) Picker
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        CFI EndBlock cfiCond3
        CFI EndBlock cfiCond4
        CFI EndBlock cfiPicker5
        REQUIRE ??Subroutine3_0
        ; // Fall through to label ??Subroutine3_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine3_0:
        CFI Block cfiCond6 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        CFI Block cfiCond7 Using cfiCommon0
        CFI (cfiCond7) NoFunction
        CFI (cfiCond7) Conditional ??CrossCallReturnLabel_5
        CFI (cfiCond7) R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI (cfiCond7) VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI (cfiCond7) V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI (cfiCond7) V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI (cfiCond7) V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI (cfiCond7) V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI (cfiCond7) V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond7) V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond7) V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond7) V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond7) V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond7) V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond7) V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond7) V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond7) V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond7) V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond7) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond7) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond7) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond7) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond7) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond7) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond7) CFA_SP SP+0
        CFI (cfiCond7) CFA_XSP16 add(XSP16, 24)
        CFI Block cfiCond8 Using cfiCommon0
        CFI (cfiCond8) NoFunction
        CFI (cfiCond8) Conditional ??CrossCallReturnLabel_2
        CFI (cfiCond8) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond8) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond8) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond8) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond8) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond8) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond8) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond8) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond8) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond8) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond8) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond8) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond8) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond8) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond8) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond8) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond8) CFA_SP SP+0
        CFI (cfiCond8) CFA_XSP16 add(XSP16, 18)
        CFI Block cfiCond9 Using cfiCommon0
        CFI (cfiCond9) NoFunction
        CFI (cfiCond9) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond9) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond9) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond9) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond9) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond9) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond9) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond9) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond9) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond9) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond9) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond9) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond9) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond9) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond9) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond9) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond9) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond9) CFA_SP SP+0
        CFI (cfiCond9) CFA_XSP16 add(XSP16, 18)
        CFI Block cfiPicker10 Using cfiCommon1
        CFI (cfiPicker10) NoFunction
        CFI (cfiPicker10) Picker
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        RET
        CFI EndBlock cfiCond6
        CFI EndBlock cfiCond7
        CFI EndBlock cfiCond8
        CFI EndBlock cfiCond9
        CFI EndBlock cfiPicker10
//  218 
//  219 #if defined(APP_AUTO_ACK)
//  220 /******************************************************************************
//  221  * @fn          nwk_buildAckReqFrame
//  222  *
//  223  * @brief       Builds an output frame for the port and message enclosed.
//  224  *              This routine prepends the frame header and populates the
//  225  *              frame in the output queue. The frame is set to request that
//  226  *              an ack frame be sent by the peer.
//  227  *
//  228  * input parameters
//  229  * @param   port    - port from application
//  230  * @param   msg     - pointer to message from app to be sent
//  231  * @param   len     - length of enclosed message
//  232  * @param   hops    - number of hops allowed. this is less than MAX_HOPS
//  233  *                    whenever the frame is being sent to the AP. this is to
//  234  *                    help mitigate the (short) broadcast storms
//  235  * @param   tid     - Transaction ID to insert in NWK header used to match
//  236  *                    the ack reply.
//  237  *
//  238  * output parameters
//  239  *
//  240  * @return   pointer to frameInfo_t structure created. NULL if there is
//  241  *           no room in output queue.
//  242  */
//  243 frameInfo_t *nwk_buildAckReqFrame(uint8_t port, uint8_t *msg, uint8_t len, uint8_t hops, volatile uint8_t *tid)
//  244 {
//  245   frameInfo_t *fInfoPtr;
//  246 
//  247   /* Build a normal frame first. */
//  248   if (!(fInfoPtr=nwk_buildFrame(port, msg, len, hops)))
//  249   {
//  250     return (frameInfo_t *)NULL;
//  251   }
//  252 
//  253   /* save TID  */
//  254   *tid = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_TRACTID_OS);
//  255   /* Set REQ_ACK bit */
//  256   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ACK_REQ, F_ACK_REQ_TYPE);
//  257 
//  258   return fInfoPtr;
//  259 }
//  260 #endif  /* APP_AUTO_ACK */
//  261 
//  262 #if SIZE_INFRAME_Q > 0
//  263 /******************************************************************************
//  264  * @fn          MRFI_RxCompleteISR
//  265  *
//  266  * @brief       Here on Rx interrupt from radio. Process received frame from the
//  267  *              radio Rx FIFO.
//  268  *
//  269  * input parameters
//  270  *
//  271  * output parameters
//  272  *
//  273  * @return      void
//  274  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  275 void MRFI_RxCompleteISR()
MRFI_RxCompleteISR:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function MRFI_RxCompleteISR
        CODE
//  276 {
        FUNCALL MRFI_RxCompleteISR, nwk_QfindSlot
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL MRFI_RxCompleteISR, MRFI_Receive
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  277   frameInfo_t  *fInfoPtr;
//  278 
//  279   /* room for more? */
//  280   if (fInfoPtr=nwk_QfindSlot(INQ))
        ; Setup parameters for call to function nwk_QfindSlot
        MOV     R1,#0x1
        LCALL   ??nwk_QfindSlot?relay
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     A,R2
        ORL     A,R3
        JZ      ??MRFI_RxCompleteISR_0
//  281   {
//  282     MRFI_Receive(&fInfoPtr->mrfiPkt);
        MOV     A,R0
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R7,A
        ; Setup parameters for call to function MRFI_Receive
        INC     R2
        INC     R2
        MOV     R3,A
        LCALL   ??MRFI_Receive?relay
//  283     g_rcvPkt = 1;
        MOV     DPTR,#g_rcvPkt
        MOV     A,#0x1
        MOVX    @DPTR,A
//  284     //dispatchFrame(fInfoPtr);
//  285    GetDeviceInfo(fInfoPtr);
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     DPTR,#g_pRcvPkt
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  286   }
//  287 
//  288   return;
??MRFI_RxCompleteISR_0:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock11
//  289 }
//  290 
//  291 
//  292 /*******************************************************************************
//  293 
//  294 *******************************************************************************/
//  295 static void GetDeviceInfo(frameInfo_t *fiPtr)
//  296 {
//  297 	g_pRcvPkt = &fiPtr->mrfiPkt;
//  298 	return;
//  299 }
//  300 /******************************************************************************
//  301  * @fn          nwk_retrieveFrame
//  302  *
//  303  * @brief       Retrieve frame from Rx frame queue. Invoked by application-level
//  304  *              code either app through SMPL_Receive() or IOCTL through raw Rx. This
//  305  *              should run in a user thread, not an ISR thread.
//  306  *
//  307  * input parameters
//  308  * @param    port    - port on which to get a frame
//  309  *
//  310  * output parameters
//  311  * @param    msg     - pointer to where app payload should be copied. Buffer
//  312  *                     allocated should be == MAX_APP_PAYLOAD.
//  313  *
//  314  * @param    len      - pointer to where payload length should be stored. Caller
//  315  *                      can check for non-zero when polling the port. initialized
//  316  *                      to 0 even if no frame is retrieved.
//  317  * @param    srcAddr  - if non-NULL, a pointer to where to copy the source address
//  318  *                      of the retrieved message.
//  319  * @param    hopCount - if non-NULL, a pointer to where to copy the hop count
//  320                         of the retrieved message.
//  321  *
//  322  * @return    SMPL_SUCCESS
//  323  *            SMPL_NO_FRAME  - no frame found for specified destination
//  324  *            SMPL_BAD_PARAM - no valid connection info for the Link ID
//  325  *
//  326  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  327 smplStatus_t nwk_retrieveFrame(rcvContext_t *rcv, uint8_t *msg, uint8_t *len, addr_t *srcAddr, uint8_t *hopCount)
nwk_retrieveFrame:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function nwk_retrieveFrame
        CODE
//  328 {
        FUNCALL nwk_retrieveFrame, nwk_QfindOldest
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_retrieveFrame, nwk_getConnInfo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_retrieveFrame, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_retrieveFrame, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_retrieveFrame, nwk_QadjustOrder
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x16
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 22)
        ; Saved register size: 22
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 10,R4
        MOV     ?V0 + 11,R5
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     A,#0x18
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
//  329   frameInfo_t *fPtr;
//  330   uint8_t      done;
//  331 
//  332   do {
//  333     /* look for a frame on requested port. */
//  334     *len = 0;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        CLR     A
        MOVX    @DPTR,A
//  335     done = 1;
//  336 
//  337     fPtr = nwk_QfindOldest(INQ, rcv, USAGE_NORMAL);
        ; Setup parameters for call to function nwk_QfindOldest
        MOV     R4,#0x1
        MOV     R1,#0x1
        LCALL   ??nwk_QfindOldest?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
//  338     if (fPtr)
        MOV     A,R2
        ORL     A,?V0 + 1
        JNZ     $+5
        LJMP    ??nwk_retrieveFrame_0 & 0xFFFF
//  339     {
//  340       connInfo_t  *pCInfo = 0;
        MOV     ?V0 + 2,#0x0
        MOV     ?V0 + 3,#0x0
//  341 
//  342       if (RCV_APP_LID == rcv->type)
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??nwk_retrieveFrame_1
//  343       {
//  344         pCInfo = nwk_getConnInfo(rcv->t.lid);
        ; Setup parameters for call to function nwk_getConnInfo
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??nwk_getConnInfo?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
//  345         if (!pCInfo)
        MOV     A,R2
        ORL     A,?V0 + 3
        JNZ     ??nwk_retrieveFrame_1
//  346         {
//  347           return SMPL_BAD_PARAM;
        MOV     R1,#0x2
        LJMP    ??nwk_retrieveFrame_2 & 0xFFFF
//  348         }
//  349 #if defined(SMPL_SECURE)
//  350         /* decrypt here...we have all the context we need. */
//  351         {
//  352           uint32_t  ctr  = pCInfo->connRxCTR;
//  353           uint32_t *pctr = &ctr;
//  354           uint8_t   len  = MRFI_GET_PAYLOAD_LEN(&fPtr->mrfiPkt) - F_SEC_CTR_OS;
//  355 
//  356           if (pCInfo->thisLinkID == SMPL_LINKID_USER_UUD)
//  357           {
//  358             pctr = NULL;
//  359           }
//  360 #if defined(RX_POLLS)
//  361           else if ((F_APP_PAYLOAD_OS - F_SEC_CTR_OS) == len)
//  362           {
//  363             /* This was an empty poll reply frame generated by the AP.
//  364              * It uses the single-byte CTR value like network applications.
//  365              * We do not want to use the application layer counter in this case.
//  366              */
//  367             pctr = NULL;
//  368           }
//  369 #endif
//  370           if (nwk_getSecureFrame(&fPtr->mrfiPkt, len, pctr))
//  371           {
//  372             if (pctr)
//  373             {
//  374               /* Update connection's counter. */
//  375               pCInfo->connRxCTR = ctr;
//  376             }
//  377           }
//  378           else
//  379           {
//  380             /* Frame bogus. Remove from queue and check for another frame. */
//  381             nwk_QadjustOrder(INQ, fPtr->orderStamp);
//  382             fPtr->fi_usage = FI_AVAILABLE;
//  383             done = 0;
//  384             continue;
//  385           }
//  386         }
//  387 #endif  /* SMPL_SECURE */
//  388       }
//  389 
//  390       /* it's on the requested port. */
//  391       *len = MRFI_GET_PAYLOAD_LEN(&fPtr->mrfiPkt) - F_APP_PAYLOAD_OS;
??nwk_retrieveFrame_1:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#-0xe
        MOV     R0,A
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    @DPTR,A
//  392       memcpy(msg, MRFI_P_PAYLOAD(&fPtr->mrfiPkt)+F_APP_PAYLOAD_OS, *len);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     A,?V0 + 0
        ADD     A,#0x11
        MOV     R4,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,?V0 + 10
        MOV     R3,?V0 + 11
        LCALL   ??Subroutine3_0 & 0xFFFF
??CrossCallReturnLabel_4:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
//  393       /* save signal info */
//  394       if (pCInfo)
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JZ      ??nwk_retrieveFrame_3
//  395       {
//  396         /* Save Rx metrics... */
//  397         pCInfo->sigInfo.rssi = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_RSSI_OFS];
        MOV     A,?V0 + 0
        ADD     A,#0x33
        LCALL   ?Subroutine1 & 0xFFFF
??CrossCallReturnLabel_0:
        MOVX    @DPTR,A
//  398         pCInfo->sigInfo.lqi  = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS];
        MOV     A,?V0 + 0
        ADD     A,#0x34
        LCALL   ?Subroutine1 & 0xFFFF
//  399       }
??CrossCallReturnLabel_1:
        INC     DPTR
        MOVX    @DPTR,A
//  400       if (srcAddr)
??nwk_retrieveFrame_3:
        MOV     A,?V0 + 8
        ORL     A,?V0 + 9
        JZ      ??nwk_retrieveFrame_4
//  401       {
//  402         /* copy source address if requested */
//  403         memcpy(srcAddr, MRFI_P_SRC_ADDR(&fPtr->mrfiPkt), NET_ADDR_SIZE);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x4
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     A,?V0 + 0
        ADD     A,#0xa
        MOV     R4,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        LCALL   ??Subroutine3_0 & 0xFFFF
//  404       }
??CrossCallReturnLabel_5:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 22)
//  405       if (hopCount)
??nwk_retrieveFrame_4:
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JZ      ??nwk_retrieveFrame_5
//  406       {
//  407         /* copy hop count if requested */
//  408         *hopCount = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fPtr->mrfiPkt), F_HOP_COUNT);
        MOV     A,?V0 + 0
        ADD     A,#0xf
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ANL     A,#0x7
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    @DPTR,A
//  409       }
//  410       /* input frame no longer needed. free it. */
//  411       nwk_QadjustOrder(INQ, fPtr->orderStamp);
??nwk_retrieveFrame_5:
        ; Setup parameters for call to function nwk_QadjustOrder
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R1,#0x1
        LCALL   ??nwk_QadjustOrder?relay
//  412 
//  413       fPtr->fi_usage = FI_AVAILABLE;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        CLR     A
        MOVX    @DPTR,A
//  414       return SMPL_SUCCESS;
        MOV     R1,A
        SJMP    ??nwk_retrieveFrame_2
//  415     }
//  416   } while (!done);
//  417 
//  418   return SMPL_NO_FRAME;
??nwk_retrieveFrame_0:
        MOV     R1,#0x4
??nwk_retrieveFrame_2:
        MOV     R7,#0xe
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock12
//  419 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiCond13 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 22)
        CFI Block cfiCond14 Using cfiCommon0
        CFI (cfiCond14) NoFunction
        CFI (cfiCond14) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond14) R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI (cfiCond14) VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI (cfiCond14) V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI (cfiCond14) V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI (cfiCond14) V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI (cfiCond14) V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI (cfiCond14) V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond14) V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond14) V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond14) V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond14) V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond14) V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond14) V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond14) V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond14) V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond14) V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond14) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond14) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond14) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond14) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond14) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond14) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond14) CFA_SP SP+0
        CFI (cfiCond14) CFA_XSP16 add(XSP16, 22)
        CFI Block cfiPicker15 Using cfiCommon1
        CFI (cfiPicker15) NoFunction
        CFI (cfiPicker15) Picker
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        RET
        CFI EndBlock cfiCond13
        CFI EndBlock cfiCond14
        CFI EndBlock cfiPicker15
//  420 
//  421 /******************************************************************************
//  422  * @fn          dispatchFrame
//  423  *
//  424  * @brief       Received frame looks OK so far. Dispatch to either NWK app by
//  425  *              invoking the handler or the user's app by simply leaving the
//  426  *              frame in the queue and letting the app poll the port.
//  427  *
//  428  * input parameters
//  429  * @param   fiPtr    - frameInfo_t pointer to received frame
//  430  *
//  431  * output parameters
//  432  *
//  433  * @return   void
//  434  */
//  435 static void dispatchFrame(frameInfo_t *fiPtr)
//  436 {
//  437   uint8_t     port       = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_PORT_OS);
//  438   uint8_t     nwkAppSize = sizeof(func)/sizeof(func[0]);
//  439   fhStatus_t  rc;
//  440   linkID_t    lid;
//  441 #if defined(ACCESS_POINT)
//  442   uint8_t loc;
//  443 #endif
//  444 #if !defined(END_DEVICE)
//  445   uint8_t isForMe;
//  446 #endif
//  447 
//  448   /* be sure it's not an echo... */
//  449   if (!memcmp(MRFI_P_SRC_ADDR(&fiPtr->mrfiPkt), sMyAddr, NET_ADDR_SIZE))
//  450   {
//  451     fiPtr->fi_usage = FI_AVAILABLE;
//  452     return;
//  453   }
//  454 
//  455   /* Make sure encyrption bit conforms to our security support context. */
//  456 #if defined(SMPL_SECURE)
//  457   if (!(GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_ENCRYPT_OS)))
//  458   {
//  459     /* Encyrption bit is not on when when it should be */
//  460     fiPtr->fi_usage = FI_AVAILABLE;
//  461     return;
//  462   }
//  463 #else
//  464   if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_ENCRYPT_OS))
//  465   {
//  466     /* Encyrption bit is on when when it should not be */
//  467     fiPtr->fi_usage = FI_AVAILABLE;
//  468     return;
//  469   }
//  470 #endif  /* SMPL_SECURE */
//  471 
//  472   /* If it's a network application port dispatch to service routine. Dispose
//  473    * of frame depending on return code.
//  474    */
//  475   if (port && (port <= nwkAppSize))
//  476   {
//  477 #if defined(SMPL_SECURE)
//  478     /* Non-connection-based frame. We can decode here if it was encrypted */
//  479     if (!nwk_getSecureFrame(&fiPtr->mrfiPkt, MRFI_GET_PAYLOAD_LEN(&fiPtr->mrfiPkt) - F_SEC_CTR_OS, 0))
//  480     {
//  481       fiPtr->fi_usage = FI_AVAILABLE;
//  482       return;
//  483     }
//  484 #endif
//  485     rc = func[port-1](&fiPtr->mrfiPkt);
//  486     if (FHS_KEEP == rc)
//  487     {
//  488       fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
//  489     }
//  490 #if !defined(END_DEVICE)
//  491     else if (FHS_REPLAY == rc)
//  492     {
//  493       /* an AP or an RE could be relaying a NWK application frame... */
//  494       nwk_replayFrame(fiPtr);
//  495     }
//  496 #endif
//  497     else  /* rc == FHS_RELEASE (default...) */
//  498     {
//  499       fiPtr->fi_usage = FI_AVAILABLE;
//  500     }
//  501     return;
//  502   }
//  503   /* sanity check */
//  504   else if ((port != SMPL_PORT_USER_BCAST) && ((port < PORT_BASE_NUMBER) || (port > SMPL_PORT_STATIC_MAX)))
//  505   {
//  506     /* bogus port. drop frame */
//  507     fiPtr->fi_usage = FI_AVAILABLE;
//  508     return;
//  509   }
//  510 
//  511   /* At this point we know the target is a user app. If this is an end device
//  512    * and we got this far save the frame and we're done. If we're an AP there
//  513    * are 3 cases: it's for us, it's for s store-and-forward client, or we need
//  514    * to replay the frame. If we're and RE and the frame didn't come from an RE
//  515    * and it's not for us, replay the frame.
//  516    */
//  517 
//  518 #if defined(END_DEVICE)
//  519   /* If we're s polling end device we only accept application frames from
//  520    * the AP. This prevents duplicate reception if we happen to be on when
//  521    * a linked peer sends.
//  522    */
//  523 #if defined(RX_POLLS)
//  524   if (F_TX_DEVICE_ED != GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_TX_DEVICE))
//  525   {
//  526     if (nwk_isConnectionValid(&fiPtr->mrfiPkt, &lid))
//  527     {
//  528       fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
//  529     }
//  530     else
//  531     {
//  532       fiPtr->fi_usage = FI_AVAILABLE;
//  533     }
//  534   }
//  535   else
//  536   {
//  537     fiPtr->fi_usage = FI_AVAILABLE;
//  538   }
//  539 #else
//  540   /* it's destined for a user app. */
//  541   if (nwk_isConnectionValid(&fiPtr->mrfiPkt, &lid))
//  542   {
//  543     fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
//  544     if (spCallback && spCallback(lid))
//  545     {
//  546       fiPtr->fi_usage = FI_AVAILABLE;
//  547       return;
//  548     }
//  549   }
//  550   else
//  551   {
//  552     fiPtr->fi_usage = FI_AVAILABLE;
//  553   }
//  554 #endif  /* RX_POLLS */
//  555 
//  556 #else   /* END_DEVICE */
//  557 
//  558   /* We have an issue if the frame is broadcast to the UUD port. The AP (or RE) must
//  559    * handle this frame as if it were the target in case there is an application
//  560    * running that is listening on that port. But if it's a broadcast it must also be
//  561    * replayed. It isn't enough just to test for the UUD port because it could be a
//  562    * directed frame to another device. We must check explicitly for broadcast
//  563    * destination address.
//  564    */
//  565   isForMe = !memcmp(sMyAddr, MRFI_P_DST_ADDR(&fiPtr->mrfiPkt), NET_ADDR_SIZE);
//  566   if (isForMe || ((port == SMPL_PORT_USER_BCAST) && !memcmp(nwk_getBCastAddress(), MRFI_P_DST_ADDR(&fiPtr->mrfiPkt), NET_ADDR_SIZE)))
//  567   {
//  568     /* The folllowing test will succeed for the UUD port regardless of the
//  569      * source address.
//  570      */
//  571     if (nwk_isConnectionValid(&fiPtr->mrfiPkt, &lid))
//  572     {
//  573       /* If this is for the UUD port and we are here then the device is either
//  574        * an AP or an RE. In either case it must replay the UUD port frame if the
//  575        * frame is not "for me". But it also must handle it since it could have a
//  576        * UUD-listening application. Do the reply first and let the subsequent code
//  577        * correctly set the frame usage state. Note that the routine return can be
//  578        * from this code block. If not it will drop through to the bottom without
//  579        * doing a replay.
//  580        */
//  581       /* Do I need to replay it? */
//  582       if (!isForMe)
//  583       {
//  584         /* must be a broadcast for the UUD port */
//  585         nwk_replayFrame(fiPtr);
//  586       }
//  587       /* OK. Now I handle it... */
//  588       fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
//  589       if (spCallback && spCallback(lid))
//  590       {
//  591         fiPtr->fi_usage = FI_AVAILABLE;
//  592         return;
//  593       }
//  594     }
//  595     else
//  596     {
//  597       fiPtr->fi_usage = FI_AVAILABLE;
//  598     }
//  599   }
//  600 #if defined( ACCESS_POINT )
//  601   /* Check to see if we need to save this for a S and F client. Otherwise,
//  602    * if it's not for us, get rid of it.
//  603    */
//  604   else if (nwk_isSandFClient(MRFI_P_DST_ADDR(&fiPtr->mrfiPkt), &loc))
//  605   {
//  606     /* Don't bother if it is a duplicate frame or if it's a forwarded frame
//  607      * echoed back from an RE.
//  608      */
//  609     if (!isDupSandFFrame(&fiPtr->mrfiPkt) &&
//  610         !(GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_FWD_FRAME))
//  611        )
//  612     {
//  613 #if defined(APP_AUTO_ACK)
//  614       /* Make sure ack request bit is off. Sender will have gone away. */
//  615       PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_ACK_REQ, 0);
//  616 #endif
//  617       fiPtr->fi_usage = FI_INUSE_UNTIL_FWD;
//  618     }
//  619     else
//  620     {
//  621       fiPtr->fi_usage = FI_AVAILABLE;
//  622     }
//  623   }
//  624   else if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_TX_DEVICE) == F_TX_DEVICE_AP)
//  625   {
//  626     /* I'm an AP and this frame came from an AP. Don't replay. */
//  627     fiPtr->fi_usage = FI_AVAILABLE;
//  628   }
//  629 #elif defined( RANGE_EXTENDER )
//  630   else if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_TX_DEVICE) == F_TX_DEVICE_RE)
//  631   {
//  632     /* I'm an RE and this frame came from an RE. Don't replay. */
//  633     fiPtr->fi_usage = FI_AVAILABLE;
//  634   }
//  635 #endif
//  636   else
//  637   {
//  638     /* It's not for me and I'm either an AP or I'm an RE and the frame
//  639      * didn't come from an RE. Replay the frame.
//  640      */
//  641     nwk_replayFrame(fiPtr);
//  642   }
//  643 #endif  /* !END_DEVICE */
//  644   return;
//  645 }
//  646 #endif   /* SIZE_INFRAME_Q > 0 */
//  647 
//  648 /******************************************************************************
//  649  * @fn          nwk_sendFrame
//  650  *
//  651  * @brief       Send a frame by copying it to the radio Tx FIFO.
//  652  *
//  653  * input parameters
//  654  * @param   pFrameInfo   - pointer to frame to be sent
//  655  * @param   txOption     - do CCA or force frame out.
//  656  *
//  657  * output parameters
//  658  *
//  659  * @return    SMPL_SUCCESS
//  660  *            SMPL_TX_CCA_FAIL Tx failed because of CCA failure.
//  661  *                             Tx FIFO flushed in this case.
//  662  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  663 smplStatus_t nwk_sendFrame(frameInfo_t *pFrameInfo, uint8_t txOption)
nwk_sendFrame:
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function nwk_sendFrame
        CODE
//  664 {
        FUNCALL nwk_sendFrame, MRFI_Transmit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  665   smplStatus_t rc;
//  666 
//  667   /* set the type of device sending the frame in the header */
//  668   // cbyi delete
//  669   //PUT_INTO_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt), F_TX_DEVICE, sMyTxType);
//  670 
//  671   if (MRFI_TX_RESULT_SUCCESS == MRFI_Transmit(&pFrameInfo->mrfiPkt, txOption))
        ; Setup parameters for call to function MRFI_Transmit
        MOV     A,R6
        ADD     A,#0x2
        INC     R2
        INC     R2
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??MRFI_Transmit?relay
        MOV     A,R1
        JNZ     ??nwk_sendFrame_0
//  672   {
//  673     rc = SMPL_SUCCESS;
        MOV     R1,#0x0
        SJMP    ??nwk_sendFrame_1
//  674   }
//  675   else
//  676   {
//  677     /* Tx failed -- probably CCA. free up frame buffer. We do not have NWK
//  678      * level retries. Let application do it.
//  679      */
//  680     rc = SMPL_TX_CCA_FAIL;
??nwk_sendFrame_0:
        MOV     R1,#0x9
//  681   }
//  682 
//  683   /* TX is done. free up the frame buffer */
//  684   pFrameInfo->fi_usage = FI_AVAILABLE;
??nwk_sendFrame_1:
        MOV     DPL,R6
        MOV     DPH,R7
        CLR     A
        MOVX    @DPTR,A
//  685 
//  686   return rc;
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock16
//  687 }
//  688 
//  689 
//  690 /******************************************************************************
//  691  * @fn          nwk_getMyRxType
//  692  *
//  693  * @brief       Get my Rx type. Used to help populate the hops count in the
//  694  *              frame header to try and limit the broadcast storm. Info is
//  695  *              exchanged when linking.
//  696  *
//  697  * input parameters
//  698  *
//  699  * output parameters
//  700  *
//  701  * @return      The address LSB.
//  702  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  703 uint8_t nwk_getMyRxType(void)
nwk_getMyRxType:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function nwk_getMyRxType
        CODE
//  704 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  705   return sMyRxType;
        MOV     DPTR,#sMyRxType
        MOVX    A,@DPTR
        MOV     R1,A
        LJMP    ?Subroutine0 & 0xFFFF
        CFI EndBlock cfiBlock17
//  706 }

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_frameInit?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_frameInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_buildFrame?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_buildFrame

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??MRFI_RxCompleteISR?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    MRFI_RxCompleteISR

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_retrieveFrame?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_retrieveFrame

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_sendFrame?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_sendFrame

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_getMyRxType?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_getMyRxType

        END
//  707 
//  708 #if defined(APP_AUTO_ACK)
//  709 /******************************************************************************
//  710  * @fn          nwk_sendAckReply
//  711  *
//  712  * @brief       Send an acknowledgement reply frame.
//  713  *
//  714  * input parameters
//  715  * @param   frame   - pointer to frame with ack request.
//  716  * @param   port    - port on whcih reply expected.
//  717  *
//  718  * output parameters
//  719  *
//  720  * @return      void
//  721  */
//  722 void nwk_sendAckReply(mrfiPacket_t *frame, uint8_t port)
//  723 {
//  724   mrfiPacket_t dFrame;
//  725   uint8_t      tid = GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_TRACTID_OS);
//  726 
//  727   /* set the type of device sending the frame in the header */
//  728   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_TX_DEVICE, sMyTxType);
//  729 
//  730   /* set the listen type of device sending the frame in the header. */
//  731   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_RX_TYPE, sMyRxType);
//  732 
//  733   /* destination address from received frame */
//  734   memcpy(MRFI_P_DST_ADDR(&dFrame), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
//  735 
//  736   /* source address */
//  737   memcpy(MRFI_P_SRC_ADDR(&dFrame), sMyAddr, NET_ADDR_SIZE);
//  738 
//  739   /* port is the source the Tx port from the connection object */
//  740   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_PORT_OS, port);
//  741 
//  742   /* frame length... */
//  743   MRFI_SET_PAYLOAD_LEN(&dFrame,F_APP_PAYLOAD_OS);
//  744 
//  745   /* transaction ID taken from source frame */
//  746   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_TRACTID_OS, tid);
//  747 
//  748   /* hop count... */
//  749   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_HOP_COUNT, MAX_HOPS);
//  750 
//  751   /* set ACK field */
//  752   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ACK_RPLY, F_ACK_RPLY_TYPE);
//  753   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ACK_REQ, 0);
//  754 
//  755    /* This is not a forwarded frame */
//  756   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_FWD_FRAME, 0);
//  757 
//  758   /* Encryption state */
//  759 #if !defined(SMPL_SECURE)
//  760   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ENCRYPT_OS, 0);
//  761 #else
//  762   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ENCRYPT_OS, F_ENCRYPT_OS_MSK);
//  763   nwk_setSecureFrame(&dFrame, 0, 0);
//  764 #endif
//  765 
//  766   MRFI_Transmit(&dFrame, MRFI_TX_TYPE_FORCED);
//  767 
//  768   return;
//  769 }
//  770 #endif /* APP_AUTO_ACK */
//  771 
//  772 #if !defined(END_DEVICE)
//  773 /******************************************************************************
//  774  * @fn          nwk_replayFrame
//  775  *
//  776  * @brief       Deal with hop count on a Range Extender or Access Point replay.
//  777  *              Queue entry usage always left as available when done.
//  778  *
//  779  * input parameters
//  780  * @param   pFrameInfo   - pointer to frame information structure
//  781  *
//  782  * output parameters
//  783  *
//  784  * @return      void
//  785  */
//  786 void nwk_replayFrame(frameInfo_t *pFrameInfo)
//  787 {
//  788   uint8_t  hops = GET_FROM_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt), F_HOP_COUNT);
//  789 
//  790   /* if hops are zero, drop frame. othewise send it. */
//  791   if (hops--)
//  792   {
//  793     PUT_INTO_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt),F_HOP_COUNT,hops);
//  794     /* Don't care if the Tx fails because of TO. Either someone else
//  795      * will retransmit or the application itself will recover.
//  796      */
//  797 #if defined(SMPL_SECURE)
//  798     /* If the frame was targeted to a NWK port it was decrypted on spec in
//  799      * the 'dispatchFrame()' method. It must be re-encypted in this case.
//  800      */
//  801     if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt), F_PORT_OS) <= SMPL_PORT_NWK_BCAST)
//  802     {
//  803       nwk_setSecureFrame(&pFrameInfo->mrfiPkt, MRFI_GET_PAYLOAD_LEN(&pFrameInfo->mrfiPkt)-F_APP_PAYLOAD_OS, 0);
//  804     }
//  805 #endif
//  806     MRFI_DelayMs(1);
//  807     nwk_sendFrame(pFrameInfo, MRFI_TX_TYPE_CCA);
//  808   }
//  809   else
//  810   {
//  811     pFrameInfo->fi_usage = FI_AVAILABLE;
//  812   }
//  813   return;
//  814 }
//  815 
//  816 #if defined(ACCESS_POINT)
//  817 /******************************************************************************
//  818  * @fn          nwk_getSandFFrame
//  819  *
//  820  * @brief       Get any frame waiting for the client on the port supplied in
//  821  *              the frame payload.
//  822  *              TODO: support returning NWK application frames always. the
//  823  *              port requested in the call should be an user application port.
//  824  *              NWK app ports will never be in the called frame.
//  825  *              TODO: deal with broadcast NWK frames from AP.
//  826  *
//  827  * input parameters
//  828  * @param   frame   - pointer to frame in question
//  829  * @param   osPort  - offset of where requested port is in the application payload.
//  830  *
//  831  * output parameters
//  832  * @param   qType   - queue type in which frame found. Needed to know which queue
//  833  *                    requires order-adjusting when frame removed from queue. Defined
//  834  *                    only if a frame is found.
//  835  *
//  836  * @return      pointer to frame if there is one, otherwise 0.
//  837  */
//  838 frameInfo_t *nwk_getSandFFrame(mrfiPacket_t *frame, uint8_t osPort, uint8_t *qType)
//  839 {
//  840   uint8_t        i, port = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+osPort);
//  841   frameInfo_t *fiPtr;
//  842   rcvContext_t rcv;
//  843 
//  844   rcv.type  = RCV_RAW_POLL_FRAME;
//  845   rcv.t.pkt = frame;
//  846   /* check the input queue for messages sent by others. */
//  847   if (fiPtr=nwk_QfindOldest(INQ, &rcv, USAGE_FWD))
//  848   {
//  849     *qType = INQ;
//  850     return fiPtr;
//  851   }
//  852 
//  853   /* Check the output queue to see if we ourselves need to send anything.
//  854    * TODO: use the cast-out scheme for output queue so this routine finds
//  855    * the oldest in either queue.
//  856    */
//  857   fiPtr = nwk_getQ(OUTQ);
//  858   for (i=0; i<SIZE_OUTFRAME_Q; ++i, fiPtr++)
//  859   {
//  860     if (FI_INUSE_UNTIL_FWD == fiPtr->fi_usage)
//  861     {
//  862       if (!memcmp(MRFI_P_DST_ADDR(&fiPtr->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE))
//  863       {
//  864         if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_PORT_OS) == port)
//  865         {
//  866           *qType = OUTQ;
//  867           return fiPtr;
//  868         }
//  869       }
//  870     }
//  871   }
//  872   return 0;
//  873 }
//  874 
//  875 /******************************************************************************
//  876  * @fn          nwk_SendEmptyPollRspFrame
//  877  *
//  878  * @brief       There are no frames waiting for the requester on the specified
//  879  *              port. Send a frame back to that port with no payload.
//  880  *
//  881  * input parameters
//  882  * @param   frame   - pointer to frame in question
//  883  *
//  884  * output parameters
//  885  *
//  886  * @return      void
//  887  */
//  888 void nwk_SendEmptyPollRspFrame(mrfiPacket_t *frame)
//  889 {
//  890   mrfiPacket_t dFrame;
//  891   uint8_t      port = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+M_POLL_PORT_OS);
//  892 
//  893   /* set the type of device sending the frame in the header. we know it's an AP */
//  894   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_TX_DEVICE, F_TX_DEVICE_AP);
//  895   /* set the listen type of device sending the frame in the header. we know it's
//  896    * an AP is is probably always on...but use the static variable anyway.
//  897    */
//  898   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_RX_TYPE, sMyRxType);
//  899   /* destination address from received frame (polling device) */
//  900   memcpy(MRFI_P_DST_ADDR(&dFrame), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
//  901   /* source address */
//  902   memcpy(MRFI_P_SRC_ADDR(&dFrame), MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+M_POLL_ADDR_OS, NET_ADDR_SIZE);
//  903   /* port is the port requested */
//  904   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_PORT_OS, port);
//  905   /* frame length... */
//  906   MRFI_SET_PAYLOAD_LEN(&dFrame,F_APP_PAYLOAD_OS);
//  907   /* transaction ID... */
//  908   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_TRACTID_OS, sTRACTID);
//  909   sTRACTID++;
//  910   /* hop count... */
//  911   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_HOP_COUNT, MAX_HOPS_FROM_AP);
//  912 
//  913   /* Ack fields */
//  914   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ACK_RPLY, 0);
//  915   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ACK_REQ, 0);
//  916 
//  917   /* This is logically a forwarded frame */
//  918   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_FWD_FRAME, F_FRAME_FWD_TYPE);
//  919 
//  920   /* Encryption state */
//  921 #if !defined(SMPL_SECURE)
//  922   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ENCRYPT_OS, 0);
//  923 #else
//  924   PUT_INTO_FRAME(MRFI_P_PAYLOAD(&dFrame), F_ENCRYPT_OS, F_ENCRYPT_OS_MSK);
//  925   nwk_setSecureFrame(&dFrame, 0, 0);
//  926 #endif
//  927 
//  928   MRFI_Transmit(&dFrame, MRFI_TX_TYPE_FORCED);
//  929 
//  930   return;
//  931 }
//  932 
//  933 /******************************************************************************
//  934  * @fn          isDupSandFFrame
//  935  *
//  936  * @brief       Have we already stored this frame on behalf of a client?
//  937  *
//  938  * input parameters
//  939  * @param   frame   - pointer to frame in question
//  940  *
//  941  * output parameters
//  942  *
//  943  * @return      Returns 1 if the frame is a duplicate, otherwise 0.
//  944  */
//  945 uint8_t  isDupSandFFrame(mrfiPacket_t *frame)
//  946 {
//  947   uint8_t      i, plLen = MRFI_GET_PAYLOAD_LEN(frame);
//  948   frameInfo_t *fiPtr;
//  949 
//  950   /* check the input queue for duplicate S&F frame. */
//  951   fiPtr = nwk_getQ(INQ);
//  952   for (i=0; i<SIZE_INFRAME_Q; ++i, fiPtr++)
//  953   {
//  954     if (FI_INUSE_UNTIL_FWD == fiPtr->fi_usage)
//  955     {
//  956       /* compare everything except the DEVICE INFO byte. */
//  957       if (MRFI_GET_PAYLOAD_LEN(&fiPtr->mrfiPkt) == plLen                                   &&
//  958           !memcmp(MRFI_P_DST_ADDR(&fiPtr->mrfiPkt), MRFI_P_DST_ADDR(frame), NET_ADDR_SIZE) &&
//  959           !memcmp(MRFI_P_SRC_ADDR(&fiPtr->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE) &&
//  960           !memcmp(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), MRFI_P_PAYLOAD(frame), 1)               &&
//  961           !memcmp(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt)+F_TRACTID_OS, MRFI_P_PAYLOAD(frame)+F_TRACTID_OS, plLen-F_TRACTID_OS)
//  962           )
//  963       {
//  964         return 1;
//  965       }
//  966     }
//  967   }
//  968   return 0;
//  969 }
//  970 #endif  /* ACCESS_POINT */
//  971 
//  972 #endif  /* !END_DEVICE */
// 
// 671 bytes in segment BANKED_CODE
//  36 bytes in segment BANK_RELAYS
//   7 bytes in segment XDATA_Z
// 
// 707 bytes of CODE  memory
//   7 bytes of XDATA memory
//
//Errors: none
//Warnings: 2
