///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.4.40412/W32 for 8051        22/Jul/2016  20:57:12 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\ /
//                          nwk_QMgmt.c                                       /
//    Command line       =  -f C:\Users\freeman\Documents\work\NBK\Nikon\Niko /
//                          n_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05 /
//                          _8051\nik_sb5000\IAR\Configuration\LinkTo\smpl_co /
//                          nfig.dat ("-DTHIS_DEVICE_ADDRESS={0x79, 0x56,     /
//                          0x34, 0x12}" -DxNWK_PLL_REFERENCE_CLOCK           /
//                          -DLINK_TO) -f C:\Users\freeman\Documents\work\NBK /
//                          \Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exa /
//                          mples\SRF05_8051\nik_sb5000\IAR\Configuration\smp /
//                          l_nwk_config.dat (-DMAX_HOPS=3                    /
//                          -DMAX_HOPS_FROM_AP=1 -DMAX_NWK_PAYLOAD=34         /
//                          -DMAX_APP_PAYLOAD=10 -DDEFAULT_LINK_TOKEN=0x01020 /
//                          304 -DDEFAULT_JOIN_TOKEN=0x05060708               /
//                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK              /
//                          -DxEXTENDED_API -DxSMPL_SECURE                    /
//                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                   /
//                          -DNUM_CONNECTIONS=2 -DSIZE_INFRAME_Q=4            /
//                          -DSIZE_OUTFRAME_Q=2 -DxFREQUENCY_HOPPING          /
//                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                /
//                          -DUART_NUMBER=UART_NUMBER_0                       /
//                          -DUART_LOCATION=UART_LOCATION_1                   /
//                          -DUART_BAUD_RATE=115200                           /
//                          -DUART_FLOW_CONTROL=UART_FLOW_CONTROL_OFF         /
//                          -DUART_PARITY_MODE=UART_PARITY_NONE               /
//                          -DUART_STOP_BITS=UART_1_STOP_BIT                  /
//                          -DBSP_TIMER_USED=1 -DEND_DEVICE)                  /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\ /
//                          nwk_QMgmt.c -D MCU_H=<ioCC2530.h> -D MRFI_CC2530  /
//                          -D ZTOOL_P1 -D MRFI_PA_LNA_ENABLED -lC            /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\ -lA                /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\ -o                 /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\Obj\ -e --debug          /
//                          --core=plain --dptr=16,1 --data_model=large       /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data --nr_virtual_regs  /
//                          16 -I C:\Users\freeman\Documents\work\NBK\Nikon\N /
//                          ikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SR /
//                          F05_8051\nik_sb5000\IAR\..\..\..\..\..\Components /
//                          \bsp\ -I C:\Users\freeman\Documents\work\NBK\Niko /
//                          n\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples /
//                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compone /
//                          nts\bsp\drivers\ -I C:\Users\freeman\Documents\wo /
//                          rk\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. /
//                          \..\Components\bsp\boards\CC2530EM\ -I            /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\mrfi\ /
//                           -I C:\Users\freeman\Documents\work\NBK\Nikon\Nik /
//                          on_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF0 /
//                          5_8051\nik_sb5000\IAR\..\..\..\..\..\Components\S /
//                          impliciTI\nwk\ -I C:\Users\freeman\Documents\work /
//                          \NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects /
//                          \Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\Appl /
//                          ications\ -I C:\Users\freeman\Documents\work\NBK\ /
//                          Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exam /
//                          ples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Com /
//                          ponents\SimpliciTI\nwk_applications\ -I           /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\OSAL\ /
//                          INCLUDE\ -I C:\Users\freeman\Documents\work\NBK\N /
//                          ikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp /
//                          les\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Comp /
//                          onents\OSAL\MCU\CCSOC\ -I                         /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\HAL\I /
//                          NCLUDE\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\HAL\TARGET\CC2530EB\ -I                     /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\SERVI /
//                          CES\SADDR\ -I C:\Users\freeman\Documents\work\NBK /
//                          \Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exa /
//                          mples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Co /
//                          mponents\SERVICES\SDATA\ -I                       /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MT\   /
//                          -I C:\Users\freeman\Documents\work\NBK\Nikon\Niko /
//                          n_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05 /
//                          _8051\nik_sb5000\IAR\..\..\..\..\..\Components\ST /
//                          ACK\AF\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\STACK\NWK\ -I C:\Users\freeman\Documents\wo /
//                          rk\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. /
//                          \..\Components\STACK\SEC\ -I                      /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\STACK /
//                          \SAPI\ -I C:\Users\freeman\Documents\work\NBK\Nik /
//                          on\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compon /
//                          ents\STACK\SYS\ -I C:\Users\freeman\Documents\wor /
//                          k\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\ /
//                          ..\Components\STACK\ZDO\ -I                       /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MAC\I /
//                          NCLUDE\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\MAC\HIGH_LEVEL\ -I                          /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MAC\L /
//                          OW_LEVEL\srf04\ -I C:\Users\freeman\Documents\wor /
//                          k\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\ /
//                          ..\Components\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\    /
//                          -Ohz --require_prototypes                         /
//    List file          =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\nwk_QMgmt.s51       /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME nwk_QMgmt

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_Z

        PUBLIC ??nwk_QInit?relay
        FUNCTION ??nwk_QInit?relay,0203H
        PUBLIC ??nwk_QadjustOrder?relay
        FUNCTION ??nwk_QadjustOrder?relay,0203H
        PUBLIC ??nwk_QfindOldest?relay
        FUNCTION ??nwk_QfindOldest?relay,0203H
        PUBLIC ??nwk_QfindSlot?relay
        FUNCTION ??nwk_QfindSlot?relay,0203H
        PUBLIC ??nwk_getQ?relay
        FUNCTION ??nwk_getQ?relay,0203H
        PUBWEAK _A_IEN0
        PUBLIC nwk_QInit
        FUNCTION nwk_QInit,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC nwk_QadjustOrder
        FUNCTION nwk_QadjustOrder,0203H
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBLIC nwk_QfindOldest
        FUNCTION nwk_QfindOldest,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 28, STACK
        PUBLIC nwk_QfindSlot
        FUNCTION nwk_QfindSlot,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 13, STACK
        PUBLIC nwk_getQ
        FUNCTION nwk_getQ,0203H
        ARGFRAME XSTACK, 0, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
memset              SYMBOL "memset"
nwk_getConnInfo     SYMBOL "nwk_getConnInfo"
memcmp              SYMBOL "memcmp"
??memcmp?relay      SYMBOL "?relay", memcmp
??memset?relay      SYMBOL "?relay", memset
??nwk_getConnInfo?relay SYMBOL "?relay", nwk_getConnInfo
nwk_QInit           SYMBOL "nwk_QInit"
??nwk_QInit?relay   SYMBOL "?relay", nwk_QInit
nwk_QadjustOrder    SYMBOL "nwk_QadjustOrder"
??nwk_QadjustOrder?relay SYMBOL "?relay", nwk_QadjustOrder
nwk_QfindOldest     SYMBOL "nwk_QfindOldest"
??nwk_QfindOldest?relay SYMBOL "?relay", nwk_QfindOldest
nwk_QfindSlot       SYMBOL "nwk_QfindSlot"
??nwk_QfindSlot?relay SYMBOL "?relay", nwk_QfindSlot
nwk_getQ            SYMBOL "nwk_getQ"
??nwk_getQ?relay    SYMBOL "?relay", nwk_getQ

        EXTERN memset
        FUNCTION memset,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nwk_getConnInfo
        FUNCTION nwk_getConnInfo,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcmp
        FUNCTION memcmp,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??memcmp?relay
        FUNCTION ??memcmp?relay,00H
        EXTERN ??memset?relay
        FUNCTION ??memset?relay,00H
        EXTERN ??nwk_getConnInfo?relay
        FUNCTION ??nwk_getConnInfo?relay,00H

// C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\nwk_QMgmt.c
//    1 /**************************************************************************************************
//    2   Filename:       nwk_QMgmt.c
//    3   Revised:        $Date: 2011-10-26 15:44:58 -0700 (Wed, 26 Oct 2011) $
//    4   Revision:       $Revision: 28059 $
//    5   Author:         $Author: jnoxon $
//    6 
//    7   Description:    This file supports the SimpliciTI input and output frame queues
//    8 
//    9   Copyright 2007-2008 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights granted under
//   12   the terms of a software license agreement between the user who downloaded the software,
//   13   his/her employer (which must be your employer) and Texas Instruments Incorporated (the
//   14   "License"). You may not use this Software unless you agree to abide by the terms of the
//   15   License. The License limits your use, and you acknowledge, that the Software may not be
//   16   modified, copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio frequency
//   18   transceiver, which is integrated into your product. Other than for the foregoing purpose,
//   19   you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
//   20   perform, display or sell this Software and/or its documentation for any purpose.
//   21 
//   22   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS”
//   23   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
//   24   WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
//   25   IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   26   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
//   27   THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
//   28   INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
//   29   DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
//   30   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   31 
//   32   Should you have any questions regarding your right to use this Software,
//   33   contact Texas Instruments Incorporated at www.TI.com.
//   34 **************************************************************************************************/
//   35 
//   36 
//   37 /******************************************************************************
//   38  * INCLUDES
//   39  */
//   40 #include <intrinsics.h>
//   41 #include <string.h>
//   42 #include "bsp.h"  

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DATA8
        DS 1
//   43 #include "mrfi.h"
//   44 #include "nwk_types.h"
//   45 #include "nwk.h"
//   46 #include "nwk_frame.h"
//   47 #include "nwk_QMgmt.h"
//   48 #include "nwk_mgmt.h"     /* need offsets for poll frames */
//   49 #ifdef DEBUG_CRITICAL_SECTIONS
//   50   #include "bsp_leds.h"
//   51 #endif
//   52 
//   53 
//   54 /******************************************************************************
//   55  * MACROS
//   56  */
//   57 
//   58 /******************************************************************************
//   59  * CONSTANTS AND DEFINES
//   60  */
//   61 
//   62 /******************************************************************************
//   63  * TYPEDEFS
//   64  */
//   65 
//   66 /******************************************************************************
//   67  * LOCAL VARIABLES
//   68  */
//   69 
//   70 #if SIZE_INFRAME_Q > 0

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   71 static frameInfo_t   sInFrameQ[SIZE_INFRAME_Q];
sInFrameQ:
        DS 204
        REQUIRE __INIT_XDATA_Z
//   72 #else
//   73 static frameInfo_t  *sInFrameQ = NULL;
//   74 #endif  /* SIZE_INFRAME_Q > 0 */
//   75 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   76 static frameInfo_t   sOutFrameQ[SIZE_OUTFRAME_Q];
sOutFrameQ:
        DS 102
        REQUIRE __INIT_XDATA_Z
//   77 
//   78 /******************************************************************************
//   79  * LOCAL FUNCTIONS
//   80  */
//   81 
//   82 /******************************************************************************
//   83  * GLOBAL VARIABLES
//   84  */
//   85 
//   86 /******************************************************************************
//   87  * GLOBAL FUNCTIONS
//   88  */
//   89 
//   90 /******************************************************************************
//   91 * @fn          nwk_QInit
//   92 * 
//   93 * @brief     Initialize the input and output frame queues to hold no packets. 
//   94 * 
//   95 * input parameters
//   96 * 
//   97 * output parameters
//   98 * 
//   99 * @return   void
//  100 */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  101 void nwk_QInit(void)
nwk_QInit:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function nwk_QInit
        CODE
//  102 {
        FUNCALL nwk_QInit, memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_QInit, memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  103 #if SIZE_INFRAME_Q > 0
//  104   memset(sInFrameQ, 0, sizeof(sInFrameQ));
        ; Setup parameters for call to function memset
        MOV     ?V0 + 0,#-0x34
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R2,#sInFrameQ & 0xff
        MOV     R3,#(sInFrameQ >> 8) & 0xff
        LCALL   ??memset?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
//  105 #endif  // SIZE_INFRAME_Q > 0
//  106   memset(sOutFrameQ, 0, sizeof(sOutFrameQ));
        ; Setup parameters for call to function memset
        MOV     ?V0 + 0,#0x66
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R2,#sOutFrameQ & 0xff
        MOV     R3,#(sOutFrameQ >> 8) & 0xff
        LCALL   ??memset?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
//  107 }
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock0
//  108  
//  109 /******************************************************************************
//  110  * @fn          nwk_QfindSlot
//  111  *
//  112  * @brief       Finds a slot to use to retrieve the frame from the radio. It
//  113  *              uses a LRU cast-out scheme. It is possible that this routine
//  114  *              finds no slot. This can happen if the queue is of size 1 or 2
//  115  *              and the Rx interrupt occurs during a retrieval call from an
//  116  *              application. There are meta-states for frames as the application
//  117  *              looks for the oldest frame on the port being requested.
//  118  *
//  119  *              This routine is running in interrupt context.
//  120  *
//  121  * input parameters
//  122  * @param   which   - INQ or OUTQ to search
//  123  *
//  124  * output parameters
//  125  *
//  126  * @return      Pointer to oldest available frame in the queue
//  127  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  128 frameInfo_t *nwk_QfindSlot(uint8_t which)
nwk_QfindSlot:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function nwk_QfindSlot
        CODE
//  129 {
        FUNCALL nwk_QfindSlot, nwk_QadjustOrder
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xd
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 13)
        ; Saved register size: 13
        ; Auto size: 0
        MOV     ?V0 + 2,R1
//  130   frameInfo_t *pFI, *oldest= 0, *newFI = 0;
        MOV     R0,#0x0
        MOV     R1,#0x0
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R0
//  131   uint8_t        i, num, newOrder = 0, orderTest;
        MOV     R4,#0x0
//  132 
//  133   if (INQ == which)
        MOV     A,#0x1
        XRL     A,?V0 + 2
        JNZ     ??nwk_QfindSlot_0
//  134   {
//  135     pFI  = sInFrameQ;
        MOV     R2,#sInFrameQ & 0xff
        MOV     R3,#(sInFrameQ >> 8) & 0xff
//  136     num  = SIZE_INFRAME_Q;
        MOV     R5,#0x4
        SJMP    ??nwk_QfindSlot_1
//  137   }
//  138   else
//  139   {
//  140     pFI  = sOutFrameQ;
??nwk_QfindSlot_0:
        MOV     R2,#sOutFrameQ & 0xff
        MOV     R3,#(sOutFrameQ >> 8) & 0xff
//  141     num  = SIZE_OUTFRAME_Q;
        MOV     R5,#0x2
//  142   }
//  143 
//  144   orderTest = num + 1;
??nwk_QfindSlot_1:
        MOV     A,#0x1
        ADD     A,R5
        MOV     ?V0 + 3,A
//  145 
//  146   for (i=0; i<num; ++i, ++pFI)
        MOV     ?V0 + 4,R0
        SJMP    ??nwk_QfindSlot_2
//  147   {
//  148     /* if frame is available it's a candidate. */
//  149     if (pFI->fi_usage != FI_AVAILABLE)
//  150     {
//  151       if (INQ == which)  /* TODO: do cast-out for Tx as well */
//  152       {
//  153 
//  154         /* need to know the number of occupied slots so we know the age value
//  155          * for the unoccupied slot (if there is one).
//  156          */
//  157         newOrder++;
//  158 
//  159         /* make sure nwk_retrieveFrame() is not processing this frame */
//  160         if (FI_INUSE_TRANSITION == pFI->fi_usage)
//  161         {
//  162           continue;
//  163         }
//  164         /* is this frame older than any we've seen? */
//  165         if (orderTest > pFI->orderStamp)
//  166         {
//  167           /* yes. */
//  168           oldest    = pFI;
//  169           orderTest = pFI->orderStamp;
//  170         }
//  171       }
//  172     }
//  173     else
//  174     {
//  175       if (OUTQ == which)  /* TODO: do cast-out for Tx as well */
//  176       {
//  177         return pFI;
//  178       }
//  179       newFI = pFI;
??nwk_QfindSlot_3:
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
??nwk_QfindSlot_4:
        INC     ?V0 + 4
        MOV     A,R2
        ADD     A,#0x33
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R3,A
??nwk_QfindSlot_2:
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R5
        JNC     ??nwk_QfindSlot_5
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        JZ      ??nwk_QfindSlot_6
        MOV     A,#0x1
        XRL     A,?V0 + 2
        JNZ     ??nwk_QfindSlot_4
        INC     R4
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??nwk_QfindSlot_4
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        CLR     C
        SUBB    A,?V0 + 3
        JNC     ??nwk_QfindSlot_4
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     ?V0 + 3,R6
        SJMP    ??nwk_QfindSlot_4
??nwk_QfindSlot_6:
        MOV     A,#0x2
        XRL     A,?V0 + 2
        JNZ     ??nwk_QfindSlot_3
        SJMP    ??nwk_QfindSlot_7
//  180     }
//  181   }
//  182 
//  183   /* did we find anything? */
//  184   if (!newFI)
??nwk_QfindSlot_5:
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??nwk_QfindSlot_8
//  185   {
//  186     /* queue was full. cast-out happens here...unless... */
//  187     if (!oldest)
        MOV     A,R0
        ORL     A,R1
        JNZ     ??nwk_QfindSlot_9
//  188     {
//  189       /* This can happen if the queue is only of size 1 or 2 and all
//  190        * the frames are in transition when the Rx interrupt occurs.
//  191        */
//  192       return (frameInfo_t *)0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??nwk_QfindSlot_7
//  193     }
//  194     newFI = oldest;
??nwk_QfindSlot_9:
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
//  195     nwk_QadjustOrder(which, newFI->orderStamp);
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
        ; Setup parameters for call to function nwk_QadjustOrder
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R1,?V0 + 2
        LCALL   ??nwk_QadjustOrder?relay
//  196     newFI->orderStamp = i;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,?V0 + 4
        SJMP    ??nwk_QfindSlot_10
//  197   }
//  198   else
//  199   {
//  200     /* mark the available slot. */
//  201     newFI->orderStamp = ++newOrder;
??nwk_QfindSlot_8:
        MOV     A,#0x1
        ADD     A,R4
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
??nwk_QfindSlot_10:
        MOVX    @DPTR,A
//  202   }
//  203 
//  204   return newFI;
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
??nwk_QfindSlot_7:
        MOV     R7,#0x5
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1
//  205 }
//  206 
//  207 /******************************************************************************
//  208  * @fn          nwk_QadjustOrder
//  209  *
//  210  * @brief       Adjusts the age of everyone in the queue newer than the frame
//  211  *              being removed.
//  212  *
//  213  * input parameters
//  214  * @param   which   - INQ or OUTQ to adjust
//  215  * @param   stamp   - value of frame being removed
//  216  *
//  217  * output parameters
//  218  *
//  219  * @return      void
//  220  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  221 void nwk_QadjustOrder(uint8_t which, uint8_t stamp)
nwk_QadjustOrder:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function nwk_QadjustOrder
        CODE
//  222 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  223   frameInfo_t *pFI;
//  224   uint8_t      i, num;
//  225   bspIState_t  intState;
//  226 
//  227   if (INQ == which)
        MOV     A,#0x1
        XRL     A,R1
        JNZ     ??nwk_QadjustOrder_0
//  228   {
//  229     pFI  = sInFrameQ;
        MOV     R4,#sInFrameQ & 0xff
        MOV     R5,#(sInFrameQ >> 8) & 0xff
//  230     num  = SIZE_INFRAME_Q;
//  231   }
//  232   else
//  233   {
//  234 /*    pFI  = sOutFrameQ; */
//  235 /*    num  = SIZE_OUTFRAME_Q; */
//  236     return;
//  237   }
//  238 
//  239   BSP_ENTER_CRITICAL_SECTION(intState);
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     R6,A
        CLR     0xa8.7
//  240 
//  241   for (i=0; i<num; ++i, ++pFI)
        MOV     R0,#0x4
//  242   {
//  243     if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
??nwk_QadjustOrder_1:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        JZ      ??nwk_QadjustOrder_2
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        CLR     C
        SUBB    A,R3
        JNC     ??nwk_QadjustOrder_2
//  244     {
//  245       pFI->orderStamp--;
        MOVX    A,@DPTR
        DEC     A
        MOVX    @DPTR,A
//  246     }
//  247   }
??nwk_QadjustOrder_2:
        MOV     A,R4
        ADD     A,#0x33
        MOV     R4,A
        MOV     A,R5
        ADDC    A,#0x0
        MOV     R5,A
        DEC     R0
        MOV     A,R0
        JNZ     ??nwk_QadjustOrder_1
//  248 
//  249   BSP_EXIT_CRITICAL_SECTION(intState);
        MOV     A,R6
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  250 
//  251   return;
??nwk_QadjustOrder_0:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock2
        REQUIRE _A_IEN0
//  252 }
//  253 
//  254 /******************************************************************************
//  255  * @fn          nwk_QfindOldest
//  256  *
//  257  * @brief       Look through frame queue and find the oldest available frame
//  258  *              in the context in question. Supports connection-based (user),
//  259  *              non-connection based (NWK applications), and the special case
//  260  *              of store-and-forward.
//  261  *
//  262  * input parameters
//  263  * @param   which      - INQ or OUTQ to adjust
//  264  * @param   rcvContext - context information for finding the oldest
//  265  * @param   usage      - normal usage or store-and-forward usage
//  266  *
//  267  * output parameters
//  268  *
//  269  * @return      Pointer to frame that is the oldsest on the requested port, or
//  270  *              0 if there are none.
//  271  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  272 frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
nwk_QfindOldest:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function nwk_QfindOldest
        CODE
//  273 {
        FUNCALL nwk_QfindOldest, nwk_getConnInfo
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL nwk_QfindOldest, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     A,R4
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
        MOV     ?V0 + 12,R2
        MOV     ?V0 + 13,R3
//  274   uint8_t      i, oldest, num, port;
//  275   uint8_t      uType, addr12Compare;
//  276   bspIState_t  intState;
//  277   frameInfo_t *fPtr = 0, *wPtr;
        MOV     ?V0 + 4,#0x0
        MOV     ?V0 + 5,#0x0
//  278   connInfo_t  *pCInfo = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
//  279   uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,R6
        MOV     ?V0 + 14,R6
        MOV     ?V0 + 15,R6
//  280 
//  281   if (INQ == which)
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??nwk_QfindOldest_0
//  282   {
//  283     wPtr   = sInFrameQ;
        MOV     ?V0 + 0,#sInFrameQ & 0xff
        MOV     ?V0 + 1,#(sInFrameQ >> 8) & 0xff
//  284     num    = SIZE_INFRAME_Q;
//  285     oldest = SIZE_INFRAME_Q+1;
        MOV     ?V0 + 7,#0x5
//  286   }
//  287   else
//  288   {
//  289 /*    pFI  = sOutFrameQ; */
//  290 /*    num  = SIZE_OUTFRAME_Q; */
//  291     return 0;
//  292   }
//  293 
//  294   if (RCV_APP_LID == rcv->type)
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x1
        XRL     A,R0
        JNZ     ??nwk_QfindOldest_1
//  295   {
//  296     pCInfo = nwk_getConnInfo(rcv->t.lid);
        ; Setup parameters for call to function nwk_getConnInfo
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??nwk_getConnInfo?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     R6,?V0 + 8
        MOV     R7,?V0 + 9
//  297     if (!pCInfo)
        MOV     A,R6
        ORL     A,R7
        JNZ     ??nwk_QfindOldest_2
??nwk_QfindOldest_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??nwk_QfindOldest_3 & 0xFFFF
//  298     {
//  299       return (frameInfo_t *)0;
//  300     }
//  301     port   = pCInfo->portRx;
??nwk_QfindOldest_2:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
//  302     pAddr2 = pCInfo->peerAddr;
        MOV     A,R6
        ADD     A,#0x2
        MOV     ?V0 + 14,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     ?V0 + 15,A
        SJMP    ??nwk_QfindOldest_4
//  303   }
//  304   else if (RCV_NWK_PORT == rcv->type)
??nwk_QfindOldest_1:
        MOV     A,R0
        JNZ     ??nwk_QfindOldest_0
//  305   {
//  306     port = rcv->t.port;
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
//  307   }
//  308 #ifdef ACCESS_POINT
//  309   else if (RCV_RAW_POLL_FRAME == rcv->type)
//  310   {
//  311     port   = *(MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_PORT_OS);
//  312     pAddr2 = MRFI_P_SRC_ADDR(rcv->t.pkt);
//  313     pAddr3 = MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_ADDR_OS;
//  314   }
//  315 #endif
//  316   else
//  317   {
//  318     return (frameInfo_t *)0;
//  319   }
//  320 
//  321   uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
??nwk_QfindOldest_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??nwk_QfindOldest_5
        MOV     ?V0 + 8,#0x1
        SJMP    ??nwk_QfindOldest_6
??nwk_QfindOldest_5:
        MOV     ?V0 + 8,#0x3
//  322 
//  323   for (i=0; i<num; ++i, ++wPtr)
??nwk_QfindOldest_6:
        MOV     ?V0 + 9,#0x4
//  324   {
//  325 
//  326     BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */
??nwk_QfindOldest_7:
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     R0,A
        CLR     0xa8.7
//  327 
//  328     /* only check entries in use and waiting for this port */
//  329     if (uType == wPtr->fi_usage)
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        XRL     A,?V0 + 8
        JZ      $+5
        LJMP    ??nwk_QfindOldest_8 & 0xFFFF
//  330     {
//  331       wPtr->fi_usage = FI_INUSE_TRANSITION;
        MOV     A,#0x4
        MOVX    @DPTR,A
//  332 
//  333       BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  334       /* message sent to this device? */
//  335       if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
        MOV     A,?V0 + 0
        ADD     A,#0xe
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ANL     A,#0x3f
        XRL     A,?V0 + 6
        JNZ     ??nwk_QfindOldest_9
//  336       {
//  337         /* Port matches. If the port of interest is a NWK applicaiton we're a
//  338          * match...the NWK applications are not connection-based. If it is a
//  339          * NWK application we need to check the source address for disambiguation.
//  340          * Also need to check source address if it's a raw frame lookup (S&F frame)
//  341          */
//  342         if (RCV_APP_LID == rcv->type)
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??nwk_QfindOldest_10
//  343         {
//  344           if (SMPL_PORT_USER_BCAST == port)
        MOV     A,#0x3f
        XRL     A,?V0 + 6
        JNZ     ??nwk_QfindOldest_11
//  345           {
//  346             /* guarantee a match... */
//  347             pAddr1 = pCInfo->peerAddr;
        MOV     A,R6
        ADD     A,#0x2
        MOV     ?V0 + 2,A
        MOV     A,R7
        SJMP    ??nwk_QfindOldest_12
//  348           }
//  349           else
//  350           {
//  351             pAddr1 = MRFI_P_SRC_ADDR(&wPtr->mrfiPkt);
??nwk_QfindOldest_11:
        MOV     A,?V0 + 0
        ADD     A,#0xa
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 1
??nwk_QfindOldest_12:
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
//  352           }
//  353         }
//  354 #ifdef ACCESS_POINT
//  355         else if (RCV_RAW_POLL_FRAME == rcv->type)
//  356         {
//  357           pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
//  358         }
//  359 #endif
//  360 
//  361         addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
??nwk_QfindOldest_10:
        ; Setup parameters for call to function memcmp
        MOV     ?V0 + 10,#0x4
        MOV     ?V0 + 11,#0x0
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 28)
        MOV     R4,?V0 + 14
        MOV     R5,?V0 + 15
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??memcmp?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 26)
//  362         if (  (RCV_NWK_PORT == rcv->type) ||
//  363               (!pAddr3 && !addr12Compare) ||
//  364               (pAddr3 && !memcmp(pAddr3, MRFI_P_SRC_ADDR(&wPtr->mrfiPkt), NET_ADDR_SIZE))
//  365            )
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOVX    A,@DPTR
        JZ      ??nwk_QfindOldest_13
        MOV     A,R2
        JNZ     ??nwk_QfindOldest_9
//  366         {
//  367           if (wPtr->orderStamp < oldest)
??nwk_QfindOldest_13:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,?V0 + 7
        JNC     ??nwk_QfindOldest_9
//  368           {
//  369             if (fPtr)
        MOV     A,?V0 + 4
        ORL     A,?V0 + 5
        JZ      ??nwk_QfindOldest_14
//  370             {
//  371               /* restore previous oldest one */
//  372               fPtr->fi_usage = uType;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOV     A,?V0 + 8
        MOVX    @DPTR,A
//  373             }
//  374             oldest = wPtr->orderStamp;
??nwk_QfindOldest_14:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
//  375             fPtr   = wPtr;
        MOV     ?V0 + 4,?V0 + 0
        MOV     ?V0 + 5,?V0 + 1
//  376             continue;
        SJMP    ??nwk_QfindOldest_15
//  377           }
//  378           else
//  379           {
//  380             /* not oldest. restore state */
//  381             wPtr->fi_usage = uType;
??nwk_QfindOldest_9:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,?V0 + 8
        MOVX    @DPTR,A
        SJMP    ??nwk_QfindOldest_15
//  382           }
//  383         }
//  384         else
//  385         {
//  386           /* not a match. restore state */
//  387           wPtr->fi_usage = uType;
//  388         }
//  389       }
//  390       else
//  391       {
//  392         /* wrong port. restore state */
//  393         wPtr->fi_usage = uType;
//  394       }
//  395     }
//  396     else
//  397     {
//  398       BSP_EXIT_CRITICAL_SECTION(intState);
??nwk_QfindOldest_8:
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  399     }
//  400   }
??nwk_QfindOldest_15:
        MOV     A,?V0 + 0
        ADD     A,#0x33
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
        DEC     ?V0 + 9
        MOV     A,?V0 + 9
        JZ      $+5
        LJMP    ??nwk_QfindOldest_7 & 0xFFFF
//  401 
//  402   return fPtr;
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
??nwk_QfindOldest_3:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock3
        REQUIRE _A_IEN0
//  403 }
//  404 
//  405 /******************************************************************************
//  406  * @fn          nwk_getQ
//  407  *
//  408  * @brief       Get location of teh specified frame queue.
//  409  *
//  410  * input parameters
//  411  * @param   which   - INQ or OUTQ to get
//  412  *
//  413  * output parameters
//  414  *
//  415  * @return      Pointer to frame queue
//  416  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  417 frameInfo_t *nwk_getQ(uint8_t which)
nwk_getQ:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function nwk_getQ
        CODE
//  418 {
        ; Saved register size: 0
        ; Auto size: 0
//  419   return (INQ == which) ? sInFrameQ : sOutFrameQ;
        MOV     A,#0x1
        XRL     A,R1
        JNZ     ??nwk_getQ_0
        MOV     R2,#sInFrameQ & 0xff
        MOV     R3,#(sInFrameQ >> 8) & 0xff
        SJMP    ??nwk_getQ_1
??nwk_getQ_0:
        MOV     R2,#sOutFrameQ & 0xff
        MOV     R3,#(sOutFrameQ >> 8) & 0xff
??nwk_getQ_1:
        LJMP    ?BRET
        CFI EndBlock cfiBlock4
//  420 }

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_QInit?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_QInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_QfindSlot?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_QfindSlot

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_QadjustOrder?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_QadjustOrder

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_QfindOldest?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_QfindOldest

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??nwk_getQ?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    nwk_getQ

        END
//  421 
// 
// 703 bytes in segment BANKED_CODE
//  30 bytes in segment BANK_RELAYS
//   1 byte  in segment SFR_AN
// 306 bytes in segment XDATA_Z
// 
// 733 bytes of CODE  memory
//   0 bytes of DATA  memory (+ 1 byte shared)
// 306 bytes of XDATA memory
//
//Errors: none
//Warnings: none
