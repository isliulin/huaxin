###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.4.40412/W32 for 8051         26/Jul/2016  23:17:48 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk_ap #
#                          plications\nwk_link.c                              #
#    Command line       =  -f C:\Users\freeman\Documents\work\NBK\Nikon\Nikon #
#                          _Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8 #
#                          051\nik_sb5000\IAR\Configuration\LinkTo\smpl_confi #
#                          g.dat ("-DTHIS_DEVICE_ADDRESS={0x79, 0x56, 0x34,   #
#                          0x12}" -DxNWK_PLL_REFERENCE_CLOCK -DLINK_TO) -f    #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\Configuration\smpl_nwk_config.dat  #
#                          (-DMAX_HOPS=3 -DMAX_HOPS_FROM_AP=1                 #
#                          -DMAX_NWK_PAYLOAD=34 -DMAX_APP_PAYLOAD=10          #
#                          -DDEFAULT_LINK_TOKEN=0x01020304                    #
#                          -DDEFAULT_JOIN_TOKEN=0x05060708                    #
#                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK               #
#                          -DxEXTENDED_API -DxSMPL_SECURE                     #
#                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                    #
#                          -DNUM_CONNECTIONS=2 -DSIZE_INFRAME_Q=4             #
#                          -DSIZE_OUTFRAME_Q=2 -DxFREQUENCY_HOPPING           #
#                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                 #
#                          -DUART_NUMBER=UART_NUMBER_0                        #
#                          -DUART_LOCATION=UART_LOCATION_1                    #
#                          -DUART_BAUD_RATE=115200 -DUART_FLOW_CONTROL=UART_F #
#                          LOW_CONTROL_OFF -DUART_PARITY_MODE=UART_PARITY_NON #
#                          E -DUART_STOP_BITS=UART_1_STOP_BIT                 #
#                          -DBSP_TIMER_USED=1 -DEND_DEVICE)                   #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk_ap #
#                          plications\nwk_link.c -D MCU_H=<ioCC2530.h> -D     #
#                          MRFI_CC2530 -D ZTOOL_P1 -D MRFI_PA_LNA_ENABLED     #
#                          -lC C:\Users\freeman\Documents\work\NBK\Nikon\Niko #
#                          n_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_ #
#                          8051\nik_sb5000\IAR\LinkTo\List\ -lA               #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\LinkTo\List\ -o                    #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\LinkTo\Obj\ -e --debug             #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs    #
#                          16 -I C:\Users\freeman\Documents\work\NBK\Nikon\Ni #
#                          kon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF0 #
#                          5_8051\nik_sb5000\IAR\..\..\..\..\..\Components\bs #
#                          p\ -I C:\Users\freeman\Documents\work\NBK\Nikon\Ni #
#                          kon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF0 #
#                          5_8051\nik_sb5000\IAR\..\..\..\..\..\Components\bs #
#                          p\drivers\ -I C:\Users\freeman\Documents\work\NBK\ #
#                          Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp #
#                          les\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo #
#                          nents\bsp\boards\CC2530EM\ -I                      #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\..\..\..\..\..\Components\mrfi\    #
#                          -I C:\Users\freeman\Documents\work\NBK\Nikon\Nikon #
#                          _Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8 #
#                          051\nik_sb5000\IAR\..\..\..\..\..\Components\Simpl #
#                          iciTI\nwk\ -I C:\Users\freeman\Documents\work\NBK\ #
#                          Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp #
#                          les\SRF05_8051\nik_sb5000\IAR\..\..\..\Application #
#                          s\ -I C:\Users\freeman\Documents\work\NBK\Nikon\Ni #
#                          kon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF0 #
#                          5_8051\nik_sb5000\IAR\..\..\..\..\..\Components\Si #
#                          mpliciTI\nwk_applications\ -I                      #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\..\..\..\..\..\Components\OSAL\INC #
#                          LUDE\ -I C:\Users\freeman\Documents\work\NBK\Nikon #
#                          \Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\S #
#                          RF05_8051\nik_sb5000\IAR\..\..\..\..\..\Components #
#                          \OSAL\MCU\CCSOC\ -I C:\Users\freeman\Documents\wor #
#                          k\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects #
#                          \Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\.. #
#                          \Components\HAL\INCLUDE\ -I                        #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\..\..\..\..\..\Components\HAL\TARG #
#                          ET\CC2530EB\ -I C:\Users\freeman\Documents\work\NB #
#                          K\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exa #
#                          mples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Com #
#                          ponents\SERVICES\SADDR\ -I                         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\..\..\..\..\..\Components\SERVICES #
#                          \SDATA\ -I C:\Users\freeman\Documents\work\NBK\Nik #
#                          on\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MT\ -I C:\Users\freeman\Documents\work\NBK\Niko #
#                          n\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\ #
#                          SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Component #
#                          s\STACK\AF\ -I C:\Users\freeman\Documents\work\NBK #
#                          \Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exam #
#                          ples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Comp #
#                          onents\STACK\NWK\ -I C:\Users\freeman\Documents\wo #
#                          rk\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project #
#                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\. #
#                          .\Components\STACK\SEC\ -I                         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\..\..\..\..\..\Components\STACK\SA #
#                          PI\ -I C:\Users\freeman\Documents\work\NBK\Nikon\N #
#                          ikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF #
#                          05_8051\nik_sb5000\IAR\..\..\..\..\..\Components\S #
#                          TACK\SYS\ -I C:\Users\freeman\Documents\work\NBK\N #
#                          ikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl #
#                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compon #
#                          ents\STACK\ZDO\ -I C:\Users\freeman\Documents\work #
#                          \NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\ #
#                          Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\ #
#                          Components\MAC\INCLUDE\ -I                         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\..\..\..\..\..\Components\MAC\HIGH #
#                          _LEVEL\ -I C:\Users\freeman\Documents\work\NBK\Nik #
#                          on\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MAC\LOW_LEVEL\srf04\ -I                         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\..\..\..\..\..\Components\MAC\LOW_ #
#                          LEVEL\srf04\SINGLE_CHIP\ -Ohz --require_prototypes #
#    List file          =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\LinkTo\List\nwk_link.lst           #
#    Object file        =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf #
#                          \SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_8051 #
#                          \nik_sb5000\IAR\LinkTo\Obj\nwk_link.r51            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk_applications\nwk_link.c
      1          /**************************************************************************************************
      2            Filename:       nwk_link.c
      3            Revised:        $Date: 2008-12-23 13:54:27 -0800 (Tue, 23 Dec 2008) $
      4            Revision:       $Revision: 18652 $
      5            Author:         $Author: lfriedman $
      6          
      7            Description:    This file supports the SimpliciTI Link network application.
      8          
      9            Copyright 2007-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights granted under
     12            the terms of a software license agreement between the user who downloaded the software,
     13            his/her employer (which must be your employer) and Texas Instruments Incorporated (the
     14            "License"). You may not use this Software unless you agree to abide by the terms of the
     15            License. The License limits your use, and you acknowledge, that the Software may not be
     16            modified, copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio frequency
     18            transceiver, which is integrated into your product. Other than for the foregoing purpose,
     19            you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
     20            perform, display or sell this Software and/or its documentation for any purpose.
     21          
     22            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS”
     23            WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
     24            WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
     25            IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     26            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
     27            THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
     28            INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
     29            DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
     30            THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     31          
     32            Should you have any questions regarding your right to use this Software,
     33            contact Texas Instruments Incorporated at www.TI.com.
     34          **************************************************************************************************/
     35          
     36          
     37          /******************************************************************************
     38           * INCLUDES
     39           */
     40          
     41          #include <string.h>
     42          #include "bsp.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     43          #include "mrfi.h"
     44          #include "nwk_types.h"
     45          #include "nwk_api.h"
     46          #include "nwk_frame.h"
     47          #include "nwk.h"
     48          #include "nwk_link.h"
     49          #include "nwk_globals.h"
     50          #include "nwk_security.h"
     51          #ifdef DEBUG_CRITICAL_SECTIONS
     52            #include "bsp_leds.h"
     53          #endif
     54          
     55          /******************************************************************************
     56           * MACROS
     57           */
     58          
     59          /******************************************************************************
     60           * CONSTANTS AND DEFINES
     61           */
     62          
     63          /******************************************************************************
     64           * TYPEDEFS
     65           */
     66          
     67          /******************************************************************************
     68           * LOCAL VARIABLES
     69           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     70          static uint32_t          sLinkToken = 0;
   \                     sLinkToken:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71          static volatile uint8_t  sListenActive = 0;
   \                     sListenActive:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     72          #if NUM_CONNECTIONS > 0

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          static volatile linkID_t sServiceLinkID[NUM_CONNECTIONS];
   \                     sServiceLinkID:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     74          #endif

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     75          static volatile uint8_t  sNumLinkers = 0;
   \                     sNumLinkers:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     76          static volatile uint8_t  sTid = 0;
   \                     sTid:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     77          
     78          /******************************************************************************
     79           * LOCAL FUNCTIONS
     80           */
     81          
     82          #define  SENT_REPLY       1
     83          #define  SENT_NO_REPLY    2
     84          static uint8_t    smpl_send_link_reply(mrfiPacket_t *);
     85          static fhStatus_t handleLinkRequest(mrfiPacket_t *);
     86          #if defined(EXTENDED_API)
     87          static void       smpl_send_unlink_reply(mrfiPacket_t *);
     88          #endif
     89          
     90          
     91          /******************************************************************************
     92           * GLOBAL VARIABLES
     93           */
     94          
     95          /******************************************************************************
     96           * GLOBAL FUNCTIONS
     97           */
     98          
     99          /******************************************************************************
    100           * @fn          nwk_linkInit
    101           *
    102           * @brief       Initialize link app. Set link token to the default.
    103           *
    104           * input parameters
    105           *
    106           * output parameters
    107           *
    108           * @return   void
    109           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    110          void nwk_linkInit(void)
   \                     nwk_linkInit:
    111          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    112            if (!sLinkToken)
   \   000005   90....       MOV     DPTR,#sLinkToken
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?L_MOV_X
   \   00000D   E5..         MOV     A,?V0 + 0
   \   00000F   45..         ORL     A,?V0 + 1
   \   000011   45..         ORL     A,?V0 + 2
   \   000013   45..         ORL     A,?V0 + 3
   \   000015   700C         JNZ     ??nwk_linkInit_0
    113            {
    114              /* if the link token has not been set externally by the time we get here
    115               * (such as by the ioctl token-setting interface) assign the default
    116               */
    117              sLinkToken = DEFAULT_LINK_TOKEN;
   \   000017   90....       MOV     DPTR,#__Constant_1020304
   \   00001A   12....       LCALL   ?XLOAD_R2345
   \   00001D   90....       MOV     DPTR,#sLinkToken
   \   000020   12....       LCALL   ?XSTORE_R2345
    118            }
    119          
    120            /* set a non-zero TID. */
    121            while (!(sTid = MRFI_RandomByte()))  ;
   \                     ??nwk_linkInit_0:
   \   000023                ; Setup parameters for call to function MRFI_RandomByte
   \   000023   12....       LCALL   ??MRFI_RandomByte?relay
   \   000026   E9           MOV     A,R1
   \   000027   90....       MOV     DPTR,#sTid
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   60F6         JZ      ??nwk_linkInit_0
    122          
    123          #if NUM_CONNECTIONS > 0
    124            memset((void *)&sServiceLinkID, 0x0, sizeof(sServiceLinkID));
   \   00002D                ; Setup parameters for call to function memset
   \   00002D   75..02       MOV     ?V0 + 0,#0x2
   \   000030   75..00       MOV     ?V0 + 1,#0x0
   \   000033   78..         MOV     R0,#?V0 + 0
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000038   7C00         MOV     R4,#0x0
   \   00003A   7D00         MOV     R5,#0x0
   \   00003C   7A..         MOV     R2,#sServiceLinkID & 0xff
   \   00003E   7B..         MOV     R3,#(sServiceLinkID >> 8) & 0xff
   \   000040   12....       LCALL   ??memset?relay
   \   000043   7402         MOV     A,#0x2
   \   000045                REQUIRE ?Subroutine0
   \   000045                ; // Fall through to label ?Subroutine0
    125          #endif
    126          
    127            return;
    128          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine9_0
   \   000003                ; // Fall through to label ??Subroutine9_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine9_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    129          
    130          /******************************************************************************
    131           * @fn          nwk_setLinkToken
    132           *
    133           * @brief       Sets the link token received in a Join reply.
    134           *
    135           * input parameters
    136           * @param   token   - Link token to be used on this network to link to any peer.
    137           *
    138           * output parameters
    139           *
    140           * @return   void
    141           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    142          void nwk_setLinkToken(uint32_t token)
   \                     nwk_setLinkToken:
    143          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
    144            /* only set if the supplied token is non-zero. */
    145            if (token)
   \   00000D   EA           MOV     A,R2
   \   00000E   45..         ORL     A,?V0 + 1
   \   000010   45..         ORL     A,?V0 + 2
   \   000012   45..         ORL     A,?V0 + 3
   \   000014   6008         JZ      ??nwk_setLinkToken_0
    146            {
    147              sLinkToken = token;
   \   000016   90....       MOV     DPTR,#sLinkToken
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?L_MOV_TO_X
    148            }
    149          
    150            return;
   \                     ??nwk_setLinkToken_0:
   \   00001E   80..         SJMP    ??Subroutine9_0
    151          }
    152          
    153          /******************************************************************************
    154           * @fn          nwk_getLinkToken
    155           *
    156           * @brief       Gets the current link token.
    157           *
    158           * input parameters
    159           *
    160           * output parameters
    161           * @param   pToken   - pointer to the returned value.
    162           *
    163           * @return   Current link token
    164           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    165          void nwk_getLinkToken(uint32_t *pToken)
   \                     nwk_getLinkToken:
    166          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
    167            /* only set if the supplied token is non-zero. */
    168            if (pToken)
   \   000009   E8           MOV     A,R0
   \   00000A   49           ORL     A,R1
   \   00000B   600D         JZ      ??nwk_getLinkToken_0
    169            {
    170              *pToken = sLinkToken;
   \   00000D   90....       MOV     DPTR,#sLinkToken
   \   000010   12....       LCALL   ?XLOAD_R2345
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
   \   000017   12....       LCALL   ?XSTORE_R2345
    171            }
    172          
    173            return;
   \                     ??nwk_getLinkToken_0:
   \   00001A                REQUIRE ?Subroutine1
   \   00001A                ; // Fall through to label ?Subroutine1
    174          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    175          
    176          #if defined(EXTENDED_API)
    177          /******************************************************************************
    178           * @fn          nwk_unlink
    179           *
    180           * @brief       Called from the application level to tear down a link.
    181           *
    182           * input parameters
    183           *
    184           * output parameters
    185           * @param   lid     - Link ID assigned for this link
    186           *
    187           * @return   Status of the operation.
    188           *           SMPL_SUCCESS
    189           *           SMPL_BAD_PARAM       No connection table entry for this Link ID;
    190           *                                SMPL_LINKID_USER_UUD not valid since it is not
    191           *                                connection-based.
    192           *           SMPL_TIMEOUT         No reply from peer.
    193           *           SMPL_NO_PEER_UNLINK  Peer did not have a Connection Table entry for me.
    194           */
    195          smplStatus_t nwk_unlink(linkID_t lid)
    196          {
    197            uint8_t      msg[UNLINK_FRAME_SIZE];
    198            connInfo_t  *pCInfo = nwk_getConnInfo(lid);
    199            smplStatus_t rc     = SMPL_SUCCESS;
    200            addr_t       addr;
    201            union
    202            {
    203              ioctlRawSend_t    send;
    204              ioctlRawReceive_t recv;
    205            } ioctl_info;
    206          
    207            /* is there connection info? */
    208             if (!pCInfo || (lid == SMPL_LINKID_USER_UUD))
    209            {
    210              return SMPL_BAD_PARAM;
    211            }
    212          
    213            /* set request byte */
    214            msg[LB_REQ_OS] = LINK_REQ_UNLINK;
    215          
    216            /* set the transaction ID. this allows target to figure out duplicates */
    217            msg[LB_TID_OS] = sTid;
    218          
    219            /* remote port to be sent in message to help match connection */
    220            msg[UL_RMT_PORT_OS] = pCInfo->portRx;
    221          
    222            /* setup for ioctl raw I/O */
    223            memcpy(addr.addr, pCInfo->peerAddr, NET_ADDR_SIZE);
    224            ioctl_info.send.addr = &addr;
    225            ioctl_info.send.msg  = msg;
    226            ioctl_info.send.len  = sizeof(msg);
    227            ioctl_info.send.port = SMPL_PORT_LINK;
    228          
    229            SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send);
    230          
    231            {
    232              uint8_t spin       = NWK_RX_RETRY_COUNT;
    233              uint8_t radioState = MRFI_GetRadioState();
    234          
    235              ioctl_info.recv.port = SMPL_PORT_LINK;
    236              ioctl_info.recv.msg  = msg;
    237              ioctl_info.recv.addr = (addr_t *)0;
    238          
    239              do
    240              {
    241                NWK_CHECK_FOR_SETRX(radioState);
    242                NWK_REPLY_DELAY();
    243                NWK_CHECK_FOR_RESTORE_STATE(radioState);
    244          
    245                if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    246                {
    247                  if ((msg[LB_REQ_OS] & (~NWK_APP_REPLY_BIT)) == LINK_REQ_UNLINK)
    248                  {
    249                    rc = (smplStatus_t)msg[ULR_RESULT_OS];
    250                    break;
    251                  }
    252                }
    253                if (!spin)
    254                {
    255                  rc = SMPL_TIMEOUT;
    256                  break;
    257                }
    258                --spin;
    259              } while (1);
    260          
    261             /* it's ok to unconditionally invalidate connection object */
    262              nwk_freeConnection(pCInfo);
    263            }
    264            return rc;
    265          }
    266          #endif  /* EXTENDED_API */
    267          
    268          /******************************************************************************
    269           * @fn          nwk_link
    270           *
    271           * @brief       Called from the application level to accomplish the link
    272           *
    273           * input parameters
    274           *
    275           * output parameters
    276           * @param   lid     - pointer to Link ID (port) assigned for this link
    277           *
    278           * @return   Status of the operation.
    279           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    280          smplStatus_t nwk_link(linkID_t *lid)
   \                     nwk_link:
    281          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
    282            uint8_t       msg[LINK_FRAME_SIZE];
    283            connInfo_t   *pCInfo = nwk_getNextConnection();
   \   00000E                ; Setup parameters for call to function nwk_getNextConnection
   \   00000E   12....       LCALL   ??nwk_getNextConnection?relay
   \   000011   8A..         MOV     ?V0 + 2,R2
   \   000013   8B..         MOV     ?V0 + 3,R3
   \   000015   AE..         MOV     R6,?V0 + 2
   \   000017   AF..         MOV     R7,?V0 + 3
    284            smplStatus_t  rc;
    285          
    286            if (pCInfo)
   \   000019   EE           MOV     A,R6
   \   00001A   4F           ORL     A,R7
   \   00001B   7003         JNZ     $+5
   \   00001D   02....       LJMP    ??nwk_link_0 & 0xFFFF
    287            {
    288              addr_t              addr;
    289              union
    290              {
    291                ioctlRawSend_t    send;
    292                ioctlRawReceive_t recv;
    293              } ioctl_info;
    294          
    295              if (!nwk_allocateLocalRxPort(LINK_SEND, pCInfo))
   \   000020                ; Setup parameters for call to function nwk_allocateLocalRxPort
   \   000020   7901         MOV     R1,#0x1
   \   000022   12....       LCALL   ??nwk_allocateLocalRxPort?relay
   \   000025   E9           MOV     A,R1
   \   000026   700A         JNZ     ??nwk_link_1
    296              {
    297                nwk_freeConnection(pCInfo);
   \   000028                ; Setup parameters for call to function nwk_freeConnection
   \   000028   EE           MOV     A,R6
   \   000029   FA           MOV     R2,A
   \   00002A   EF           MOV     A,R7
   \   00002B   FB           MOV     R3,A
   \   00002C   12....       LCALL   ??nwk_freeConnection?relay
    298                return SMPL_NOMEM;
   \   00002F   02....       LJMP    ??nwk_link_0 & 0xFFFF
    299              }
    300          
    301              memcpy(addr.addr, nwk_getBCastAddress(), NET_ADDR_SIZE);
   \                     ??nwk_link_1:
   \   000032                ; Setup parameters for call to function memcpy
   \   000032   75..04       MOV     ?V0 + 2,#0x4
   \   000035   75..00       MOV     ?V0 + 3,#0x0
   \   000038   78..         MOV     R0,#?V0 + 2
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D                ; Setup parameters for call to function nwk_getBCastAddress
   \   00003D   12....       LCALL   ??nwk_getBCastAddress?relay
   \   000040   EA           MOV     A,R2
   \   000041   FC           MOV     R4,A
   \   000042   EB           MOV     A,R3
   \   000043   FD           MOV     R5,A
   \   000044   7412         MOV     A,#0x12
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   AA82         MOV     R2,DPL
   \   00004B   AB83         MOV     R3,DPH
   \   00004D   12....       LCALL   ??Subroutine11_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
    302              ioctl_info.send.addr = &addr;
   \   000053   7410         MOV     A,#0x10
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   A882         MOV     R0,DPL
   \   00005A   A983         MOV     R1,DPH
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   E8           MOV     A,R0
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   E9           MOV     A,R1
   \   000066   F0           MOVX    @DPTR,A
    303              ioctl_info.send.msg  = msg;
   \   000067   7407         MOV     A,#0x7
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   A882         MOV     R0,DPL
   \   00006E   A983         MOV     R1,DPH
   \   000070   7402         MOV     A,#0x2
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E8           MOV     A,R0
   \   000076   F0           MOVX    @DPTR,A
   \   000077   A3           INC     DPTR
   \   000078   E9           MOV     A,R1
   \   000079   F0           MOVX    @DPTR,A
    304              ioctl_info.send.len  = sizeof(msg);
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   7409         MOV     A,#0x9
   \   000081   F0           MOVX    @DPTR,A
    305              ioctl_info.send.port = SMPL_PORT_LINK;
   \   000082   7405         MOV     A,#0x5
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   7402         MOV     A,#0x2
   \   000089   F0           MOVX    @DPTR,A
    306          
    307              /* Put link token in */
    308              nwk_putNumObjectIntoMsg((void *)&sLinkToken, msg+L_LINK_TOKEN_OS, sizeof(sLinkToken));
   \   00008A                ; Setup parameters for call to function nwk_putNumObjectIntoMsg
   \   00008A   7904         MOV     R1,#0x4
   \   00008C   7409         MOV     A,#0x9
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   AC82         MOV     R4,DPL
   \   000093   AD83         MOV     R5,DPH
   \   000095   7A..         MOV     R2,#sLinkToken & 0xff
   \   000097   7B..         MOV     R3,#(sLinkToken >> 8) & 0xff
   \   000099   12....       LCALL   ??nwk_putNumObjectIntoMsg?relay
    309          
    310              /* set port to which the remote device should send */
    311              msg[L_RMT_PORT_OS] = pCInfo->portRx;
   \   00009C   8E82         MOV     DPL,R6
   \   00009E   8F83         MOV     DPH,R7
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   C0E0         PUSH    A
   \   0000AB   740D         MOV     A,#0xd
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   D0E0         POP     A
   \   0000B2   F0           MOVX    @DPTR,A
    312          
    313              /* set the transaction ID. this allows target to figure out duplicates */
    314              msg[LB_TID_OS] = sTid;
   \   0000B3   90....       MOV     DPTR,#sTid
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   C0E0         PUSH    A
   \   0000B9   7408         MOV     A,#0x8
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   D0E0         POP     A
   \   0000C0   F0           MOVX    @DPTR,A
    315          
    316              /* set my Rx type */
    317              msg[L_MY_RXTYPE_OS] = nwk_getMyRxType();
   \   0000C1                ; Setup parameters for call to function nwk_getMyRxType
   \   0000C1   12....       LCALL   ??nwk_getMyRxType?relay
   \   0000C4   740E         MOV     A,#0xe
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   E9           MOV     A,R1
   \   0000CA   F0           MOVX    @DPTR,A
    318          
    319              /* set request byte */
    320              msg[LB_REQ_OS] = LINK_REQ_LINK;
   \   0000CB   7407         MOV     A,#0x7
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   7401         MOV     A,#0x1
   \   0000D2   F0           MOVX    @DPTR,A
    321          
    322              /* protocol version number */
    323              msg[L_PROTOCOL_VERSION_OS] = nwk_getProtocolVersion();
   \   0000D3                ; Setup parameters for call to function nwk_getProtocolVersion
   \   0000D3   12....       LCALL   ??nwk_getProtocolVersion?relay
   \   0000D6   740F         MOV     A,#0xf
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   E9           MOV     A,R1
   \   0000DC   F0           MOVX    @DPTR,A
    324          
    325          #if defined(SMPL_SECURE)
    326              pCInfo->connTxCTR = MRFI_RandomByte()                   | \
    327                                  ((uint32_t)(MRFI_RandomByte())<<8)  | \
    328                                  ((uint32_t)(MRFI_RandomByte())<<16) | \
    329                                  ((uint32_t)(MRFI_RandomByte())<<24);
    330          
    331              nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[L_CTR_OS], 4);
    332          #endif
    333          
    334          
    335              if (SMPL_SUCCESS != (rc=SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send)))
   \   0000DD                ; Setup parameters for call to function SMPL_Ioctl
   \   0000DD   85..82       MOV     DPL,?XSP + 0
   \   0000E0   85..83       MOV     DPH,?XSP + 1
   \   0000E3   AC82         MOV     R4,DPL
   \   0000E5   AD83         MOV     R5,DPH
   \   0000E7   7A03         MOV     R2,#0x3
   \   0000E9   7902         MOV     R1,#0x2
   \   0000EB   12....       LCALL   ??SMPL_Ioctl?relay
   \   0000EE   E9           MOV     A,R1
   \   0000EF   F5..         MOV     ?V0 + 2,A
   \   0000F1   600C         JZ      ??nwk_link_2
    336              {
    337                nwk_freeConnection(pCInfo);
   \   0000F3                ; Setup parameters for call to function nwk_freeConnection
   \   0000F3   EE           MOV     A,R6
   \   0000F4   FA           MOV     R2,A
   \   0000F5   EF           MOV     A,R7
   \   0000F6   FB           MOV     R3,A
   \   0000F7   12....       LCALL   ??nwk_freeConnection?relay
    338                return rc;
   \   0000FA   A9..         MOV     R1,?V0 + 2
   \   0000FC   02....       LJMP    ??nwk_link_3 & 0xFFFF
    339              }
    340          
    341              {
    342                uint8_t radioState = MRFI_GetRadioState();
   \                     ??nwk_link_2:
   \   0000FF                ; Setup parameters for call to function MRFI_GetRadioState
   \   0000FF   12....       LCALL   ??MRFI_GetRadioState?relay
   \   000102   E9           MOV     A,R1
   \   000103   F5..         MOV     ?V0 + 2,A
    343          
    344                ioctl_info.recv.port = SMPL_PORT_LINK;
   \   000105   7405         MOV     A,#0x5
   \   000107   12....       LCALL   ?XSTACK_DISP0_8
   \   00010A   7402         MOV     A,#0x2
   \   00010C   F0           MOVX    @DPTR,A
    345                ioctl_info.recv.msg  = msg;
   \   00010D   7407         MOV     A,#0x7
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   A882         MOV     R0,DPL
   \   000114   A983         MOV     R1,DPH
   \   000116   7402         MOV     A,#0x2
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   E8           MOV     A,R0
   \   00011C   F0           MOVX    @DPTR,A
   \   00011D   A3           INC     DPTR
   \   00011E   E9           MOV     A,R1
   \   00011F   F0           MOVX    @DPTR,A
    346                ioctl_info.recv.addr = (addr_t *)pCInfo->peerAddr;
   \   000120   EE           MOV     A,R6
   \   000121   2402         ADD     A,#0x2
   \   000123   F8           MOV     R0,A
   \   000124   EF           MOV     A,R7
   \   000125   3400         ADDC    A,#0x0
   \   000127   F9           MOV     R1,A
   \   000128   85..82       MOV     DPL,?XSP + 0
   \   00012B   85..83       MOV     DPH,?XSP + 1
   \   00012E   E8           MOV     A,R0
   \   00012F   F0           MOVX    @DPTR,A
   \   000130   A3           INC     DPTR
   \   000131   E9           MOV     A,R1
   \   000132   F0           MOVX    @DPTR,A
    347          
    348                NWK_CHECK_FOR_SETRX(radioState);
   \   000133   7403         MOV     A,#0x3
   \   000135   65..         XRL     A,?V0 + 2
   \   000137   600C         JZ      ??nwk_link_4
   \   000139   7401         MOV     A,#0x1
   \   00013B   65..         XRL     A,?V0 + 2
   \   00013D   7003         JNZ     ??nwk_link_5
   \   00013F                ; Setup parameters for call to function MRFI_WakeUp
   \   00013F   12....       LCALL   ??MRFI_WakeUp?relay
   \                     ??nwk_link_5:
   \   000142                ; Setup parameters for call to function MRFI_RxOn
   \   000142   12....       LCALL   ??MRFI_RxOn?relay
    349                NWK_REPLY_DELAY();
   \                     ??nwk_link_4:
   \   000145                ; Setup parameters for call to function MRFI_ReplyDelay
   \   000145   12....       LCALL   ??MRFI_ReplyDelay?relay
    350                NWK_CHECK_FOR_RESTORE_STATE(radioState);
   \   000148   7403         MOV     A,#0x3
   \   00014A   65..         XRL     A,?V0 + 2
   \   00014C   600E         JZ      ??nwk_link_6
   \   00014E   7401         MOV     A,#0x1
   \   000150   65..         XRL     A,?V0 + 2
   \   000152   7005         JNZ     ??nwk_link_7
   \   000154                ; Setup parameters for call to function MRFI_Sleep
   \   000154   12....       LCALL   ??MRFI_Sleep?relay
   \   000157   8003         SJMP    ??nwk_link_6
   \                     ??nwk_link_7:
   \   000159                ; Setup parameters for call to function MRFI_RxIdle
   \   000159   12....       LCALL   ??MRFI_RxIdle?relay
    351          
    352                if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
   \                     ??nwk_link_6:
   \   00015C                ; Setup parameters for call to function SMPL_Ioctl
   \   00015C   85..82       MOV     DPL,?XSP + 0
   \   00015F   85..83       MOV     DPH,?XSP + 1
   \   000162   AC82         MOV     R4,DPL
   \   000164   AD83         MOV     R5,DPH
   \   000166   7A02         MOV     R2,#0x2
   \   000168   7902         MOV     R1,#0x2
   \   00016A   12....       LCALL   ??SMPL_Ioctl?relay
   \   00016D   E9           MOV     A,R1
   \   00016E   705D         JNZ     ??nwk_link_8
    353                {
    354                  uint8_t firstByte = msg[LB_REQ_OS] & (~NWK_APP_REPLY_BIT);
   \   000170   7407         MOV     A,#0x7
   \   000172   12....       LCALL   ?XSTACK_DISP0_8
   \   000175   E0           MOVX    A,@DPTR
   \   000176   547F         ANL     A,#0x7f
   \   000178   F8           MOV     R0,A
    355          
    356                  /* Sanity check for correct reply frame. Older version
    357                   * has the length instead of the request as the first byte.
    358                   */
    359                  if ((firstByte != LINK_REQ_LINK) &&
    360                      (firstByte != LINK_REPLY_LEGACY_MSG_LENGTH)
    361                     )
   \   000179   7401         MOV     A,#0x1
   \   00017B   68           XRL     A,R0
   \   00017C   6010         JZ      ??nwk_link_9
   \   00017E   7403         MOV     A,#0x3
   \   000180   68           XRL     A,R0
   \   000181   600B         JZ      ??nwk_link_9
    362                  {
    363                    /* invalidate connection object */
    364                    nwk_freeConnection(pCInfo);
   \   000183                ; Setup parameters for call to function nwk_freeConnection
   \   000183   EE           MOV     A,R6
   \   000184   FA           MOV     R2,A
   \   000185   EF           MOV     A,R7
   \   000186   FB           MOV     R3,A
   \   000187   12....       LCALL   ??nwk_freeConnection?relay
    365                    return SMPL_NO_LINK;
   \   00018A   7905         MOV     R1,#0x5
   \   00018C   805F         SJMP    ??nwk_link_3
    366          
    367                  }
    368                }
    369                else
    370                {
    371                  /* no successful receive */
    372                  nwk_freeConnection(pCInfo);
    373                  return SMPL_TIMEOUT;
    374                }
    375          
    376                pCInfo->connState = CONNSTATE_CONNECTED;
   \                     ??nwk_link_9:
   \   00018E   8E82         MOV     DPL,R6
   \   000190   8F83         MOV     DPH,R7
   \   000192   7402         MOV     A,#0x2
   \   000194   F0           MOVX    @DPTR,A
    377                pCInfo->portTx    = msg[LR_RMT_PORT_OS];    /* link reply returns remote port */
   \   000195   7409         MOV     A,#0x9
   \   000197   12....       LCALL   ?XSTACK_DISP0_8
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   8E82         MOV     DPL,R6
   \   00019D   8F83         MOV     DPH,R7
   \   00019F   A3           INC     DPTR
   \   0001A0   A3           INC     DPTR
   \   0001A1   A3           INC     DPTR
   \   0001A2   A3           INC     DPTR
   \   0001A3   A3           INC     DPTR
   \   0001A4   A3           INC     DPTR
   \   0001A5   A3           INC     DPTR
   \   0001A6   A3           INC     DPTR
   \   0001A7   A3           INC     DPTR
   \   0001A8   12....       LCALL   ?Subroutine3 & 0xFFFF
    378                *lid              = pCInfo->thisLinkID;     /* return our local port number */
   \                     ??CrossCallReturnLabel_2:
   \   0001AB   85..82       MOV     DPL,?V0 + 0
   \   0001AE   85..83       MOV     DPH,?V0 + 1
   \   0001B1   F0           MOVX    @DPTR,A
    379          
    380                /* Set hop count. If it's a polling device set the count to the
    381                 * distance to the AP. Otherwise, set it to the max less the remaining
    382                 * which will be the path taken for this frame. It will be no worse
    383                 * then tha max and probably will be better.
    384                 */
    385                if (F_RX_TYPE_POLLS == msg[LR_MY_RXTYPE_OS])
   \   0001B2   8E82         MOV     DPL,R6
   \   0001B4   8F83         MOV     DPH,R7
   \   0001B6   A3           INC     DPTR
   \   0001B7   A882         MOV     R0,DPL
   \   0001B9   A983         MOV     R1,DPH
   \   0001BB   740A         MOV     A,#0xa
   \   0001BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C0   E0           MOVX    A,@DPTR
   \   0001C1   6440         XRL     A,#0x40
   \   0001C3   8882         MOV     DPL,R0
   \   0001C5   8983         MOV     DPH,R1
   \   0001C7   700F         JNZ     ??nwk_link_10
    386                {
    387                  pCInfo->hops2target = MAX_HOPS_FROM_AP;
   \   0001C9   7401         MOV     A,#0x1
   \   0001CB   800D         SJMP    ??nwk_link_11
    388                }
   \                     ??nwk_link_8:
   \   0001CD                ; Setup parameters for call to function nwk_freeConnection
   \   0001CD   EE           MOV     A,R6
   \   0001CE   FA           MOV     R2,A
   \   0001CF   EF           MOV     A,R7
   \   0001D0   FB           MOV     R3,A
   \   0001D1   12....       LCALL   ??nwk_freeConnection?relay
   \   0001D4   7901         MOV     R1,#0x1
   \   0001D6   8015         SJMP    ??nwk_link_3
    389                else
    390                {
    391                  /* Can't really use this trick because the device could move. If the
    392                   * devices are all static this may work unless the initial reception
    393                   * was marginal.
    394                   */
    395          #if defined(DEVICE_DOES_NOT_MOVE)
    396                  pCInfo->hops2target = MAX_HOPS - ioctl_info.recv.hopCount;
    397          #else
    398                  pCInfo->hops2target = MAX_HOPS;
   \                     ??nwk_link_10:
   \   0001D8   7403         MOV     A,#0x3
   \                     ??nwk_link_11:
   \   0001DA   F0           MOVX    @DPTR,A
    399          #endif
    400                }
    401          
    402          #if defined(SMPL_SECURE)
    403                nwk_getNumObjectFromMsg((void *)&msg[LR_CTR_OS], (void *)&pCInfo->connRxCTR, 4);
    404          #endif
    405              }
    406          
    407              /* guard against duplicates... */
    408              ++sTid;
   \   0001DB   90....       MOV     DPTR,#sTid
   \   0001DE   E0           MOVX    A,@DPTR
   \   0001DF   04           INC     A
   \   0001E0   F0           MOVX    @DPTR,A
    409              if (!sTid)
   \   0001E1   E0           MOVX    A,@DPTR
   \   0001E2   7003         JNZ     ??nwk_link_12
    410              {
    411                sTid = 1;
   \   0001E4   7401         MOV     A,#0x1
   \   0001E6   F0           MOVX    @DPTR,A
    412              }
    413              return SMPL_SUCCESS;
   \                     ??nwk_link_12:
   \   0001E7   7900         MOV     R1,#0x0
   \   0001E9   8002         SJMP    ??nwk_link_3
    414            }
    415          
    416            return SMPL_NOMEM;
   \                     ??nwk_link_0:
   \   0001EB   7903         MOV     R1,#0x3
   \                     ??nwk_link_3:
   \   0001ED   7414         MOV     A,#0x14
   \   0001EF   02....       LJMP    ?Subroutine0 & 0xFFFF
    417          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   12....       LCALL   ??memcpy?relay
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET
    418          
    419          #if defined(EXTENDED_API)
    420          /******************************************************************************
    421           * @fn          smpl_send_unlink_reply
    422           *
    423           * @brief       Send the unlink reply to the device trying to unlink
    424           *
    425           * input parameters
    426           * @param   frame   - frame received from linker
    427           *
    428           * output parameters
    429           *
    430           * @return   void
    431           */
    432          static void smpl_send_unlink_reply(mrfiPacket_t *frame)
    433          {
    434            connInfo_t  *pCInfo;
    435            frameInfo_t *pOutFrame;
    436            uint8_t      msg[UNLINK_REPLY_FRAME_SIZE];
    437            smplStatus_t rc = SMPL_NO_PEER_UNLINK;
    438          
    439            /* match the remote port and source address with a connection table entry */
    440            if (pCInfo = nwk_findPeer((addr_t *)MRFI_P_SRC_ADDR(frame), *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+UL_RMT_PORT_OS)))
    441            {
    442              /* Note we unconditionally free the connection resources */
    443              nwk_freeConnection(pCInfo);
    444              rc = SMPL_SUCCESS;
    445            }
    446          
    447            /* set reply bit */
    448            msg[LB_REQ_OS] = LINK_REQ_UNLINK | NWK_APP_REPLY_BIT;
    449          
    450            /* sender's TID */
    451            msg[LB_TID_OS] = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+LB_TID_OS);
    452          
    453            /* result of freeing local connection */
    454            msg[ULR_RESULT_OS] = rc;
    455          
    456            if (pOutFrame = nwk_buildFrame(SMPL_PORT_LINK, msg, sizeof(msg), MAX_HOPS))
    457            {
    458              /* destination address is the source adddress of the received frame. */
    459              memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    460          #if defined(SMPL_SECURE)
    461              nwk_setSecureFrame(&pOutFrame->mrfiPkt, sizeof(msg), 0);
    462          #endif  /* SMPL_SECURE */
    463              nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
    464            }
    465          }
    466          #endif  /* EXTENDED_API */
    467          
    468          /******************************************************************************
    469           * @fn          smpl_send_link_reply
    470           *
    471           * @brief       Send the link reply to the device trying to link. This routine
    472           *              will handle duplicates.
    473           *
    474           * input parameters
    475           * @param   frame   - frame received from linker
    476           *
    477           * output parameters
    478           *
    479           * @return   Returns SENT_REPLY if reply sent, else SENT_NO_REPLY.
    480           *           The return value is used as this routine unwinds to know
    481           *           whether to replay the frame. An RE or AP can host an ED
    482           *           object in which case it might send a reply (possibly from
    483           *           a duplicate frame). If we do reply we do not want to replay.
    484           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    485          static uint8_t smpl_send_link_reply(mrfiPacket_t *frame)
   \                     smpl_send_link_reply:
    486          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
    487          #if NUM_CONNECTIONS > 0
    488            frameInfo_t *pOutFrame;
    489            connInfo_t  *pCInfo;
    490            uint8_t      remotePort;
    491            uint8_t      msg[LINK_REPLY_FRAME_SIZE];
    492          
    493            /* Is this a legacy frame? If so continue. Otherwise check version.*/
    494            if ((MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS) > LINK_LEGACY_MSG_LENGTH)
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   E0           MOVX    A,@DPTR
   \   000013   24F2         ADD     A,#-0xe
   \   000015   F8           MOV     R0,A
   \   000016   E4           CLR     A
   \   000017   34FF         ADDC    A,#-0x1
   \   000019   F9           MOV     R1,A
   \   00001A   C3           CLR     C
   \   00001B   E8           MOV     A,R0
   \   00001C   9409         SUBB    A,#0x9
   \   00001E   E9           MOV     A,R1
   \   00001F   9400         SUBB    A,#0x0
   \   000021   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000023   65D0         XRL     A,PSW
   \   000025   33           RLC     A
   \   000026   4021         JC      ??smpl_send_link_reply_0
    495            {
    496              /* see if protocol version is correct... */
    497              if (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_PROTOCOL_VERSION_OS) != nwk_getProtocolVersion())
   \   000028                ; Setup parameters for call to function nwk_getProtocolVersion
   \   000028   12....       LCALL   ??nwk_getProtocolVersion?relay
   \   00002B   E9           MOV     A,R1
   \   00002C   F8           MOV     R0,A
   \   00002D   E5..         MOV     A,?V0 + 0
   \   00002F   2417         ADD     A,#0x17
   \   000031   F582         MOV     DPL,A
   \   000033   E5..         MOV     A,?V0 + 1
   \   000035   3400         ADDC    A,#0x0
   \   000037   F583         MOV     DPH,A
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   68           XRL     A,R0
   \   00003B   600C         JZ      ??smpl_send_link_reply_0
    498              {
    499                /* Accommodation of protocol version differences can be noted or accomplished here.
    500                 * This field was also checked in the join transaction but it is checked again here
    501                 * because that check may not have occurred if thre is no AP in this topology.
    502                 * Otherwise, no match and the board goes back
    503                 */
    504                return SENT_NO_REPLY;
   \                     ??smpl_send_link_reply_1:
   \   00003D   7902         MOV     R1,#0x2
   \                     ??smpl_send_link_reply_2:
   \   00003F   7408         MOV     A,#0x8
   \   000041   12....       LCALL   ?DEALLOC_XSTACK8
   \   000044   7F0C         MOV     R7,#0xc
   \   000046   02....       LJMP    ?BANKED_LEAVE_XDATA
    505              }
    506            }
    507          
    508            /* see if token is correct */
    509            {
    510              uint32_t lt;
    511          
    512              nwk_getNumObjectFromMsg(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_LINK_TOKEN_OS, &lt, sizeof(lt));
   \                     ??smpl_send_link_reply_0:
   \   000049                ; Setup parameters for call to function nwk_getNumObjectFromMsg
   \   000049   7904         MOV     R1,#0x4
   \   00004B   E9           MOV     A,R1
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   AC82         MOV     R4,DPL
   \   000051   AD83         MOV     R5,DPH
   \   000053   E5..         MOV     A,?V0 + 0
   \   000055   2411         ADD     A,#0x11
   \   000057   FA           MOV     R2,A
   \   000058   E5..         MOV     A,?V0 + 1
   \   00005A   3400         ADDC    A,#0x0
   \   00005C   FB           MOV     R3,A
   \   00005D   12....       LCALL   ??nwk_getNumObjectFromMsg?relay
    513              if (lt != sLinkToken)
   \   000060   7404         MOV     A,#0x4
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   C082         PUSH    DPL
   \   000067   C083         PUSH    DPH
   \   000069   90....       MOV     DPTR,#sLinkToken
   \   00006C   78..         MOV     R0,#?V0 + 4
   \   00006E   12....       LCALL   ?L_MOV_X
   \   000071   D083         POP     DPH
   \   000073   D082         POP     DPL
   \   000075   78..         MOV     R0,#?V0 + 4
   \   000077   12....       LCALL   ?L_EQ_X
   \   00007A   70C1         JNZ     ??smpl_send_link_reply_1
    514              {
    515                return SENT_NO_REPLY;
    516              }
    517            }
    518          
    519            /* if we get here the token matched. */
    520          
    521            /* is this a duplicate request? */
    522            remotePort = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_RMT_PORT_OS);
   \   00007C   E5..         MOV     A,?V0 + 0
   \   00007E   2415         ADD     A,#0x15
   \   000080   F582         MOV     DPL,A
   \   000082   E5..         MOV     A,?V0 + 1
   \   000084   3400         ADDC    A,#0x0
   \   000086   F583         MOV     DPH,A
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F5..         MOV     ?V0 + 8,A
    523            if (pCInfo=nwk_isLinkDuplicate(MRFI_P_SRC_ADDR(frame), remotePort))
   \   00008B   E5..         MOV     A,?V0 + 0
   \   00008D   2408         ADD     A,#0x8
   \   00008F   F5..         MOV     ?V0 + 4,A
   \   000091   E5..         MOV     A,?V0 + 1
   \   000093   3400         ADDC    A,#0x0
   \   000095   F5..         MOV     ?V0 + 5,A
   \   000097                ; Setup parameters for call to function nwk_isLinkDuplicate
   \   000097   A9..         MOV     R1,?V0 + 8
   \   000099   AA..         MOV     R2,?V0 + 4
   \   00009B   FB           MOV     R3,A
   \   00009C   12....       LCALL   ??nwk_isLinkDuplicate?relay
   \   00009F   8A..         MOV     ?V0 + 2,R2
   \   0000A1   8B..         MOV     ?V0 + 3,R3
   \   0000A3   A8..         MOV     R0,?V0 + 2
   \   0000A5   A9..         MOV     R1,?V0 + 3
   \   0000A7   E8           MOV     A,R0
   \   0000A8   FE           MOV     R6,A
   \   0000A9   E9           MOV     A,R1
   \   0000AA   FF           MOV     R7,A
   \   0000AB   E5..         MOV     A,?V0 + 0
   \   0000AD   240D         ADD     A,#0xd
   \   0000AF   F5..         MOV     ?V0 + 6,A
   \   0000B1   E5..         MOV     A,?V0 + 1
   \   0000B3   3400         ADDC    A,#0x0
   \   0000B5   F5..         MOV     ?V0 + 7,A
   \   0000B7   E5..         MOV     A,?V0 + 0
   \   0000B9   2410         ADD     A,#0x10
   \   0000BB   F5..         MOV     ?V0 + 2,A
   \   0000BD   E5..         MOV     A,?V0 + 1
   \   0000BF   3400         ADDC    A,#0x0
   \   0000C1   F5..         MOV     ?V0 + 3,A
   \   0000C3   E8           MOV     A,R0
   \   0000C4   49           ORL     A,R1
   \   0000C5   6046         JZ      ??smpl_send_link_reply_3
    524            {
    525              /* resend reply */
    526              msg[LB_REQ_OS] = LINK_REQ_LINK | NWK_APP_REPLY_BIT;
   \   0000C7   12....       LCALL   ?Subroutine6 & 0xFFFF
    527          
    528              /* sender's TID */
    529              msg[LB_TID_OS] = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+LB_TID_OS);
   \                     ??CrossCallReturnLabel_6:
   \   0000CA   C0E0         PUSH    A
   \   0000CC   7401         MOV     A,#0x1
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   D0E0         POP     A
   \   0000D3   12....       LCALL   ?Subroutine4 & 0xFFFF
    530          
    531              /* Send reply with the local port number so the remote device knows where to
    532               * send packets.
    533               */
    534              msg[LR_RMT_PORT_OS] = pCInfo->portRx;
   \                     ??CrossCallReturnLabel_4:
   \   0000D6   C0E0         PUSH    A
   \   0000D8   7402         MOV     A,#0x2
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   D0E0         POP     A
   \   0000DF   F0           MOVX    @DPTR,A
    535          
    536              /* put my Rx type in there. used to know how to set hops when sending back. */
    537              msg[LR_MY_RXTYPE_OS] = nwk_getMyRxType();
   \   0000E0                ; Setup parameters for call to function nwk_getMyRxType
   \   0000E0   12....       LCALL   ??nwk_getMyRxType?relay
   \   0000E3   7403         MOV     A,#0x3
   \   0000E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E8   E9           MOV     A,R1
   \   0000E9   12....       LCALL   ?Subroutine2 & 0xFFFF
    538          #if defined(SMPL_SECURE)
    539              /* Set the Tx counter value for peer's Rx counter object */
    540              nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[LR_CTR_OS], 4);
    541              /* We also need to save the newly generated Rx counter value. */
    542              nwk_getNumObjectFromMsg((void *)(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_CTR_OS), (void *)&pCInfo->connRxCTR, 4);
    543          #endif
    544              if (pOutFrame = nwk_buildFrame(SMPL_PORT_LINK, msg, sizeof(msg), MAX_HOPS-(GET_FROM_FRAME(MRFI_P_PAYLOAD(frame),F_HOP_COUNT))))
   \                     ??CrossCallReturnLabel_0:
   \   0000EC   601A         JZ      ??smpl_send_link_reply_4
    545              {
    546                /* destination address is the source adddress of the received frame. */
    547                memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
   \   0000EE                ; Setup parameters for call to function memcpy
   \   0000EE   75..04       MOV     ?V0 + 2,#0x4
   \   0000F1   75..00       MOV     ?V0 + 3,#0x0
   \   0000F4   78..         MOV     R0,#?V0 + 2
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0000FC   12....       LCALL   ?DEALLOC_XSTACK8
    548          #if defined(SMPL_SECURE)
    549                nwk_setSecureFrame(&pOutFrame->mrfiPkt, sizeof(msg), 0);
    550          #endif  /* SMPL_SECURE */
    551                nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
   \   0000FF                ; Setup parameters for call to function nwk_sendFrame
   \   0000FF   7900         MOV     R1,#0x0
   \   000101   AA..         MOV     R2,?V0 + 0
   \   000103   AB..         MOV     R3,?V0 + 1
   \   000105   12....       LCALL   ??nwk_sendFrame?relay
    552              }
    553              return SENT_REPLY;
   \                     ??smpl_send_link_reply_4:
   \   000108   7901         MOV     R1,#0x1
   \   00010A   02....       LJMP    ??smpl_send_link_reply_2 & 0xFFFF
    554            }
    555          
    556            if (!sListenActive)
   \                     ??smpl_send_link_reply_3:
   \   00010D   90....       MOV     DPTR,#sListenActive
   \   000110   E0           MOVX    A,@DPTR
   \   000111   7003         JNZ     $+5
   \   000113   02....       LJMP    ??smpl_send_link_reply_1 & 0xFFFF
    557            {
    558              /* We've checked for duplicate and resent reply. In that case we weren't listening
    559               * so just go back`.
    560               */
    561              return SENT_NO_REPLY;
    562            }
    563          
    564            /* room to link? */
    565          #if defined(AP_IS_DATA_HUB)
    566            pCInfo = nwk_findAlreadyJoined(frame);
    567          
    568            if (!pCInfo)
    569          #endif
    570            {
    571              pCInfo = nwk_getNextConnection();
   \   000116                ; Setup parameters for call to function nwk_getNextConnection
   \   000116   12....       LCALL   ??nwk_getNextConnection?relay
   \   000119   8A..         MOV     ?V0 + 10,R2
   \   00011B   8B..         MOV     ?V0 + 11,R3
   \   00011D   AE..         MOV     R6,?V0 + 10
   \   00011F   AF..         MOV     R7,?V0 + 11
    572            }
    573          
    574            if (pCInfo)
   \   000121   EE           MOV     A,R6
   \   000122   4F           ORL     A,R7
   \   000123   60E3         JZ      ??smpl_send_link_reply_4
    575            {
    576              /* yes there's room and it's not a dup. address. */
    577              memcpy(&pCInfo->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
   \   000125                ; Setup parameters for call to function memcpy
   \   000125   75..04       MOV     ?V0 + 10,#0x4
   \   000128   75..00       MOV     ?V0 + 11,#0x0
   \   00012B   78..         MOV     R0,#?V0 + 10
   \   00012D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000130   AC..         MOV     R4,?V0 + 4
   \   000132   AD..         MOV     R5,?V0 + 5
   \   000134   EE           MOV     A,R6
   \   000135   2402         ADD     A,#0x2
   \   000137   0A           INC     R2
   \   000138   0A           INC     R2
   \   000139   EF           MOV     A,R7
   \   00013A   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00013D   12....       LCALL   ?DEALLOC_XSTACK8
    578          
    579              if (!nwk_allocateLocalRxPort(LINK_REPLY, pCInfo))
   \   000140                ; Setup parameters for call to function nwk_allocateLocalRxPort
   \   000140   EE           MOV     A,R6
   \   000141   FA           MOV     R2,A
   \   000142   EF           MOV     A,R7
   \   000143   FB           MOV     R3,A
   \   000144   7902         MOV     R1,#0x2
   \   000146   12....       LCALL   ??nwk_allocateLocalRxPort?relay
   \   000149   E9           MOV     A,R1
   \   00014A   7009         JNZ     ??smpl_send_link_reply_5
    580              {
    581                nwk_freeConnection(pCInfo);
   \                     ??smpl_send_link_reply_6:
   \   00014C                ; Setup parameters for call to function nwk_freeConnection
   \   00014C   EE           MOV     A,R6
   \   00014D   FA           MOV     R2,A
   \   00014E   EF           MOV     A,R7
   \   00014F   FB           MOV     R3,A
   \   000150   12....       LCALL   ??nwk_freeConnection?relay
   \   000153   80B3         SJMP    ??smpl_send_link_reply_4
    582                /* we're done with the packet */
    583                return SENT_REPLY;
    584              }
    585          
    586              /* The local Rx port is the one returned in the connection structure. The
    587               * caller is waiting on this to be set. The code here is running in an ISR
    588               * thread so the caller will see this change after RETI.
    589               */
    590              if (NUM_CONNECTIONS == sNumLinkers)
   \                     ??smpl_send_link_reply_5:
   \   000155   90....       MOV     DPTR,#sNumLinkers
   \   000158   E0           MOVX    A,@DPTR
   \   000159   6402         XRL     A,#0x2
   \   00015B   60EF         JZ      ??smpl_send_link_reply_6
    591              {
    592                /* Something is wrong -- no room to stack Link request */
    593                nwk_freeConnection(pCInfo);
    594                /* we're done with the packet */
    595                return SENT_REPLY;
    596              }
    597              sServiceLinkID[sNumLinkers++] = pCInfo->thisLinkID;
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   F5..         MOV     ?V0 + 10,A
   \   000160   7401         MOV     A,#0x1
   \   000162   25..         ADD     A,?V0 + 10
   \   000164   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000167   C0E0         PUSH    A
   \   000169   74..         MOV     A,#sServiceLinkID & 0xff
   \   00016B   25..         ADD     A,?V0 + 10
   \   00016D   F582         MOV     DPL,A
   \   00016F   74..         MOV     A,#(sServiceLinkID >> 8) & 0xff
   \   000171   3400         ADDC    A,#0x0
   \   000173   F583         MOV     DPH,A
   \   000175   D0E0         POP     A
   \   000177   12....       LCALL   ?Subroutine7 & 0xFFFF
    598          
    599              /* save the remote Tx port */
    600              pCInfo->portTx = remotePort;
   \                     ??CrossCallReturnLabel_8:
   \   00017A   E5..         MOV     A,?V0 + 8
   \   00017C   F0           MOVX    @DPTR,A
    601          
    602              /* connection is valid... */
    603              pCInfo->connState = CONNSTATE_CONNECTED;
   \   00017D   8E82         MOV     DPL,R6
   \   00017F   8F83         MOV     DPH,R7
   \   000181   7402         MOV     A,#0x2
   \   000183   F0           MOVX    @DPTR,A
    604          
    605              /* Set hop count. If it's a polling device set the count to the
    606               * distance to the AP. otherwise, set it to the max less the remaining
    607               * which will be the path taken for this frame. It will be no worse
    608               * then tha max and probably will be better.
    609               */
    610              if (F_RX_TYPE_POLLS == *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_MY_RXTYPE_OS))
   \   000184   A3           INC     DPTR
   \   000185   A882         MOV     R0,DPL
   \   000187   A983         MOV     R1,DPH
   \   000189   E5..         MOV     A,?V0 + 0
   \   00018B   2416         ADD     A,#0x16
   \   00018D   F582         MOV     DPL,A
   \   00018F   E5..         MOV     A,?V0 + 1
   \   000191   3400         ADDC    A,#0x0
   \   000193   F583         MOV     DPH,A
   \   000195   E0           MOVX    A,@DPTR
   \   000196   6440         XRL     A,#0x40
   \   000198   8882         MOV     DPL,R0
   \   00019A   8983         MOV     DPH,R1
   \   00019C   7004         JNZ     ??smpl_send_link_reply_7
    611              {
    612                /* It polls. so. we'll be sending to the AP which will store the
    613                 * frame. The AP is only MAX_HOPS_FROM_AP hops away from us.
    614                 */
    615                pCInfo->hops2target = MAX_HOPS_FROM_AP;
   \   00019E   7401         MOV     A,#0x1
   \   0001A0   8002         SJMP    ??smpl_send_link_reply_8
    616              }
    617              else
    618              {
    619                /* Can't really use this trick because the device could move. If the
    620                 * devices are all static this may work unless the initial reception
    621                 * was marginal.
    622                 */
    623          #if defined(DEVICE_DOES_NOT_MOVE)
    624                pCInfo->hops2target = MAX_HOPS - GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_HOP_COUNT);
    625          #else
    626                pCInfo->hops2target = MAX_HOPS;
   \                     ??smpl_send_link_reply_7:
   \   0001A2   7403         MOV     A,#0x3
    627          #endif
    628              }
   \                     ??smpl_send_link_reply_8:
   \   0001A4   12....       LCALL   ?Subroutine4 & 0xFFFF
    629              /* Send reply with the local port number so the remote device knows where to
    630               * send packets.
    631               */
    632              msg[LR_RMT_PORT_OS]  = pCInfo->portRx;
   \                     ??CrossCallReturnLabel_5:
   \   0001A7   C0E0         PUSH    A
   \   0001A9   7402         MOV     A,#0x2
   \   0001AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AE   D0E0         POP     A
   \   0001B0   F0           MOVX    @DPTR,A
    633          
    634              /* put my Rx type in there. used to know how to set hops when sending back. */
    635              msg[LR_MY_RXTYPE_OS] = nwk_getMyRxType();
   \   0001B1                ; Setup parameters for call to function nwk_getMyRxType
   \   0001B1   12....       LCALL   ??nwk_getMyRxType?relay
   \   0001B4   7403         MOV     A,#0x3
   \   0001B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B9   E9           MOV     A,R1
   \   0001BA   F0           MOVX    @DPTR,A
    636          
    637              msg[LB_REQ_OS] = LINK_REQ_LINK | NWK_APP_REPLY_BIT;
   \   0001BB   12....       LCALL   ?Subroutine6 & 0xFFFF
    638          
    639              /* sender's TID */
    640              msg[LB_TID_OS] = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+LB_TID_OS);
   \                     ??CrossCallReturnLabel_7:
   \   0001BE   C0E0         PUSH    A
   \   0001C0   7401         MOV     A,#0x1
   \   0001C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C5   D0E0         POP     A
   \   0001C7   12....       LCALL   ?Subroutine2 & 0xFFFF
    641          #if defined(SMPL_SECURE)
    642              nwk_getNumObjectFromMsg((void *)(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_CTR_OS), (void *)&pCInfo->connRxCTR, 4);
    643              pCInfo->connTxCTR = MRFI_RandomByte()                   | \
    644                                  ((uint32_t)(MRFI_RandomByte())<<8)  | \
    645                                  ((uint32_t)(MRFI_RandomByte())<<16) | \
    646                                  ((uint32_t)(MRFI_RandomByte())<<24);
    647          
    648              nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[LR_CTR_OS], 4);
    649          #endif
    650              if (pOutFrame = nwk_buildFrame(SMPL_PORT_LINK, msg, sizeof(msg), MAX_HOPS-(GET_FROM_FRAME(MRFI_P_PAYLOAD(frame),F_HOP_COUNT))))
   \                     ??CrossCallReturnLabel_1:
   \   0001CA   6080         JZ      ??smpl_send_link_reply_6
    651              {
    652                /* destination address is the source adddress of the received frame. */
    653                memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
   \   0001CC                ; Setup parameters for call to function memcpy
   \   0001CC   75..04       MOV     ?V0 + 2,#0x4
   \   0001CF   75..00       MOV     ?V0 + 3,#0x0
   \   0001D2   78..         MOV     R0,#?V0 + 2
   \   0001D4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001D7   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   0001DA   12....       LCALL   ?DEALLOC_XSTACK8
    654          #if defined(SMPL_SECURE)
    655                nwk_setSecureFrame(&pOutFrame->mrfiPkt, sizeof(msg), 0);
    656          #endif
    657                if (SMPL_SUCCESS != nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED))
   \   0001DD                ; Setup parameters for call to function nwk_sendFrame
   \   0001DD   7900         MOV     R1,#0x0
   \   0001DF   AA..         MOV     R2,?V0 + 0
   \   0001E1   AB..         MOV     R3,?V0 + 1
   \   0001E3   12....       LCALL   ??nwk_sendFrame?relay
   \   0001E6   E9           MOV     A,R1
   \   0001E7   6003         JZ      $+5
   \   0001E9   02....       LJMP    ??smpl_send_link_reply_6 & 0xFFFF
   \   0001EC   02....       LJMP    ??smpl_send_link_reply_4 & 0xFFFF
    658                {
    659                  /* better release the connection structure */
    660                  nwk_freeConnection(pCInfo);
    661                }
    662              }
    663              else
    664              {
    665                /* better release the connection structure */
    666                nwk_freeConnection(pCInfo);
    667              }
    668            }
    669            /* we're done with the packet */
    670            return SENT_REPLY;
    671          #else
    672            return SENT_NO_REPLY;
    673          #endif  /* NUM_CONNECTIONS */
    674          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   7481         MOV     A,#-0x7f
   \   000008   F0           MOVX    @DPTR,A
   \   000009   85..82       MOV     DPL,?V0 + 2
   \   00000C   85..83       MOV     DPH,?V0 + 3
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   AC..         MOV     R4,?V0 + 4
   \   000002   AD..         MOV     R5,?V0 + 5
   \   000004   EA           MOV     A,R2
   \   000005   2406         ADD     A,#0x6
   \   000007   FA           MOV     R2,A
   \   000008   E9           MOV     A,R1
   \   000009                REQUIRE ??Subroutine10_0
   \   000009                ; // Fall through to label ??Subroutine10_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FB           MOV     R3,A
   \   000003                REQUIRE ??Subroutine11_0
   \   000003                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function nwk_buildFrame
   \   000001                ; Setup parameters for call to function nwk_buildFrame
   \   000001   85..82       MOV     DPL,?V0 + 6
   \   000004   85..83       MOV     DPH,?V0 + 7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   5407         ANL     A,#0x7
   \   00000A   F8           MOV     R0,A
   \   00000B   7403         MOV     A,#0x3
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   FD           MOV     R5,A
   \   000010   7C04         MOV     R4,#0x4
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   7902         MOV     R1,#0x2
   \   00001E   12....       LCALL   ??nwk_buildFrame?relay
   \   000021   8A..         MOV     ?V0 + 0,R2
   \   000023   8B..         MOV     ?V0 + 1,R3
   \   000025   A9..         MOV     R1,?V0 + 1
   \   000027   EA           MOV     A,R2
   \   000028   49           ORL     A,R1
   \   000029   22           RET
    675          
    676          /******************************************************************************
    677           * @fn          nwk_processLink
    678           *
    679           * @brief       Process Link frame. Just save the frame for the Link app if it
    680           *              a reply. If it isn't a reply, send the reply in this thread.
    681           *
    682           * input parameters
    683           * @param   frame   - pointer to frame to be processed
    684           *
    685           * output parameters
    686           *
    687           * @return   Keep frame for application, release frame, or replay frame..
    688           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    689          fhStatus_t nwk_processLink(mrfiPacket_t *frame)
   \                     nwk_processLink:
    690          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    691            fhStatus_t   rc;
    692            uint8_t      replyType;
    693          
    694            /* If we sent this then this is the reply. Validate the
    695             * packet for reception by client app. If we didn't send
    696             * it then we are the target. send the reply.
    697             */
    698            if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, LB_REQ_OS, LB_TID_OS)))
   \   000009                ; Setup parameters for call to function nwk_isValidReply
   \   000009   7D01         MOV     R5,#0x1
   \   00000B   7C00         MOV     R4,#0x0
   \   00000D   90....       MOV     DPTR,#sTid
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   12....       LCALL   ??nwk_isValidReply?relay
   \   000015   E9           MOV     A,R1
   \   000016   7007         JNZ     ??nwk_processLink_0
    699            {
    700              /* It's a match and it's a reply. Validate the received packet by
    701               * returning a 1 so it can be received by the client app.
    702               */
    703              MRFI_PostKillSem();
   \   000018                ; Setup parameters for call to function MRFI_PostKillSem
   \   000018   12....       LCALL   ??MRFI_PostKillSem?relay
    704              rc = FHS_KEEP;
   \   00001B   7901         MOV     R1,#0x1
   \   00001D   8033         SJMP    ??nwk_processLink_1
    705            }
    706          #if !defined( END_DEVICE )
    707            else if (SMPL_A_REPLY == replyType)
    708            {
    709              /* no match. if i'm not an ED this is a reply that should be passed on. */
    710              rc = FHS_REPLAY;
    711            }
    712          #endif  /* !END_DEVICE */
    713            else
    714            {
    715              /* No, we didn't send it. Process request assuming it's
    716               * intended for us.
    717               */
    718              rc = handleLinkRequest(frame);
   \                     ??nwk_processLink_0:
   \   00001F   EE           MOV     A,R6
   \   000020   240F         ADD     A,#0xf
   \   000022   F8           MOV     R0,A
   \   000023   EF           MOV     A,R7
   \   000024   3400         ADDC    A,#0x0
   \   000026   F9           MOV     R1,A
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   24F2         ADD     A,#-0xe
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   34FF         ADDC    A,#-0x1
   \   000032   FB           MOV     R3,A
   \   000033   7408         MOV     A,#0x8
   \   000035   6A           XRL     A,R2
   \   000036   7001         JNZ     ??nwk_processLink_2
   \   000038   EB           MOV     A,R3
   \                     ??nwk_processLink_2:
   \   000039   8882         MOV     DPL,R0
   \   00003B   8983         MOV     DPH,R1
   \   00003D   7005         JNZ     ??nwk_processLink_3
   \   00003F   7401         MOV     A,#0x1
   \   000041   F0           MOVX    @DPTR,A
   \   000042   8005         SJMP    ??nwk_processLink_4
   \                     ??nwk_processLink_3:
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6401         XRL     A,#0x1
   \   000047   7007         JNZ     ??nwk_processLink_5
   \                     ??nwk_processLink_4:
   \   000049                ; Setup parameters for call to function smpl_send_link_reply
   \   000049   EE           MOV     A,R6
   \   00004A   FA           MOV     R2,A
   \   00004B   EF           MOV     A,R7
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   ??smpl_send_link_reply?relay
    719            }
   \                     ??nwk_processLink_5:
   \   000050   7900         MOV     R1,#0x0
    720          
    721            (void) replyType;  /* keep compiler happy when ED built... */
    722          
    723            return rc;
   \                     ??nwk_processLink_1:
   \   000052   02....       LJMP    ?Subroutine1 & 0xFFFF
    724          }
    725          
    726          /******************************************************************************
    727           * @fn          nwk_getLocalLinkID
    728           *
    729           * @brief       This routine checks to see if a service port has been assigned
    730           *              as a result of a link reply frame being received. It is the means
    731           *              by which the user thread knows that the waiting is over for the
    732           *              link listen. the value is set in an interrupt thread.
    733           *
    734           * input parameters
    735           *
    736           * output parameters
    737           *
    738           * @return   Local port assigned when the link reply was received.
    739           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    740          linkID_t nwk_getLocalLinkID(void)
   \                     nwk_getLocalLinkID:
    741          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    742            linkID_t    lid = 0;
   \   000005   7900         MOV     R1,#0x0
    743          #if NUM_CONNECTIONS > 0
    744            uint8_t     i;
    745            bspIState_t intState;
    746          
    747          
    748            BSP_ENTER_CRITICAL_SECTION(intState);
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   F8           MOV     R0,A
   \   00000C   C2AF         CLR     0xa8.7
    749            if (sNumLinkers)
   \   00000E   90....       MOV     DPTR,#sNumLinkers
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6039         JZ      ??nwk_getLocalLinkID_0
    750            {
    751              sNumLinkers--;
   \   000014   E0           MOVX    A,@DPTR
   \   000015   14           DEC     A
   \   000016   F0           MOVX    @DPTR,A
    752              BSP_EXIT_CRITICAL_SECTION(intState);
   \   000017   E8           MOV     A,R0
   \   000018   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001A   92AF         MOV     0xa8.7,C
   \   00001C   E5A8         MOV     A,0xa8
    753          
    754              nwk_setListenContext(LINK_LISTEN_OFF);
   \   00001E                ; Setup parameters for call to function nwk_setListenContext
   \   00001E   09           INC     R1
   \   00001F   12....       LCALL   ??nwk_setListenContext?relay
    755              lid = sServiceLinkID[0];
   \   000022   90....       MOV     DPTR,#sServiceLinkID
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
    756              /* If more than one Link frame has been processed without an intervening
    757               * Listen assume that there will be another Link Listen call that will
    758               * poll for completion which has already occurred. Age any existing entries.
    759               * This code was added to deal with the possibility of mulitple EDs being
    760               * activated simultaneously in the AP-as-data-hub example. This opens a
    761               * window of opportunity for a "typical" scenario to get hosed. But for
    762               * a "typical" scenario to get hosed a number of improbable events have to
    763               * occur. These are deemed far less likely than the multiple-ED-activation
    764               * scenario in the AP-as-dat-hub case.
    765               */
    766              for (i=0; i<sNumLinkers; ++i)
   \   000027   7800         MOV     R0,#0x0
   \                     ??nwk_getLocalLinkID_1:
   \   000029   90....       MOV     DPTR,#sNumLinkers
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   FA           MOV     R2,A
   \   00002E   E8           MOV     A,R0
   \   00002F   C3           CLR     C
   \   000030   9A           SUBB    A,R2
   \   000031   5021         JNC     ??nwk_getLocalLinkID_2
    767              {
    768                sServiceLinkID[i] = sServiceLinkID[i+1];
   \   000033   88..         MOV     ?V0 + 0,R0
   \   000035   74..         MOV     A,#sServiceLinkID & 0xff
   \   000037   25..         ADD     A,?V0 + 0
   \   000039   FA           MOV     R2,A
   \   00003A   74..         MOV     A,#(sServiceLinkID >> 8) & 0xff
   \   00003C   3400         ADDC    A,#0x0
   \   00003E   FB           MOV     R3,A
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   F0           MOVX    @DPTR,A
    769              }
   \   00004A   08           INC     R0
   \   00004B   80DC         SJMP    ??nwk_getLocalLinkID_1
    770            }
    771            else
    772            {
    773              BSP_EXIT_CRITICAL_SECTION(intState);
   \                     ??nwk_getLocalLinkID_0:
   \   00004D   E8           MOV     A,R0
   \   00004E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000050   92AF         MOV     0xa8.7,C
   \   000052   E5A8         MOV     A,0xa8
    774            }
    775          #endif  /* NUM_CONNECTIONS */
    776          
    777            return lid;
   \                     ??nwk_getLocalLinkID_2:
   \   000054   7F02         MOV     R7,#0x2
   \   000056   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000059                REQUIRE _A_IEN0
    778          }
    779          
    780          /******************************************************************************
    781           * @fn          nwk_setListenContext
    782           *
    783           * @brief       Sets the context when a LinkListen is executed. This prevents
    784           *              processing other link frames from being confused with the real
    785           *              one. Without this semaphore other broadcast link messages
    786           *              could wait int the input queue and accidently be processed if
    787           *              a listen is done later.
    788           *
    789           * input parameters
    790           *
    791           * @param   context - listen on or off
    792           *
    793           * output parameters
    794           *
    795           * @return   void
    796           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    797          void nwk_setListenContext(uint8_t context)
   \                     nwk_setListenContext:
    798          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    799            sListenActive = (context == LINK_LISTEN_ON) ? 1 : 0;
   \   000004   E9           MOV     A,R1
   \   000005   7004         JNZ     ??nwk_setListenContext_0
   \   000007   7401         MOV     A,#0x1
   \   000009   8001         SJMP    ??nwk_setListenContext_1
   \                     ??nwk_setListenContext_0:
   \   00000B   E4           CLR     A
   \                     ??nwk_setListenContext_1:
   \   00000C   90....       MOV     DPTR,#sListenActive
   \   00000F   F0           MOVX    @DPTR,A
    800          }
   \   000010   D083         POP     DPH
   \   000012   D082         POP     DPL
   \   000014   02....       LJMP    ?BRET

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_1020304:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_1020304>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_1020304>`:
   \   000000   04030201     DD 16909060

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_linkInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_linkInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_setLinkToken?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_setLinkToken

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_getLinkToken?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_getLinkToken

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_link?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_link

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??smpl_send_link_reply?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    smpl_send_link_reply

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_processLink?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_processLink

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_getLocalLinkID?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_getLocalLinkID

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_setListenContext?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_setListenContext
    801          
    802          /******************************************************************************
    803           * @fn          handleLinkRequest
    804           *
    805           * @brief       Dispatches handler for specfic link request
    806           *
    807           * input parameters
    808           *
    809           * @param   frame - Link frame received
    810           *
    811           * output parameters
    812           *
    813           * @return   void
    814           */
    815          static fhStatus_t handleLinkRequest(mrfiPacket_t *frame)
    816          {
    817            fhStatus_t rc = FHS_RELEASE;
    818            uint8_t    isReplySent;
    819          
    820            if (LINK_LEGACY_MSG_LENGTH == (MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS))
    821            {
    822              /* Legacy frame. Spoof a link request */
    823              *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS) = LINK_REQ_LINK;
    824            }
    825          
    826            switch (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS))
    827            {
    828              case LINK_REQ_LINK:
    829                isReplySent = smpl_send_link_reply(frame);
    830          #if !defined(END_DEVICE)
    831                /* If I am an AP or RE and not listening I need to replay frame.
    832                 * The exception is if I am an AP or RE hosting an End Device
    833                 * object and I just sent a reply frame to a duplicate link frame
    834                 * for which I was not listening. In this case don't replay.
    835                 */
    836                if (!sListenActive && (SENT_REPLY != isReplySent))
    837                {
    838                  rc = FHS_REPLAY;
    839                }
    840          #endif   /* !END_DEVICE */
    841                break;
    842          
    843          #if defined(EXTENDED_API)
    844              case LINK_REQ_UNLINK:
    845                smpl_send_unlink_reply(frame);
    846                break;
    847          #endif
    848          
    849              default:
    850                break;
    851            }
    852          
    853            /* keep compiler happy if I'm compiled as an End Device */
    854            (void) isReplySent;
    855          
    856            return rc;
    857          }

   Maximum stack usage in bytes:

     Function                     ISTACK PSTACK XSTACK
     --------                     ------ ------ ------
     nwk_getLinkToken                 0      0      9
     nwk_getLocalLinkID               1      0     10
       -> nwk_setListenContext        0      0     20
     nwk_link                         1      0     34
       -> nwk_getNextConnection       0      0     64
       -> nwk_allocateLocalRxPort     0      0     64
       -> nwk_freeConnection          0      0     64
       -> nwk_getBCastAddress         0      0     68
       -> memcpy                      0      0     68
       -> nwk_putNumObjectIntoMsg     0      0     64
       -> nwk_getMyRxType             0      0     64
       -> nwk_getProtocolVersion      0      0     64
       -> SMPL_Ioctl                  0      0     64
       -> nwk_freeConnection          0      0     64
       -> MRFI_GetRadioState          0      0     64
       -> MRFI_WakeUp                 0      0     64
       -> MRFI_RxOn                   0      0     64
       -> MRFI_ReplyDelay             0      0     64
       -> MRFI_Sleep                  0      0     64
       -> MRFI_RxIdle                 0      0     64
       -> SMPL_Ioctl                  0      0     64
       -> nwk_freeConnection          0      0     64
       -> nwk_freeConnection          0      0     64
     nwk_linkInit                     0      0     14
       -> MRFI_RandomByte             0      0     24
       -> memset                      0      0     28
     nwk_processLink                  0      0      9
       -> nwk_isValidReply            0      0     18
       -> MRFI_PostKillSem            0      0     18
       -> smpl_send_link_reply        0      0     18
     nwk_setLinkToken                 0      0     12
     nwk_setListenContext             2      0     10
     smpl_send_link_reply             2      0     39
       -> nwk_getProtocolVersion      0      0     56
       -> nwk_getNumObjectFromMsg     0      0     56
       -> nwk_isLinkDuplicate         0      0     56
       -> nwk_getMyRxType             0      0     56
       -> nwk_buildFrame              0      0     56
       -> memcpy                      0      0     60
       -> nwk_sendFrame               0      0     56
       -> nwk_getNextConnection       0      0     56
       -> memcpy                      0      0     60
       -> nwk_allocateLocalRxPort     0      0     56
       -> nwk_freeConnection          0      0     56
       -> nwk_getMyRxType             0      0     56
       -> nwk_buildFrame              0      0     56
       -> memcpy                      0      0     60
       -> nwk_sendFrame               0      0     56


   Segment part sizes:

     Function/Label                        Bytes
     --------------                        -----
     _A_IEN0                                  1
     sLinkToken                               4
     sListenActive                            1
     sServiceLinkID                           2
     sNumLinkers                              1
     sTid                                     1
     nwk_linkInit                            69
     ?Subroutine0                             3
     ??Subroutine9_0                          5
     nwk_setLinkToken                        32
     nwk_getLinkToken                        26
     ?Subroutine1                             5
     nwk_link                               498
     ??Subroutine11_0                         6
     ?Subroutine3                             6
     ?Subroutine7                             5
     ?Subroutine8                            14
     smpl_send_link_reply                   495
     ?Subroutine6                            17
     ?Subroutine5                             9
     ??Subroutine10_0                         3
     ?Subroutine4                             5
     ?Subroutine2                            42
     nwk_processLink                         85
     nwk_getLocalLinkID                      89
     nwk_setListenContext                    23
     __Constant_1020304                       4
     ?<Initializer for __Constant_1020304>    4
     ??nwk_linkInit?relay                     6
     ??nwk_setLinkToken?relay                 6
     ??nwk_getLinkToken?relay                 6
     ??nwk_link?relay                         6
     ??smpl_send_link_reply?relay             6
     ??nwk_processLink?relay                  6
     ??nwk_getLocalLinkID?relay               6
     ??nwk_setListenContext?relay             6

 
 1 437 bytes in segment BANKED_CODE
    48 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
     4 bytes in segment XDATA_I
     4 bytes in segment XDATA_ID
     9 bytes in segment XDATA_Z
 
 1 485 bytes of CODE  memory (+ 4 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
     9 bytes of XDATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
