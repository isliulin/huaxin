///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.4.40412/W32 for 8051        22/Jul/2016  22:50:18 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Components\bsp\drivers\cod /
//                          e\uart_intfc.c                                    /
//    Command line       =  -f C:\Users\freeman\Documents\work\NBK\Nikon\Niko /
//                          n_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05 /
//                          _8051\nik_sb5000\IAR\Configuration\LinkTo\smpl_co /
//                          nfig.dat ("-DTHIS_DEVICE_ADDRESS={0x79, 0x56,     /
//                          0x34, 0x12}" -DxNWK_PLL_REFERENCE_CLOCK           /
//                          -DLINK_TO) -f C:\Users\freeman\Documents\work\NBK /
//                          \Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exa /
//                          mples\SRF05_8051\nik_sb5000\IAR\Configuration\smp /
//                          l_nwk_config.dat (-DMAX_HOPS=3                    /
//                          -DMAX_HOPS_FROM_AP=1 -DMAX_NWK_PAYLOAD=34         /
//                          -DMAX_APP_PAYLOAD=10 -DDEFAULT_LINK_TOKEN=0x01020 /
//                          304 -DDEFAULT_JOIN_TOKEN=0x05060708               /
//                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK              /
//                          -DxEXTENDED_API -DxSMPL_SECURE                    /
//                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                   /
//                          -DNUM_CONNECTIONS=2 -DSIZE_INFRAME_Q=4            /
//                          -DSIZE_OUTFRAME_Q=2 -DxFREQUENCY_HOPPING          /
//                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                /
//                          -DUART_NUMBER=UART_NUMBER_0                       /
//                          -DUART_LOCATION=UART_LOCATION_1                   /
//                          -DUART_BAUD_RATE=115200                           /
//                          -DUART_FLOW_CONTROL=UART_FLOW_CONTROL_OFF         /
//                          -DUART_PARITY_MODE=UART_PARITY_NONE               /
//                          -DUART_STOP_BITS=UART_1_STOP_BIT                  /
//                          -DBSP_TIMER_USED=1 -DEND_DEVICE)                  /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Components\bsp\drivers\cod /
//                          e\uart_intfc.c -D MCU_H=<ioCC2530.h> -D           /
//                          MRFI_CC2530 -D ZTOOL_P1 -D MRFI_PA_LNA_ENABLED    /
//                          -lC C:\Users\freeman\Documents\work\NBK\Nikon\Nik /
//                          on_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF0 /
//                          5_8051\nik_sb5000\IAR\LinkTo\List\ -lA            /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\ -o                 /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\Obj\ -e --debug          /
//                          --core=plain --dptr=16,1 --data_model=large       /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data --nr_virtual_regs  /
//                          16 -I C:\Users\freeman\Documents\work\NBK\Nikon\N /
//                          ikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SR /
//                          F05_8051\nik_sb5000\IAR\..\..\..\..\..\Components /
//                          \bsp\ -I C:\Users\freeman\Documents\work\NBK\Niko /
//                          n\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples /
//                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compone /
//                          nts\bsp\drivers\ -I C:\Users\freeman\Documents\wo /
//                          rk\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. /
//                          \..\Components\bsp\boards\CC2530EM\ -I            /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\mrfi\ /
//                           -I C:\Users\freeman\Documents\work\NBK\Nikon\Nik /
//                          on_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF0 /
//                          5_8051\nik_sb5000\IAR\..\..\..\..\..\Components\S /
//                          impliciTI\nwk\ -I C:\Users\freeman\Documents\work /
//                          \NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects /
//                          \Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\Appl /
//                          ications\ -I C:\Users\freeman\Documents\work\NBK\ /
//                          Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exam /
//                          ples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Com /
//                          ponents\SimpliciTI\nwk_applications\ -I           /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\OSAL\ /
//                          INCLUDE\ -I C:\Users\freeman\Documents\work\NBK\N /
//                          ikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp /
//                          les\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Comp /
//                          onents\OSAL\MCU\CCSOC\ -I                         /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\HAL\I /
//                          NCLUDE\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\HAL\TARGET\CC2530EB\ -I                     /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\SERVI /
//                          CES\SADDR\ -I C:\Users\freeman\Documents\work\NBK /
//                          \Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exa /
//                          mples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Co /
//                          mponents\SERVICES\SDATA\ -I                       /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MT\   /
//                          -I C:\Users\freeman\Documents\work\NBK\Nikon\Niko /
//                          n_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05 /
//                          _8051\nik_sb5000\IAR\..\..\..\..\..\Components\ST /
//                          ACK\AF\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\STACK\NWK\ -I C:\Users\freeman\Documents\wo /
//                          rk\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. /
//                          \..\Components\STACK\SEC\ -I                      /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\STACK /
//                          \SAPI\ -I C:\Users\freeman\Documents\work\NBK\Nik /
//                          on\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compon /
//                          ents\STACK\SYS\ -I C:\Users\freeman\Documents\wor /
//                          k\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\ /
//                          ..\Components\STACK\ZDO\ -I                       /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MAC\I /
//                          NCLUDE\ -I C:\Users\freeman\Documents\work\NBK\Ni /
//                          kon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Exampl /
//                          es\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo /
//                          nents\MAC\HIGH_LEVEL\ -I                          /
//                          C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\..\..\..\..\..\Components\MAC\L /
//                          OW_LEVEL\srf04\ -I C:\Users\freeman\Documents\wor /
//                          k\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\ /
//                          ..\Components\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\    /
//                          -Ohz --require_prototypes                         /
//    List file          =  C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_R /
//                          f\SimpliciTI-IAR-1.2.0\Projects\Examples\SRF05_80 /
//                          51\nik_sb5000\IAR\LinkTo\List\uart_intfc.s51      /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME uart_intfc

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        PUBLIC ??DmaUartInit?relay
        FUNCTION ??DmaUartInit?relay,0203H
        FUNCTION ??UartProcessData?relay,0203H
        PUBLIC ??buffer_free_space?relay
        FUNCTION ??buffer_free_space?relay,0203H
        PUBLIC ??buffer_used_space?relay
        FUNCTION ??buffer_used_space?relay,0203H
        PUBLIC ??pop_buffer?relay
        FUNCTION ??pop_buffer?relay,0203H
        PUBLIC ??push_buffer?relay
        FUNCTION ??push_buffer?relay,0203H
        PUBLIC ??rx_handler?relay
        FUNCTION ??rx_handler?relay,0203H
        PUBLIC ??rx_peek?relay
        FUNCTION ??rx_peek?relay,0203H
        PUBLIC ??rx_receive?relay
        FUNCTION ??rx_receive?relay,0203H
        PUBLIC ??tx_handler?relay
        FUNCTION ??tx_handler?relay,0203H
        PUBLIC ??tx_peek?relay
        FUNCTION ??tx_peek?relay,0203H
        PUBLIC ??tx_send?relay
        FUNCTION ??tx_send?relay,0203H
        PUBLIC ??tx_send_wait?relay
        FUNCTION ??tx_send_wait?relay,0203H
        PUBLIC ??uart_busy?relay
        FUNCTION ??uart_busy?relay,0203H
        PUBLIC ??uart_intfc_init?relay
        FUNCTION ??uart_intfc_init?relay,0203H
        PUBLIC DmaUartInit
        FUNCTION DmaUartInit,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 3, STACK
        LOCFRAME XSTACK, 29, STACK
        FUNCTION UartProcessData,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBWEAK _A_IEN0
        PUBLIC buffer_free_space
        FUNCTION buffer_free_space,021203H
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC buffer_used_space
        FUNCTION buffer_used_space,0203H
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC pop_buffer
        FUNCTION pop_buffer,0203H
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC push_buffer
        FUNCTION push_buffer,021203H
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC rx_handler
        FUNCTION rx_handler,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 17, STACK
        PUBLIC rx_peek
        FUNCTION rx_peek,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC rx_receive
        FUNCTION rx_receive,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC tx_handler
        FUNCTION tx_handler,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC tx_peek
        FUNCTION tx_peek,021203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC tx_send
        FUNCTION tx_send,021203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC tx_send_wait
        FUNCTION tx_send_wait,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC uart_busy
        FUNCTION uart_busy,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC uart_intfc_init
        FUNCTION uart_intfc_init,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT SameValue
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
uart_init           SYMBOL "uart_init"
uart_rx_message     SYMBOL "uart_rx_message"
HalUARTWrite        SYMBOL "HalUARTWrite"
UartDMAIntSend      SYMBOL "UartDMAIntSend"
HalUARTOpen         SYMBOL "HalUARTOpen"
Hal_UART_RxBufLen   SYMBOL "Hal_UART_RxBufLen"
osal_memset         SYMBOL "osal_memset"
HalUARTRead         SYMBOL "HalUARTRead"
??HalUARTOpen?relay SYMBOL "?relay", HalUARTOpen
??HalUARTRead?relay SYMBOL "?relay", HalUARTRead
??HalUARTWrite?relay SYMBOL "?relay", HalUARTWrite
??Hal_UART_RxBufLen?relay SYMBOL "?relay", Hal_UART_RxBufLen
??UartDMAIntSend?relay SYMBOL "?relay", UartDMAIntSend
??osal_memset?relay SYMBOL "?relay", osal_memset
??uart_init?relay   SYMBOL "?relay", uart_init
??uart_rx_message?relay SYMBOL "?relay", uart_rx_message
DmaUartInit         SYMBOL "DmaUartInit"
??DmaUartInit?relay SYMBOL "?relay", DmaUartInit
buffer_free_space   SYMBOL "buffer_free_space"
??buffer_free_space?relay SYMBOL "?relay", buffer_free_space
buffer_used_space   SYMBOL "buffer_used_space"
??buffer_used_space?relay SYMBOL "?relay", buffer_used_space
pop_buffer          SYMBOL "pop_buffer"
??pop_buffer?relay  SYMBOL "?relay", pop_buffer
push_buffer         SYMBOL "push_buffer"
??push_buffer?relay SYMBOL "?relay", push_buffer
rx_handler          SYMBOL "rx_handler"
??rx_handler?relay  SYMBOL "?relay", rx_handler
rx_peek             SYMBOL "rx_peek"
??rx_peek?relay     SYMBOL "?relay", rx_peek
rx_receive          SYMBOL "rx_receive"
??rx_receive?relay  SYMBOL "?relay", rx_receive
tx_handler          SYMBOL "tx_handler"
??tx_handler?relay  SYMBOL "?relay", tx_handler
tx_peek             SYMBOL "tx_peek"
??tx_peek?relay     SYMBOL "?relay", tx_peek
tx_send             SYMBOL "tx_send"
??tx_send?relay     SYMBOL "?relay", tx_send
tx_send_wait        SYMBOL "tx_send_wait"
??tx_send_wait?relay SYMBOL "?relay", tx_send_wait
uart_busy           SYMBOL "uart_busy"
??uart_busy?relay   SYMBOL "?relay", uart_busy
uart_intfc_init     SYMBOL "uart_intfc_init"
??uart_intfc_init?relay SYMBOL "?relay", uart_intfc_init

        EXTERN uart_init
        FUNCTION uart_init,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uart_rx_message
        FUNCTION uart_rx_message,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalUARTWrite
        FUNCTION HalUARTWrite,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN UartDMAIntSend
        FUNCTION UartDMAIntSend,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalUARTOpen
        FUNCTION HalUARTOpen,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN Hal_UART_RxBufLen
        FUNCTION Hal_UART_RxBufLen,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_memset
        FUNCTION osal_memset,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalUARTRead
        FUNCTION HalUARTRead,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??HalUARTOpen?relay
        FUNCTION ??HalUARTOpen?relay,00H
        EXTERN ??HalUARTRead?relay
        FUNCTION ??HalUARTRead?relay,00H
        EXTERN ??HalUARTWrite?relay
        FUNCTION ??HalUARTWrite?relay,00H
        EXTERN ??Hal_UART_RxBufLen?relay
        FUNCTION ??Hal_UART_RxBufLen?relay,00H
        EXTERN ??UartDMAIntSend?relay
        FUNCTION ??UartDMAIntSend?relay,00H
        EXTERN ??osal_memset?relay
        FUNCTION ??osal_memset?relay,00H
        EXTERN ??uart_init?relay
        FUNCTION ??uart_init?relay,00H
        EXTERN ??uart_rx_message?relay
        FUNCTION ??uart_rx_message?relay,00H

// C:\Users\freeman\Documents\work\NBK\Nikon\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\bsp\drivers\code\uart_intfc.c
//    1 /**************************************************************************************************
//    2   Filename:       uart_intfc.c
//    3   Revised:        $Date: 2009-08-17 10:50:58 -0700 (Mon, 17 Aug 2009) $
//    4   Author:         $Author: jnoxon $
//    5 
//    6   Description:    This file supports the SimpliciTI-compatible UART API functions.
//    7 
//    8   Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
//    9 
//   10   IMPORTANT: Your use of this Software is limited to those specific rights granted under
//   11   the terms of a software license agreement between the user who downloaded the software,
//   12   his/her employer (which must be your employer) and Texas Instruments Incorporated (the
//   13   "License"). You may not use this Software unless you agree to abide by the terms of the
//   14   License. The License limits your use, and you acknowledge, that the Software may not be
//   15   modified, copied or distributed unless embedded on a Texas Instruments microcontroller
//   16   or used solely and exclusively in conjunction with a Texas Instruments radio frequency
//   17   transceiver, which is integrated into your product. Other than for the foregoing purpose,
//   18   you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
//   19   perform, display or sell this Software and/or its documentation for any purpose.
//   20 
//   21   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS?  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
//   22   WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
//   23   IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   24   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
//   25   THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
//   26   INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
//   27   DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
//   28   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   29 
//   30   Should you have any questions regarding your right to use this Software,
//   31   contact Texas Instruments Incorporated at www.TI.com.
//   32 **************************************************************************************************/
//   33 
//   34 /******************************************************************************
//   35  * INCLUDES
//   36  */
//   37 #include "uart_intfc.h"

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DATA8
        DS 1
//   38 #include <stdlib.h>
//   39 
//   40 #include "bsp.h"
//   41 #ifdef FREQUENCY_HOPPING
//   42 #include "nwk_pll.h"
//   43 #endif
//   44 
//   45 #include "hal_uart.h"
//   46 #include "osal.h"
//   47 
//   48 /******************************************************************************
//   49  * CONSTANTS AND DEFINES
//   50  */
//   51 #ifndef RX_TX_BUFFER_SIZE       /* this value must be at least 2. */
//   52 #define RX_TX_BUFFER_SIZE 50
//   53 #endif
//   54 
//   55 //serial setting
//   56 #define UART_DEFAULT_BAUDRATE			HAL_UART_BR_115200//HAL_UART_BR_57600
//   57 #define UART_DEFAULT_OVERFLOW			FALSE
//   58 #define UART_DEFAULT_THRESHOLD		(128/2)
//   59 #define UART_DEFAULT_MAX_RX_BUFF		128		
//   60 #define UART_DEFAULT_MAX_TX_BUFF		128
//   61 #define UART_DEFAULT_IDLE_TIMEOUT		6
//   62 
//   63 //#define UART_PORT HAL_UART_PORT_0
//   64 
//   65 /******************************************************************************
//   66  * MACROS
//   67  */
//   68 #define RX_TX_BUFFER_THROTTLE_LIMIT ( ( ( UART_BAUD_RATE ) > 15000 \ 
//   69                                        && ( RX_TX_BUFFER_SIZE ) > 8 ) \ 
//   70                                              ? ( ( RX_TX_BUFFER_SIZE ) - 4 )\ 
//   71                                              : ( ( RX_TX_BUFFER_SIZE ) - 1 ) )
//   72 
//   73 /******************************************************************************
//   74  * LOCAL VARIABLES
//   75  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   76 static unsigned char rx_buff[RX_TX_BUFFER_SIZE];
rx_buff:
        DS 50
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   77 static unsigned char tx_buff[RX_TX_BUFFER_SIZE];
tx_buff:
        DS 50
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_I:XDATA:NOROOT(0)
//   78 static unsigned char* rx_head = rx_buff;
rx_head:
        DATA16
        DS 2
        REQUIRE `?<Initializer for rx_head>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
//   79 static unsigned char* rx_tail = rx_buff;
rx_tail:
        DATA16
        DS 2
        REQUIRE `?<Initializer for rx_tail>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
//   80 static unsigned char* tx_head = tx_buff;
tx_head:
        DATA16
        DS 2
        REQUIRE `?<Initializer for tx_head>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
//   81 static unsigned char* tx_tail = tx_buff;
tx_tail:
        DATA16
        DS 2
        REQUIRE `?<Initializer for tx_tail>`
        REQUIRE __INIT_XDATA_I
//   82 
//   83 /******************************************************************************
//   84  * LOCAL FUNCTIONS
//   85  */
//   86 
//   87 /* uart data handler function prototypes */
//   88 bool tx_handler( unsigned char* c );
//   89 bool rx_handler( unsigned char c );
//   90 
//   91 int buffer_free_space( unsigned char* head, unsigned char* tail );
//   92 int buffer_used_space( unsigned char* head, unsigned char* tail );
//   93 bool push_buffer( unsigned char** head, unsigned char* tail,
//   94                   unsigned char* buff, unsigned char* data, int len );
//   95 int pop_buffer( unsigned char* head, unsigned char** tail,
//   96                 unsigned char* buff, unsigned char* data, int max_len );
//   97 
//   98 static void UartProcessData(uint8 port, uint8 event);
//   99 
//  100 extern void UartDMAIntSend(void);
//  101 
//  102 /******************************************************************************
//  103  * GLOBAL FUNCTIONS
//  104  */
//  105 
//  106 /******************************************************************************
//  107  * @fn          uart_intfc_init
//  108  *
//  109  * @brief       Initialize UART interface. Buffer pointers are initialized.
//  110  *
//  111  * input parameters
//  112  *
//  113  * output parameters
//  114  *
//  115  * @return   void
//  116  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  117 void uart_intfc_init( void )
uart_intfc_init:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function uart_intfc_init
        CODE
//  118   {
        FUNCALL uart_intfc_init, uart_init
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uart_intfc_init, uart_rx_message
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  119   /* initialize the buffer pointers in case we are re-initialized */
//  120   rx_head = rx_buff;
        MOV     DPTR,#rx_head
        MOV     A,#rx_buff & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(rx_buff >> 8) & 0xff
        MOVX    @DPTR,A
//  121   rx_tail = rx_buff;
        MOV     DPTR,#rx_tail
        MOV     A,#rx_buff & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(rx_buff >> 8) & 0xff
        MOVX    @DPTR,A
//  122   tx_head = tx_buff;
        MOV     DPTR,#tx_head
        MOV     A,#tx_buff & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(tx_buff >> 8) & 0xff
        MOVX    @DPTR,A
//  123   tx_tail = tx_buff;
        MOV     DPTR,#tx_tail
        MOV     A,#tx_buff & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(tx_buff >> 8) & 0xff
        MOVX    @DPTR,A
//  124 
//  125   uart_init( ); /* initialize the uart for operations */
        ; Setup parameters for call to function uart_init
        LCALL   ??uart_init?relay
//  126   uart_rx_message( rx_handler ); /* enable us to receive uart data */
        ; Setup parameters for call to function uart_rx_message
        MOV     R2,#??rx_handler?relay & 0xff
        MOV     R3,#(??rx_handler?relay >> 8) & 0xff
        LCALL   ??uart_rx_message?relay
//  127 
//  128 #if( defined UART_HARDWARE_HANDSHAKE_IN_SOFTWARE )
//  129    UART_ASSERT_RTS( UART_RTS_DEASSERTED ); /* release flow control */
//  130 #endif
//  131 
//  132   return;
        LJMP    ?Subroutine0 & 0xFFFF
        CFI EndBlock cfiBlock0
//  133   }
//  134 
//  135 /******************************************************************************
//  136  * @fn          buffer_free_space
//  137  *
//  138  * @brief       Calculates amount of freespace in buffer from <head> and <tail>
//  139  *              addresses
//  140  *
//  141  * input parameters
//  142  * @param   head       - pointer to buffer head
//  143  * @param   tail       - pointer to buffer tail
//  144  *
//  145  * output parameters
//  146  *
//  147  * @return   Buffer free space count in bytes
//  148  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  149 int buffer_free_space( unsigned char* head, unsigned char* tail )
buffer_free_space:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function buffer_free_space
        CODE
//  150   {
        FUNCALL buffer_free_space, buffer_used_space
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  151   /* the free count is the buffer size minus the used count minus one
//  152    * because we don't want the pointers to ever get back on top of each other
//  153    * because that would indicate an empty buffer. */
//  154   return RX_TX_BUFFER_SIZE - buffer_used_space( head, tail ) - 1;
        ; Setup parameters for call to function buffer_used_space
        LCALL   ??buffer_used_space?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#0x31
        CLR     C
        SUBB    A,?V0 + 0
        MOV     R2,A
        CLR     A
        SUBB    A,?V0 + 1
        MOV     R3,A
        SJMP    ??Subroutine7_0
        CFI EndBlock cfiBlock1
//  155   }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI Invalid
        LCALL   ?DEALLOC_XSTACK8
        CFI EndBlock cfiBlock2
        REQUIRE ??Subroutine7_0
        ; // Fall through to label ??Subroutine7_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine7_0:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock3
//  156 
//  157 /******************************************************************************
//  158  * @fn          buffer_used_space
//  159  *
//  160  * @brief       Calculates amount of used space in buffer from <head> and <tail>
//  161  *              addresses
//  162  *
//  163  * input parameters
//  164  * @param   head       - pointer to buffer head
//  165  * @param   tail       - pointer to buffer tail
//  166  *
//  167  * output parameters
//  168  *
//  169  * @return   Buffer used space count in bytes
//  170  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  171 int buffer_used_space( unsigned char* head, unsigned char* tail )
buffer_used_space:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function buffer_used_space
        CODE
//  172   {
        ; Saved register size: 0
        ; Auto size: 0
//  173   ptrdiff_t used;
//  174   
//  175   used = head - tail; /* get used count */
        MOV     A,R2
        CLR     C
        SUBB    A,R4
        MOV     R2,A
        MOV     A,R3
        SUBB    A,R5
        MOV     R3,A
//  176   if( used < 0 ) /* if the pointers were wrapped */
        CLR     C
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_2:
        JNC     ??buffer_used_space_0
//  177     used += RX_TX_BUFFER_SIZE; /* correct the count */
        MOV     A,R2
        ADD     A,#0x32
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R3,A
//  178   
//  179   return used; /* return used count */
??buffer_used_space_0:
        LJMP    ?BRET
        CFI EndBlock cfiBlock4
//  180   }
//  181 
//  182 /******************************************************************************
//  183  * @fn          push_buffer
//  184  *
//  185  * @brief       Pushes bytes of data onto the specified buffer. Assumes on 
//  186  *              entry that <data>, <buff>, <tail>, and <head> are all valid 
//  187  *              pointers
//  188  *
//  189  * input parameters
//  190  * @param   tail       - pointer to buffer tail
//  191  * @param   buff       - pointer to buffer (push target)
//  192  * @param   data       - pointer to data to be pushed into buffer
//  193  * @param   len        - length in bytes of data to be pushed
//  194  *
//  195  * output parameters
//  196  * @param   head       - updated buffer head pointer
//  197  *
//  198  * @return   status of operation.
//  199  *             true          Data successfully pushed into buffer
//  200  *             false         Data not pushed into buffer
//  201  */
//  202 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  203 bool push_buffer( unsigned char** head, unsigned char* tail,
push_buffer:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function push_buffer
        CODE
//  204                   unsigned char* buff, unsigned char* data, int len )
//  205   {
        FUNCALL push_buffer, buffer_free_space
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x12
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 0
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
//  206   unsigned char* local_head;
//  207   unsigned char* local_tail = tail;
//  208 
//  209   BSP_CRITICAL_STATEMENT( local_head = *head );
        MOV     A,0xa8
        MOV     R0,A
        CLR     0xa8.7
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
//  210   
//  211   /* if no room in the buffer */
//  212   if( buffer_free_space( local_head, local_tail ) < len )
        ; Setup parameters for call to function buffer_free_space
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??buffer_free_space?relay
        CLR     C
        MOV     A,R2
        SUBB    A,?V0 + 2
        MOV     A,R3
        SUBB    A,?V0 + 3
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??push_buffer_0
//  213     return false; /* indicate failure to enqueue message */
        CLR     C
        SJMP    ??push_buffer_1
//  214   
//  215   /* there is room for the data, put in the buffer */
//  216   
//  217   do /* put the data in the buffer */
//  218     {
//  219     if( local_head == buff + RX_TX_BUFFER_SIZE ) /* if wrapping around */
??push_buffer_0:
        MOV     A,?V0 + 4
        ADD     A,#0x32
        MOV     R0,A
        MOV     A,?V0 + 5
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,R6
        XRL     A,R0
        JNZ     ??push_buffer_2
        MOV     A,R7
        XRL     A,R1
??push_buffer_2:
        JNZ     ??push_buffer_3
//  220       local_head = buff; /* reset pointer */
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
//  221     
//  222     *local_head++ = *data++; /* copy over this byte of data */
??push_buffer_3:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
//  223     } while( --len > 0 ); /* copy all the data to the buffer */
        MOV     A,?V0 + 2
        ADD     A,#-0x1
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#-0x1
        MOV     ?V0 + 3,A
        CLR     C
        MOV     A,?V0 + 2
        SUBB    A,#0x1
        MOV     A,?V0 + 3
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_3:
        JNC     ??push_buffer_0
//  224   
//  225   BSP_CRITICAL_STATEMENT( *head = local_head ); /* update reference value */
        MOV     A,0xa8
        MOV     R0,A
        CLR     0xa8.7
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
//  226   
//  227   return true;
        SETB    C
??push_buffer_1:
        MOV     R7,#0xa
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock5
        REQUIRE _A_IEN0
//  228   }
//  229 
//  230 /******************************************************************************
//  231  * @fn          pop_buffer
//  232  *
//  233  * @brief       Pops the specified number of bytes off of the specified buffer. 
//  234  *              Assumes on entry that <data>, <buff>, <tail>, and <head> are 
//  235  *              all valid pointers.
//  236  *
//  237  * input parameters
//  238  * @param   head       - pointer to buffer head
//  239  * @param   buff       - pointer to buffer (pop source)
//  240  * @param   data       - pointer to location to store popped data
//  241  * @param   len        - amount of bytes to be popped from buffer
//  242  *
//  243  * output parameters
//  244  * @param   tail       - updated buffer tail pointer
//  245  *
//  246  * @return   number of bytes popped from buffer
//  247  */
//  248 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  249 int pop_buffer( unsigned char* head, unsigned char** tail,
pop_buffer:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function pop_buffer
        CODE
//  250                 unsigned char* buff, unsigned char* data, int max_len )
//  251   {
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
//  252   unsigned char* local_tail;
//  253   unsigned char* local_head = head;
//  254   int cnt = 0;
        MOV     R4,#0x0
        MOV     R5,#0x0
//  255 
//  256   BSP_CRITICAL_STATEMENT( local_tail = *tail );
        MOV     A,0xa8
        MOV     ?V0 + 6,A
        CLR     0xa8.7
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V0 + 6
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
//  257   
//  258   /* if the buffer is empty or no data requested */
//  259   if( local_tail == local_head || max_len <= 0 )
        MOV     A,R2
        XRL     A,R0
        JNZ     ??pop_buffer_0
        MOV     A,R3
        XRL     A,R1
??pop_buffer_0:
        JZ      ??pop_buffer_1
        CLR     C
        MOV     A,?V0 + 4
        SUBB    A,#0x1
        MOV     A,?V0 + 5
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_4:
        JNC     ??pop_buffer_2
//  260     return 0; /* indicate so */
??pop_buffer_1:
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??pop_buffer_3
//  261   
//  262   do /* retrieve the data from the buffer */
//  263     {
//  264     if( local_tail == buff + RX_TX_BUFFER_SIZE ) /* if wrapping around */
??pop_buffer_2:
        MOV     A,?V0 + 0
        ADD     A,#0x32
        MOV     ?V0 + 6,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 7,A
        MOV     A,R0
        XRL     A,?V0 + 6
        JNZ     ??pop_buffer_4
        MOV     A,R1
        XRL     A,?V0 + 7
??pop_buffer_4:
        JNZ     ??pop_buffer_5
//  265       local_tail = buff; /* reset pointer */
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
//  266     
//  267     *data++ = *local_tail++; /* copy data from buffer */
??pop_buffer_5:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
//  268       
//  269     /* while the user needs more data and there is data left in the fifo */
//  270     } while( ++cnt < max_len && local_tail != local_head );
        MOV     A,R4
        ADD     A,#0x1
        INC     R4
        MOV     A,R5
        ADDC    A,#0x0
        MOV     R5,A
        CLR     C
        MOV     A,R4
        SUBB    A,?V0 + 4
        MOV     A,R5
        SUBB    A,?V0 + 5
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??pop_buffer_6
        MOV     A,R2
        XRL     A,R0
        JNZ     ??pop_buffer_7
        MOV     A,R3
        XRL     A,R1
??pop_buffer_7:
        JNZ     ??pop_buffer_2
//  271     
//  272   BSP_CRITICAL_STATEMENT( *tail = local_tail ); /* update reference value */
??pop_buffer_6:
        MOV     A,0xa8
        MOV     R2,A
        CLR     0xa8.7
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     A,R2
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
//  273   
//  274   return cnt; /* return number of characters retrieved from the buffer */
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
??pop_buffer_3:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock6
        REQUIRE _A_IEN0
//  275   }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond7 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI Block cfiCond8 Using cfiCommon0
        CFI (cfiCond8) NoFunction
        CFI (cfiCond8) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond8) R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI (cfiCond8) VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI (cfiCond8) V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond8) V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond8) V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond8) V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond8) V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond8) V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond8) V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond8) V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond8) V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond8) V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond8) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond8) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond8) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond8) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond8) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond8) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond8) CFA_SP SP+0
        CFI (cfiCond8) CFA_XSP16 add(XSP16, 18)
        CFI Block cfiCond9 Using cfiCommon0
        CFI (cfiCond9) NoFunction
        CFI (cfiCond9) Conditional ??CrossCallReturnLabel_4
        CFI (cfiCond9) R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond9) VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond9) V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond9) V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond9) V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond9) V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond9) V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond9) V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond9) V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond9) V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond9) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond9) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond9) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond9) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond9) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond9) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond9) CFA_SP SP+0
        CFI (cfiCond9) CFA_XSP16 add(XSP16, 16)
        CFI Block cfiCond10 Using cfiCommon0
        CFI (cfiCond10) NoFunction
        CFI (cfiCond10) Conditional ??CrossCallReturnLabel_5
        CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond10) V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond10) V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond10) V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond10) V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond10) CFA_SP SP+0
        CFI (cfiCond10) CFA_XSP16 add(XSP16, 14)
        CFI Block cfiPicker11 Using cfiCommon1
        CFI (cfiPicker11) NoFunction
        CFI (cfiPicker11) Picker
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        RET
        CFI EndBlock cfiCond7
        CFI EndBlock cfiCond8
        CFI EndBlock cfiCond9
        CFI EndBlock cfiCond10
        CFI EndBlock cfiPicker11
//  276 
//  277 /******************************************************************************
//  278  * @fn          tx_send_wait
//  279  *
//  280  * @brief       Enqueue's the message bointed to by <data> which is of length 
//  281  *              <len> and initiates its transfer across the UART.  This is a 
//  282  *              blocking function in that if the transmit fifo doesn't have 
//  283  *              enough room to enqueue the data in its entirety it will push 
//  284  *              the data out a piece at a time as the room in the FIFO becomes 
//  285  *              available.  The function returns true upon completion of moving 
//  286  *              all the data into the FIFO and false if either a NULL pointer 
//  287  *              or a length of zero was passed.
//  288  *
//  289  * input parameters
//  290  * @param   data       - pointer to data to be sent
//  291  * @param   len        - length in bytes of data to be sent
//  292  *
//  293  * output parameters
//  294  *
//  295  * @return   status of operation.
//  296  *             true          Data successfully pushed into transmit buffer
//  297  *             false         Invalid length or NULL data pointer
//  298  */
//  299 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  300 bool tx_send_wait( const void* data, size_t len )
tx_send_wait:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function tx_send_wait
        CODE
//  301   {
        FUNCALL tx_send_wait, tx_peek
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL tx_send_wait, tx_send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
//  302   if( len > 0 && data != NULL ) /* if the information looks viable */
        MOV     A,R4
        ORL     A,?V0 + 3
        JZ      ??tx_send_wait_0
        MOV     A,R6
        ORL     A,R7
        JZ      ??tx_send_wait_0
//  303     {
//  304     while( len > 0 )            /* while there is data left to transfer */
//  305       {
//  306       int sz = tx_peek( );      /* get free space in the fifo */
??tx_send_wait_1:
        ; Setup parameters for call to function tx_peek
        LCALL   ??tx_peek?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
//  307 
//  308       if( sz > 0 )              /* if there is room for at least some data */
        CLR     C
        MOV     A,R2
        SUBB    A,#0x1
        MOV     A,R3
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_5:
        JC      ??tx_send_wait_1
//  309         {
//  310         if( sz > len )          /* if more room than required          */
        CLR     C
        MOV     A,?V0 + 2
        SUBB    A,?V0 + 0
        MOV     A,?V0 + 3
        SUBB    A,?V0 + 1
        JNC     ??tx_send_wait_2
//  311           sz = len;             /* limit size to just the data to send */
        MOV     ?V0 + 0,?V0 + 2
        MOV     ?V0 + 1,?V0 + 3
//  312 
//  313         tx_send( data, sz );    /* send this portion of the information */
??tx_send_wait_2:
        ; Setup parameters for call to function tx_send
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??tx_send?relay
//  314 
//  315         data = (unsigned char*)data + sz; /* move the pointer */
        MOV     A,R6
        ADD     A,?V0 + 0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 1
        MOV     R7,A
//  316 
//  317         len -= sz;              /* adjust the count of remaining data to send */
        CLR     C
        MOV     A,?V0 + 2
        SUBB    A,?V0 + 0
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        SUBB    A,?V0 + 1
        MOV     ?V0 + 3,A
//  318         }
//  319       #ifdef FREQUENCY_HOPPING
//  320       // run the pll charge pump if frequency hopping active
//  321       //   only send pump requests if there are still characters still to send
//  322       nwk_pllBackgrounder( len == 0 );
//  323       #endif
//  324       }
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??tx_send_wait_1
//  325     
//  326     return true; /* indicate success */
        SETB    C
        SJMP    ??tx_send_wait_3
//  327     }
//  328   
//  329   return false; /* otherwise indicate failure */
??tx_send_wait_0:
        CLR     C
??tx_send_wait_3:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock12
//  330   }
//  331 
//  332 /******************************************************************************
//  333  * @fn          tx_send
//  334  *
//  335  * @brief       Enqueue's the message pointed to by <data> which is of length 
//  336  *              <len> and initiates its transfer across the uart.  true is 
//  337  *              returned if there was space in the FIFO to send the data, false 
//  338  *              if the FIFO didn't have enough free space to enqueue the data. 
//  339  *
//  340  * input parameters
//  341  * @param   data       - pointer to data to be sent
//  342  * @param   len        - length in bytes of data to be sent
//  343  *
//  344  * output parameters
//  345  *
//  346  * @return   status of operation.
//  347  *             true          Data successfully pushed into transmit buffer
//  348  *             false         Data not successfully pushed into transmit buffer
//  349  */
//  350 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  351 bool tx_send( const void* data, size_t len )
tx_send:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function tx_send
        CODE
//  352   {
        FUNCALL tx_send, HalUARTWrite
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL tx_send, UartDMAIntSend
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  353 #if 0
//  354   bool status;
//  355   unsigned char* tail;
//  356   
//  357   /* get current state of tail pointer */
//  358   BSP_CRITICAL_STATEMENT( tail = tx_tail );
//  359 
//  360   /* put data into transmit buffer */
//  361   status = push_buffer( &tx_head, tail, tx_buff, (unsigned char*)data, len );
//  362 
//  363   if( status != false ) /* if data was put in the buffer properly */
//  364     uart_tx_message( tx_handler ); /* notify the irq that data is ready to send */
//  365   
//  366   return status; /* return status */
//  367 #endif
//  368 
//  369 	HalUARTWrite(0,(uint8*)data,len);
        ; Setup parameters for call to function HalUARTWrite
        MOV     R1,#0x0
        LCALL   ??HalUARTWrite?relay
//  370 	//HalUARTPoll();
//  371 	UartDMAIntSend();
        ; Setup parameters for call to function UartDMAIntSend
        LCALL   ??UartDMAIntSend?relay
//  372   }
        SJMP    ?Subroutine0
        CFI EndBlock cfiBlock13
//  373 
//  374 /******************************************************************************
//  375  * @fn          tx_peek
//  376  *
//  377  * @brief       Returns the number of bytes of free space in the transmit FIFO. 
//  378  *
//  379  * input parameters
//  380  *
//  381  * output parameters
//  382  *
//  383  * @return   Number of bytes of free space in the transmit FIFO
//  384  */
//  385 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  386 int tx_peek( void )
tx_peek:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function tx_peek
        CODE
//  387   {
        FUNCALL tx_peek, buffer_free_space
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  388   unsigned char* head;
//  389   unsigned char* tail;
//  390   
//  391   BSP_CRITICAL_STATEMENT( head = tx_head; tail = tx_tail );
        LCALL   ?Subroutine5 & 0xFFFF
//  392   
//  393   return buffer_free_space( head, tail );
??CrossCallReturnLabel_6:
        LCALL   ??buffer_free_space?relay
        CFI EndBlock cfiBlock14
        REQUIRE ?Subroutine0
        REQUIRE _A_IEN0
        ; // Fall through to label ?Subroutine0
//  394   }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock15 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-5
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        POP     DPH
        CFI CFA_SP SP+-4
        CFI DPH0 SameValue
        POP     DPL
        CFI CFA_SP SP+-3
        CFI DPL0 SameValue
        LJMP    ?BRET
        CFI EndBlock cfiBlock15
//  395 
//  396 /******************************************************************************
//  397  * @fn          rx_peek
//  398  *
//  399  * @brief       Returns the number of bytes currently available to be read from
//  400  *              the receive FIFO. 
//  401  *
//  402  * input parameters
//  403  *
//  404  * output parameters
//  405  *
//  406  * @return   Number of bytes of available in the receive FIFO
//  407  */
//  408 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  409 int rx_peek( void )
rx_peek:
        CFI Block cfiBlock16 Using cfiCommon0
        CFI Function rx_peek
        CODE
//  410   {
        FUNCALL rx_peek, buffer_used_space
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  411   unsigned char* head;
//  412   unsigned char* tail;
//  413   
//  414   BSP_CRITICAL_STATEMENT( head = rx_head; tail = rx_tail );
        LCALL   ?Subroutine3 & 0xFFFF
//  415   
//  416   return buffer_used_space( head, tail );
??CrossCallReturnLabel_0:
        SJMP    ?Subroutine0
        CFI EndBlock cfiBlock16
        REQUIRE _A_IEN0
//  417   }
//  418 
//  419 /******************************************************************************
//  420  * @fn          rx_receive
//  421  *
//  422  * @brief       Fills in the buffer <data> with data from the receive FIFO until
//  423  *              either <max_len> bytes have been transferred into <data> or the 
//  424  *              receive queue is emptied.  The actual number of bytes put into 
//  425  *              <data> is returned. 
//  426  *
//  427  * input parameters
//  428  * @param   data           - pointer to data to be sent
//  429  * @param   max_len        - length in bytes of data to be sent
//  430  *
//  431  * output parameters
//  432  *
//  433  * @return   status of operation.
//  434  *             true          Data successfully pushed into transmit buffer
//  435  *             false         Data not successfully pushed into transmit buffer
//  436  */
//  437 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  438 int rx_receive( void* data, int max_len )
rx_receive:
        CFI Block cfiBlock17 Using cfiCommon0
        CFI Function rx_receive
        CODE
//  439   {
        FUNCALL rx_receive, pop_buffer
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  440   int cnt;
//  441   unsigned char* head;
//  442   
//  443   /* get current state of head pointer */
//  444   BSP_CRITICAL_STATEMENT( head = rx_head );
        MOV     A,0xa8
        CLR     0xa8.7
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
//  445   
//  446   /* retrieve data from buffer */
//  447   cnt = pop_buffer( head, &rx_tail, rx_buff, data, max_len );
//  448 
//  449 #if( defined UART_HARDWARE_HANDSHAKE_IN_SOFTWARE )
//  450   /* if we need to hold off the remote transmitter */
//  451   if( rx_peek( ) < RX_TX_BUFFER_THROTTLE_LIMIT )
//  452      UART_ASSERT_RTS( UART_RTS_DEASSERTED ); /* deassert the RTS line */
//  453 #endif
//  454 
//  455   return cnt; /* indicate the number of bytes retrieved from the buffer */
        ; Setup parameters for call to function pop_buffer
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#rx_buff & 0xff
        MOV     ?V0 + 1,#(rx_buff >> 8) & 0xff
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#rx_tail & 0xff
        MOV     R5,#(rx_tail >> 8) & 0xff
        MOV     DPTR,#rx_head
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_8:
        LJMP    ?Subroutine1 & 0xFFFF
        CFI EndBlock cfiBlock17
        REQUIRE _A_IEN0
//  456   }
//  457 
//  458 /******************************************************************************
//  459  * @fn          uart_busy
//  460  *
//  461  * @brief       Returns true if there are characters in the receive FIFO or 
//  462  *              transmit buffer and returns false if both FIFOs are empty. 
//  463  *
//  464  * input parameters
//  465  *
//  466  * output parameters
//  467  *
//  468  * @return   UART status
//  469  *             true          Data in receive and/or transmit FIFO
//  470  *             false         Both receive and transmit FIFOS empty
//  471  */
//  472 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  473 bool uart_busy( void )
uart_busy:
        CFI Block cfiBlock18 Using cfiCommon0
        CFI Function uart_busy
        CODE
//  474   {
        FUNCALL uart_busy, buffer_used_space
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uart_busy, buffer_used_space
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  475   int cnt;
//  476   unsigned char* head;
//  477   unsigned char* tail;
//  478   
//  479   /* get receive buffer count */
//  480   BSP_CRITICAL_STATEMENT( head = rx_head; tail = rx_tail );
        LCALL   ?Subroutine3 & 0xFFFF
//  481   cnt = buffer_used_space( head, tail );
??CrossCallReturnLabel_1:
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R6,?V0 + 0
        MOV     R7,?V0 + 1
//  482   
//  483   /* get transmit buffer count */
//  484   BSP_CRITICAL_STATEMENT( head = tx_head; tail = tx_tail );
        LCALL   ?Subroutine5 & 0xFFFF
//  485   cnt += buffer_used_space( head, tail );
//  486   
//  487   return ( ( cnt == 0 ) ? false : true ); /* return status of uart */
??CrossCallReturnLabel_7:
        LCALL   ??buffer_used_space?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R6
        ADD     A,?V0 + 0
        MOV     R0,A
        MOV     A,R7
        ADDC    A,?V0 + 1
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??uart_busy_0
        SETB    B.0
        SJMP    ??uart_busy_1
??uart_busy_0:
        CLR     B.0
        CFI EndBlock cfiBlock18
??uart_busy_1:
        REQUIRE ?Subroutine2
        REQUIRE _A_IEN0
        ; // Fall through to label ?Subroutine2
//  488   }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiBlock19 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     C,B.0
        LJMP    ??Subroutine7_0 & 0xFFFF
        CFI EndBlock cfiBlock19

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond20 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_6
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        CFI Block cfiCond21 Using cfiCommon0
        CFI (cfiCond21) NoFunction
        CFI (cfiCond21) Conditional ??CrossCallReturnLabel_7
        CFI (cfiCond21) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond21) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond21) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond21) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond21) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond21) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond21) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond21) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond21) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond21) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond21) CFA_SP SP+0
        CFI (cfiCond21) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiPicker22 Using cfiCommon1
        CFI (cfiPicker22) NoFunction
        CFI (cfiPicker22) Picker
        MOV     A,0xa8
        CLR     0xa8.7
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
        ; Setup parameters for call to function buffer_free_space
        ; Setup parameters for call to function buffer_used_space
        MOV     DPTR,#tx_tail
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPTR,#tx_head
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        RET
        CFI EndBlock cfiCond20
        CFI EndBlock cfiCond21
        CFI EndBlock cfiPicker22

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond23 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        CFI Block cfiCond24 Using cfiCommon0
        CFI (cfiCond24) NoFunction
        CFI (cfiCond24) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond24) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond24) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond24) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond24) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond24) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond24) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond24) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond24) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond24) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond24) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond24) CFA_SP SP+0
        CFI (cfiCond24) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiPicker25 Using cfiCommon1
        CFI (cfiPicker25) NoFunction
        CFI (cfiPicker25) Picker
        MOV     A,0xa8
        CLR     0xa8.7
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
        ; Setup parameters for call to function buffer_used_space
        ; Setup parameters for call to function buffer_used_space
        MOV     DPTR,#rx_tail
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPTR,#rx_head
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??buffer_used_space?relay
        RET
        CFI EndBlock cfiCond23
        CFI EndBlock cfiCond24
        CFI EndBlock cfiPicker25
//  489 
//  490 /******************************************************************************
//  491  * @fn          tx_handler
//  492  *
//  493  * @brief       Called by UART transmit interrupt service routine. Pops a byte 
//  494  *              off of the transmit FIFO and stores in <c>. The UART
//  495  *              interrupt service routine will transmit the byte in <c> after
//  496  *              calling this function. Returns true if there is still data left
//  497  *              in the transmit FIFO and false if the FIFO has been emptied.
//  498  *
//  499  * input parameters
//  500  * @param   c              - pointer to store byte to be sent
//  501  *
//  502  * output parameters
//  503  *
//  504  * @return   status of operation.
//  505  *             true          Byte in <c> is NOT the last byte in the buffer
//  506  *             false         Byte in <c> IS the last byte in the buffer
//  507  */
//  508 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  509 bool tx_handler( unsigned char* c )
tx_handler:
        CFI Block cfiBlock26 Using cfiCommon0
        CFI Function tx_handler
        CODE
//  510   {
        FUNCALL tx_handler, pop_buffer
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  511   bool status;
//  512   unsigned char* head;
//  513 
//  514   /* get current state of head pointer */
//  515   BSP_CRITICAL_STATEMENT( head = tx_head );
        MOV     A,0xa8
        CLR     0xa8.7
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
//  516 
//  517   /* get data off of the transmit buffer */
//  518   pop_buffer( head, &tx_tail, tx_buff, c, 1 );
        ; Setup parameters for call to function pop_buffer
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 12)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 14)
        MOV     ?V0 + 0,#tx_buff & 0xff
        MOV     ?V0 + 1,#(tx_buff >> 8) & 0xff
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#tx_tail & 0xff
        MOV     R5,#(tx_tail >> 8) & 0xff
        MOV     DPTR,#tx_head
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_9:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 10)
//  519   
//  520   /* check status of buffer */
//  521   BSP_CRITICAL_STATEMENT( status = tx_head != tx_tail );
        MOV     C,0xa8.7
        CLR     A
        RLC     A
        MOV     R2,A
        CLR     0xa8.7
        MOV     DPTR,#tx_head
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#tx_tail
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??tx_handler_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??tx_handler_0:
        JZ      ??tx_handler_1
        SETB    B.0
        SJMP    ??tx_handler_2
??tx_handler_1:
        CLR     B.0
??tx_handler_2:
        MOV     A,R2
        MOV     C,0xE0 /* A   */.0
        MOV     0xa8.7,C
        MOV     A,0xa8
//  522   
//  523   return status; /* indicate if this is the last byte in the buffer */
        LJMP    ?Subroutine2 & 0xFFFF
        CFI EndBlock cfiBlock26
        REQUIRE _A_IEN0
//  524   }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond27 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_8
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 16)
        CFI Block cfiCond28 Using cfiCommon0
        CFI (cfiCond28) NoFunction
        CFI (cfiCond28) Conditional ??CrossCallReturnLabel_9
        CFI (cfiCond28) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond28) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond28) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond28) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond28) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond28) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond28) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond28) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond28) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond28) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond28) CFA_SP SP+0
        CFI (cfiCond28) CFA_XSP16 add(XSP16, 16)
        CFI Block cfiPicker29 Using cfiCommon1
        CFI (cfiPicker29) NoFunction
        CFI (cfiPicker29) Picker
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??pop_buffer?relay
        MOV     A,#0x6
        RET
        CFI EndBlock cfiCond27
        CFI EndBlock cfiCond28
        CFI EndBlock cfiPicker29
//  525 
//  526 /******************************************************************************
//  527  * @fn          rx_handler
//  528  *
//  529  * @brief       Called by UART receive interrupt service routine. Pushes byte 
//  530  *              <c> into the receive FIFO <c>.
//  531  *
//  532  * input parameters
//  533  * @param   c              - byte of data to be pushed onto receive FIFO
//  534  *
//  535  * output parameters
//  536  *
//  537  * @return   Always returns true
//  538  */
//  539 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  540 bool rx_handler( unsigned char c )
rx_handler:
        CFI Block cfiBlock30 Using cfiCommon0
        CFI Function rx_handler
        CODE
//  541   {
        FUNCALL rx_handler, push_buffer
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
        MOV     A,R1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
//  542   unsigned char* tail;
//  543 
//  544   /* get current state of tail pointer */
//  545   BSP_CRITICAL_STATEMENT( tail = rx_tail );
        MOV     A,0xa8
        CLR     0xa8.7
        MOV     C,0xE0 /* A   */.7
        MOV     0xa8.7,C
        MOV     A,0xa8
//  546   
//  547   /* put data onto the receive buffer */
//  548   push_buffer( &rx_head, tail, rx_buff, &c, 1 );
        ; Setup parameters for call to function push_buffer
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 13)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 15)
        MOV     ?V0 + 0,#rx_buff & 0xff
        MOV     ?V0 + 1,#(rx_buff >> 8) & 0xff
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 17)
        MOV     DPTR,#rx_tail
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,#rx_head & 0xff
        MOV     R3,#(rx_head >> 8) & 0xff
        LCALL   ??push_buffer?relay
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 11)
//  549 
//  550 #if( defined UART_HARDWARE_HANDSHAKE_IN_SOFTWARE )
//  551   /* if we need to hold off the remote transmitter */
//  552   if( rx_peek( ) >= RX_TX_BUFFER_THROTTLE_LIMIT )
//  553     UART_ASSERT_RTS( UART_RTS_ASSERTED ); /* assert the RTS line */
//  554 #endif
//  555   
//  556   return true; /* always accept data received from the uart */
        SETB    C
        MOV     A,#0x1
        LJMP    ?Subroutine1 & 0xFFFF
        CFI EndBlock cfiBlock30
        REQUIRE _A_IEN0
//  557   }
//  558 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  559 void DmaUartInit (void)
DmaUartInit:
        CFI Block cfiBlock31 Using cfiCommon0
        CFI Function DmaUartInit
        CODE
//  560 {
        FUNCALL DmaUartInit, HalUARTOpen
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 29
        MOV     A,#-0x1d
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 29)
//  561 	halUARTCfg_t uartConfig;
//  562 	/* Initialize APP ID */
//  563 	//App_TaskID = 0;
//  564 
//  565 	/* UART Configuration */
//  566 	uartConfig.configured           = TRUE;
        MOV     A,#0x1
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
//  567 	uartConfig.baudRate             = UART_DEFAULT_BAUDRATE;
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x4
        MOVX    @DPTR,A
//  568 	uartConfig.flowControl          = UART_DEFAULT_OVERFLOW;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        CLR     A
        MOVX    @DPTR,A
//  569 	uartConfig.flowControlThreshold = UART_DEFAULT_THRESHOLD;
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x40
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  570 	uartConfig.rx.maxBufSize        = UART_DEFAULT_MAX_RX_BUFF;
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#-0x80
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  571 	uartConfig.tx.maxBufSize        = UART_DEFAULT_MAX_TX_BUFF;
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#-0x80
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  572 	uartConfig.idleTimeout          = UART_DEFAULT_IDLE_TIMEOUT;
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x6
        MOVX    @DPTR,A
//  573 	uartConfig.intEnable            = TRUE;
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x1
        MOVX    @DPTR,A
//  574 	uartConfig.callBackFunc         = UartProcessData;
        MOV     A,#0x1b
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#??UartProcessData?relay & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(??UartProcessData?relay >> 8) & 0xff
        MOVX    @DPTR,A
//  575 
//  576 	/* Start UART */
//  577 	HalUARTOpen (HAL_UART_PORT_0, &uartConfig);
        ; Setup parameters for call to function HalUARTOpen
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     R1,#0x0
        LCALL   ??HalUARTOpen?relay
//  578 
//  579 	//HalUARTWrite(0,"2015/11/13 OK\r\n",sizeof("2015/11/13 OK\r\n"));
//  580 	//HalUARTPoll();
//  581 	//UartDMAIntSend();
//  582 	
//  583 }
        MOV     A,#0x1d
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        LJMP    ?Subroutine0 & 0xFFFF
        CFI EndBlock cfiBlock31
//  584 
//  585 static void UartRcvHandle(uint8 *rcv,uint8 len)
//  586 {
//  587 	//HalUARTWrite(0,"Receive data\r\n",sizeof("Receive data\r\n"));
//  588 	//UartDMAIntSend();
//  589 	//HalUARTWrite(0,rcv,len);
//  590 	//UartDMAIntSend();
//  591 	//HalUARTPoll();
//  592 	//UartDMAIntSend();
//  593 	return;
//  594 }
//  595 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  596 static void UartProcessData(uint8 port, uint8 event)
UartProcessData:
        CFI Block cfiBlock32 Using cfiCommon0
        CFI Function UartProcessData
        CODE
//  597 {
        FUNCALL UartProcessData, Hal_UART_RxBufLen
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL UartProcessData, osal_memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL UartProcessData, HalUARTRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R1
//  598 	//uint16 rxBufLen  = Hal_UART_RxBufLen(0);
//  599 	//static uint8 rcvLen=0;
//  600 	//unsigned char uartBuf[128];
//  601 	uint8 ch;
//  602 	static uint8 loaden=0;
//  603 	static uint16 bufIndex=0;
//  604 	uint8 rcvLen=0;
//  605 	//unsigned char uartBufIndex=0;
//  606 	//uint16 rxBufLen;
//  607 	
//  608 	rcvLen = Hal_UART_RxBufLen(port);
        ; Setup parameters for call to function Hal_UART_RxBufLen
        LCALL   ??Hal_UART_RxBufLen?relay
        MOV     ?V0 + 2,R2
//  609 	osal_memset(rx_buff, 0x00, RX_TX_BUFFER_SIZE);
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0x32
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     R2,#rx_buff & 0xff
        MOV     R3,#(rx_buff >> 8) & 0xff
        LCALL   ??osal_memset?relay
//  610 	HalUARTRead (port, rx_buff, rcvLen);
        ; Setup parameters for call to function HalUARTRead
        MOV     R4,?V0 + 2
        MOV     R5,#0x0
        MOV     R2,#rx_buff & 0xff
        MOV     R3,#(rx_buff >> 8) & 0xff
        MOV     R1,?V0 + 0
        LCALL   ??HalUARTRead?relay
//  611 
//  612 	UartRcvHandle(&rx_buff[0],rcvLen);
//  613 }
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock32

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for rx_head>`:
        DATA16
        DW rx_buff

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for rx_tail>`:
        DATA16
        DW rx_buff

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for tx_head>`:
        DATA16
        DW tx_buff

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for tx_tail>`:
        DATA16
        DW tx_buff

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uart_intfc_init?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    uart_intfc_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??buffer_free_space?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    buffer_free_space

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??buffer_used_space?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    buffer_used_space

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??push_buffer?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    push_buffer

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??pop_buffer?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    pop_buffer

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??tx_send_wait?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    tx_send_wait

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??tx_send?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    tx_send

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??tx_peek?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    tx_peek

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rx_peek?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rx_peek

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rx_receive?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rx_receive

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uart_busy?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    uart_busy

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??tx_handler?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    tx_handler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rx_handler?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    rx_handler

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??DmaUartInit?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    DmaUartInit

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??UartProcessData?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    UartProcessData

        END
//  614 
//  615 
// 
// 1 203 bytes in segment BANKED_CODE
//    90 bytes in segment BANK_RELAYS
//     1 byte  in segment SFR_AN
//     8 bytes in segment XDATA_I
//     8 bytes in segment XDATA_ID
//   100 bytes in segment XDATA_Z
// 
// 1 301 bytes of CODE  memory
//     0 bytes of DATA  memory (+ 1 byte shared)
//   108 bytes of XDATA memory
//
//Errors: none
//Warnings: 4
