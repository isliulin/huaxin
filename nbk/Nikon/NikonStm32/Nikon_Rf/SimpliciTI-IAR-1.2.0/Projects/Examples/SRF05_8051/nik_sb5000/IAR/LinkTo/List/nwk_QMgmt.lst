###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.4.40412/W32 for 8051         04/Dec/2016  22:37:59 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpli #
#                          citi\nwk\nwk_QMgmt.c                               #
#    Command line       =  -f C:\Users\freeman\Documents\work\NBK\Nikon\Nikon #
#                          Stm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp #
#                          les\SRF05_8051\nik_sb5000\IAR\Configuration\LinkTo #
#                          \smpl_config.dat ("-DTHIS_DEVICE_ADDRESS={0x79,    #
#                          0x56, 0x34, 0x12}" -DxNWK_PLL_REFERENCE_CLOCK      #
#                          -DLINK_TO) -f C:\Users\freeman\Documents\work\NBK\ #
#                          Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Pro #
#                          jects\Examples\SRF05_8051\nik_sb5000\IAR\Configura #
#                          tion\smpl_nwk_config.dat (-DMAX_HOPS=3             #
#                          -DMAX_HOPS_FROM_AP=1 -DMAX_NWK_PAYLOAD=34          #
#                          -DMAX_APP_PAYLOAD=10 -DDEFAULT_LINK_TOKEN=0x010203 #
#                          04 -DDEFAULT_JOIN_TOKEN=0x05060708                 #
#                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK               #
#                          -DxEXTENDED_API -DxSMPL_SECURE                     #
#                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                    #
#                          -DNUM_CONNECTIONS=2 -DSIZE_INFRAME_Q=4             #
#                          -DSIZE_OUTFRAME_Q=2 -DxFREQUENCY_HOPPING           #
#                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                 #
#                          -DUART_NUMBER=UART_NUMBER_0                        #
#                          -DUART_LOCATION=UART_LOCATION_1                    #
#                          -DUART_BAUD_RATE=115200 -DUART_FLOW_CONTROL=UART_F #
#                          LOW_CONTROL_OFF -DUART_PARITY_MODE=UART_PARITY_NON #
#                          E -DUART_STOP_BITS=UART_1_STOP_BIT                 #
#                          -DBSP_TIMER_USED=1 -DEND_DEVICE)                   #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpli #
#                          citi\nwk\nwk_QMgmt.c -D MCU_H=<ioCC2530.h> -D      #
#                          MRFI_CC2530 -D ZTOOL_P1 -lC                        #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\List\ -lA        #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\List\ -o         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\Obj\ -e --debug  #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs    #
#                          16 -I C:\Users\freeman\Documents\work\NBK\Nikon\Ni #
#                          konStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Ex #
#                          amples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Co #
#                          mponents\bsp\ -I C:\Users\freeman\Documents\work\N #
#                          BK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\ #
#                          Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\..\ #
#                          ..\..\..\Components\bsp\drivers\ -I                #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\bsp\boards\CC2530EM\ -I                         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\mrfi\ -I C:\Users\freeman\Documents\work\NBK\Ni #
#                          kon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Proje #
#                          cts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. #
#                          \..\Components\SimpliciTI\nwk\ -I                  #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\Applications\  #
#                          -I C:\Users\freeman\Documents\work\NBK\Nikon\Nikon #
#                          Stm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp #
#                          les\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo #
#                          nents\SimpliciTI\nwk_applications\ -I              #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\OSAL\INCLUDE\ -I C:\Users\freeman\Documents\wor #
#                          k\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2 #
#                          .0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\ #
#                          ..\..\..\..\Components\OSAL\MCU\CCSOC\ -I          #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\HAL\INCLUDE\ -I C:\Users\freeman\Documents\work #
#                          \NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2. #
#                          0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\. #
#                          .\..\..\..\Components\HAL\TARGET\CC2530EB\ -I      #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\SERVICES\SADDR\ -I C:\Users\freeman\Documents\w #
#                          ork\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1 #
#                          .2.0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\. #
#                          .\..\..\..\..\Components\SERVICES\SDATA\ -I        #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MT\ -I C:\Users\freeman\Documents\work\NBK\Niko #
#                          n\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project #
#                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\. #
#                          .\Components\STACK\AF\ -I                          #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\STACK\NWK\ -I C:\Users\freeman\Documents\work\N #
#                          BK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\ #
#                          Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\..\ #
#                          ..\..\..\Components\STACK\SEC\ -I                  #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\STACK\SAPI\ -I C:\Users\freeman\Documents\work\ #
#                          NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0 #
#                          \Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\.. #
#                          \..\..\..\Components\STACK\SYS\ -I                 #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\STACK\ZDO\ -I C:\Users\freeman\Documents\work\N #
#                          BK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\ #
#                          Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\..\ #
#                          ..\..\..\Components\MAC\INCLUDE\ -I                #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MAC\HIGH_LEVEL\ -I C:\Users\freeman\Documents\w #
#                          ork\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1 #
#                          .2.0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\. #
#                          .\..\..\..\..\Components\MAC\LOW_LEVEL\srf04\ -I   #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz           #
#                          --require_prototypes                               #
#    List file          =  C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\List\nwk_QMgmt.l #
#                          st                                                 #
#    Object file        =  C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\Obj\nwk_QMgmt.r5 #
#                          1                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\nwk_QMgmt.c
      1          /**************************************************************************************************
      2            Filename:       nwk_QMgmt.c
      3            Revised:        $Date: 2011-10-26 15:44:58 -0700 (Wed, 26 Oct 2011) $
      4            Revision:       $Revision: 28059 $
      5            Author:         $Author: jnoxon $
      6          
      7            Description:    This file supports the SimpliciTI input and output frame queues
      8          
      9            Copyright 2007-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights granted under
     12            the terms of a software license agreement between the user who downloaded the software,
     13            his/her employer (which must be your employer) and Texas Instruments Incorporated (the
     14            "License"). You may not use this Software unless you agree to abide by the terms of the
     15            License. The License limits your use, and you acknowledge, that the Software may not be
     16            modified, copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio frequency
     18            transceiver, which is integrated into your product. Other than for the foregoing purpose,
     19            you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
     20            perform, display or sell this Software and/or its documentation for any purpose.
     21          
     22            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS”
     23            WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
     24            WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
     25            IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     26            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
     27            THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
     28            INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
     29            DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
     30            THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     31          
     32            Should you have any questions regarding your right to use this Software,
     33            contact Texas Instruments Incorporated at www.TI.com.
     34          **************************************************************************************************/
     35          
     36          
     37          /******************************************************************************
     38           * INCLUDES
     39           */
     40          #include <intrinsics.h>
     41          #include <string.h>
     42          #include "bsp.h"  

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     43          #include "mrfi.h"
     44          #include "nwk_types.h"
     45          #include "nwk.h"
     46          #include "nwk_frame.h"
     47          #include "nwk_QMgmt.h"
     48          #include "nwk_mgmt.h"     /* need offsets for poll frames */
     49          #ifdef DEBUG_CRITICAL_SECTIONS
     50            #include "bsp_leds.h"
     51          #endif
     52          
     53          
     54          /******************************************************************************
     55           * MACROS
     56           */
     57          
     58          /******************************************************************************
     59           * CONSTANTS AND DEFINES
     60           */
     61          
     62          /******************************************************************************
     63           * TYPEDEFS
     64           */
     65          
     66          /******************************************************************************
     67           * LOCAL VARIABLES
     68           */
     69          
     70          #if SIZE_INFRAME_Q > 0

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71          static frameInfo_t   sInFrameQ[SIZE_INFRAME_Q];
   \                     sInFrameQ:
   \   000000                DS 204
   \   0000CC                REQUIRE __INIT_XDATA_Z
     72          #else
     73          static frameInfo_t  *sInFrameQ = NULL;
     74          #endif  /* SIZE_INFRAME_Q > 0 */
     75          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     76          static frameInfo_t   sOutFrameQ[SIZE_OUTFRAME_Q];
   \                     sOutFrameQ:
   \   000000                DS 102
   \   000066                REQUIRE __INIT_XDATA_Z
     77          
     78          /******************************************************************************
     79           * LOCAL FUNCTIONS
     80           */
     81          
     82          /******************************************************************************
     83           * GLOBAL VARIABLES
     84           */
     85          
     86          /******************************************************************************
     87           * GLOBAL FUNCTIONS
     88           */
     89          
     90          /******************************************************************************
     91          * @fn          nwk_QInit
     92          * 
     93          * @brief     Initialize the input and output frame queues to hold no packets. 
     94          * 
     95          * input parameters
     96          * 
     97          * output parameters
     98          * 
     99          * @return   void
    100          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    101          void nwk_QInit(void)
   \                     nwk_QInit:
    102          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    103          #if SIZE_INFRAME_Q > 0
    104            memset(sInFrameQ, 0, sizeof(sInFrameQ));
   \   000005                ; Setup parameters for call to function memset
   \   000005   75..CC       MOV     ?V0 + 0,#-0x34
   \   000008   75..00       MOV     ?V0 + 1,#0x0
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   7C00         MOV     R4,#0x0
   \   000012   7D00         MOV     R5,#0x0
   \   000014   7A..         MOV     R2,#sInFrameQ & 0xff
   \   000016   7B..         MOV     R3,#(sInFrameQ >> 8) & 0xff
   \   000018   12....       LCALL   ??memset?relay
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
    105          #endif  // SIZE_INFRAME_Q > 0
    106            memset(sOutFrameQ, 0, sizeof(sOutFrameQ));
   \   000020                ; Setup parameters for call to function memset
   \   000020   75..66       MOV     ?V0 + 0,#0x66
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7C00         MOV     R4,#0x0
   \   00002A   7D00         MOV     R5,#0x0
   \   00002C   7A..         MOV     R2,#sOutFrameQ & 0xff
   \   00002E   7B..         MOV     R3,#(sOutFrameQ >> 8) & 0xff
   \   000030   12....       LCALL   ??memset?relay
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
    107          }
   \   000038   7F02         MOV     R7,#0x2
   \   00003A   02....       LJMP    ?BANKED_LEAVE_XDATA
    108           
    109          /******************************************************************************
    110           * @fn          nwk_QfindSlot
    111           *
    112           * @brief       Finds a slot to use to retrieve the frame from the radio. It
    113           *              uses a LRU cast-out scheme. It is possible that this routine
    114           *              finds no slot. This can happen if the queue is of size 1 or 2
    115           *              and the Rx interrupt occurs during a retrieval call from an
    116           *              application. There are meta-states for frames as the application
    117           *              looks for the oldest frame on the port being requested.
    118           *
    119           *              This routine is running in interrupt context.
    120           *
    121           * input parameters
    122           * @param   which   - INQ or OUTQ to search
    123           *
    124           * output parameters
    125           *
    126           * @return      Pointer to oldest available frame in the queue
    127           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    128          frameInfo_t *nwk_QfindSlot(uint8_t which)
   \                     nwk_QfindSlot:
    129          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
    130            frameInfo_t *pFI, *oldest= 0, *newFI = 0;
   \   000007   7800         MOV     R0,#0x0
   \   000009   7900         MOV     R1,#0x0
   \   00000B   88..         MOV     ?V0 + 0,R0
   \   00000D   88..         MOV     ?V0 + 1,R0
    131            uint8_t        i, num, newOrder = 0, orderTest;
   \   00000F   7C00         MOV     R4,#0x0
    132          
    133            if (INQ == which)
   \   000011   7401         MOV     A,#0x1
   \   000013   65..         XRL     A,?V0 + 2
   \   000015   7008         JNZ     ??nwk_QfindSlot_0
    134            {
    135              pFI  = sInFrameQ;
   \   000017   7A..         MOV     R2,#sInFrameQ & 0xff
   \   000019   7B..         MOV     R3,#(sInFrameQ >> 8) & 0xff
    136              num  = SIZE_INFRAME_Q;
   \   00001B   7D04         MOV     R5,#0x4
   \   00001D   8006         SJMP    ??nwk_QfindSlot_1
    137            }
    138            else
    139            {
    140              pFI  = sOutFrameQ;
   \                     ??nwk_QfindSlot_0:
   \   00001F   7A..         MOV     R2,#sOutFrameQ & 0xff
   \   000021   7B..         MOV     R3,#(sOutFrameQ >> 8) & 0xff
    141              num  = SIZE_OUTFRAME_Q;
   \   000023   7D02         MOV     R5,#0x2
    142            }
    143          
    144            orderTest = num + 1;
   \                     ??nwk_QfindSlot_1:
   \   000025   7401         MOV     A,#0x1
   \   000027   2D           ADD     A,R5
   \   000028   F5..         MOV     ?V0 + 3,A
    145          
    146            for (i=0; i<num; ++i, ++pFI)
   \   00002A   88..         MOV     ?V0 + 4,R0
   \   00002C   800E         SJMP    ??nwk_QfindSlot_2
    147            {
    148              /* if frame is available it's a candidate. */
    149              if (pFI->fi_usage != FI_AVAILABLE)
    150              {
    151                if (INQ == which)  /* TODO: do cast-out for Tx as well */
    152                {
    153          
    154                  /* need to know the number of occupied slots so we know the age value
    155                   * for the unoccupied slot (if there is one).
    156                   */
    157                  newOrder++;
    158          
    159                  /* make sure nwk_retrieveFrame() is not processing this frame */
    160                  if (FI_INUSE_TRANSITION == pFI->fi_usage)
    161                  {
    162                    continue;
    163                  }
    164                  /* is this frame older than any we've seen? */
    165                  if (orderTest > pFI->orderStamp)
    166                  {
    167                    /* yes. */
    168                    oldest    = pFI;
    169                    orderTest = pFI->orderStamp;
    170                  }
    171                }
    172              }
    173              else
    174              {
    175                if (OUTQ == which)  /* TODO: do cast-out for Tx as well */
    176                {
    177                  return pFI;
    178                }
    179                newFI = pFI;
   \                     ??nwk_QfindSlot_3:
   \   00002E   8A..         MOV     ?V0 + 0,R2
   \   000030   8B..         MOV     ?V0 + 1,R3
   \                     ??nwk_QfindSlot_4:
   \   000032   05..         INC     ?V0 + 4
   \   000034   EA           MOV     A,R2
   \   000035   2433         ADD     A,#0x33
   \   000037   FA           MOV     R2,A
   \   000038   EB           MOV     A,R3
   \   000039   3400         ADDC    A,#0x0
   \   00003B   FB           MOV     R3,A
   \                     ??nwk_QfindSlot_2:
   \   00003C   E5..         MOV     A,?V0 + 4
   \   00003E   C3           CLR     C
   \   00003F   9D           SUBB    A,R5
   \   000040   502B         JNC     ??nwk_QfindSlot_5
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   E0           MOVX    A,@DPTR
   \   000047   601C         JZ      ??nwk_QfindSlot_6
   \   000049   7401         MOV     A,#0x1
   \   00004B   65..         XRL     A,?V0 + 2
   \   00004D   70E3         JNZ     ??nwk_QfindSlot_4
   \   00004F   0C           INC     R4
   \   000050   E0           MOVX    A,@DPTR
   \   000051   6404         XRL     A,#0x4
   \   000053   60DD         JZ      ??nwk_QfindSlot_4
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   FE           MOV     R6,A
   \   000058   C3           CLR     C
   \   000059   95..         SUBB    A,?V0 + 3
   \   00005B   50D5         JNC     ??nwk_QfindSlot_4
   \   00005D   EA           MOV     A,R2
   \   00005E   F8           MOV     R0,A
   \   00005F   EB           MOV     A,R3
   \   000060   F9           MOV     R1,A
   \   000061   8E..         MOV     ?V0 + 3,R6
   \   000063   80CD         SJMP    ??nwk_QfindSlot_4
   \                     ??nwk_QfindSlot_6:
   \   000065   7402         MOV     A,#0x2
   \   000067   65..         XRL     A,?V0 + 2
   \   000069   70C3         JNZ     ??nwk_QfindSlot_3
   \   00006B   803D         SJMP    ??nwk_QfindSlot_7
    180              }
    181            }
    182          
    183            /* did we find anything? */
    184            if (!newFI)
   \                     ??nwk_QfindSlot_5:
   \   00006D   E5..         MOV     A,?V0 + 0
   \   00006F   45..         ORL     A,?V0 + 1
   \   000071   7028         JNZ     ??nwk_QfindSlot_8
    185            {
    186              /* queue was full. cast-out happens here...unless... */
    187              if (!oldest)
   \   000073   E8           MOV     A,R0
   \   000074   49           ORL     A,R1
   \   000075   7006         JNZ     ??nwk_QfindSlot_9
    188              {
    189                /* This can happen if the queue is only of size 1 or 2 and all
    190                 * the frames are in transition when the Rx interrupt occurs.
    191                 */
    192                return (frameInfo_t *)0;
   \   000077   7A00         MOV     R2,#0x0
   \   000079   7B00         MOV     R3,#0x0
   \   00007B   802D         SJMP    ??nwk_QfindSlot_7
    193              }
    194              newFI = oldest;
   \                     ??nwk_QfindSlot_9:
   \   00007D   88..         MOV     ?V0 + 0,R0
   \   00007F   89..         MOV     ?V0 + 1,R1
    195              nwk_QadjustOrder(which, newFI->orderStamp);
   \   000081   85..82       MOV     DPL,?V0 + 0
   \   000084   85..83       MOV     DPH,?V0 + 1
   \   000087   A3           INC     DPTR
   \   000088   AE82         MOV     R6,DPL
   \   00008A   AF83         MOV     R7,DPH
   \   00008C                ; Setup parameters for call to function nwk_QadjustOrder
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   FA           MOV     R2,A
   \   00008E   A9..         MOV     R1,?V0 + 2
   \   000090   12....       LCALL   ??nwk_QadjustOrder?relay
    196              newFI->orderStamp = i;
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   E5..         MOV     A,?V0 + 4
   \   000099   800A         SJMP    ??nwk_QfindSlot_10
    197            }
    198            else
    199            {
    200              /* mark the available slot. */
    201              newFI->orderStamp = ++newOrder;
   \                     ??nwk_QfindSlot_8:
   \   00009B   7401         MOV     A,#0x1
   \   00009D   2C           ADD     A,R4
   \   00009E   85..82       MOV     DPL,?V0 + 0
   \   0000A1   85..83       MOV     DPH,?V0 + 1
   \   0000A4   A3           INC     DPTR
   \                     ??nwk_QfindSlot_10:
   \   0000A5   F0           MOVX    @DPTR,A
    202            }
    203          
    204            return newFI;
   \   0000A6   AA..         MOV     R2,?V0 + 0
   \   0000A8   AB..         MOV     R3,?V0 + 1
   \                     ??nwk_QfindSlot_7:
   \   0000AA   7F05         MOV     R7,#0x5
   \   0000AC   02....       LJMP    ?BANKED_LEAVE_XDATA
    205          }
    206          
    207          /******************************************************************************
    208           * @fn          nwk_QadjustOrder
    209           *
    210           * @brief       Adjusts the age of everyone in the queue newer than the frame
    211           *              being removed.
    212           *
    213           * input parameters
    214           * @param   which   - INQ or OUTQ to adjust
    215           * @param   stamp   - value of frame being removed
    216           *
    217           * output parameters
    218           *
    219           * @return      void
    220           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    221          void nwk_QadjustOrder(uint8_t which, uint8_t stamp)
   \                     nwk_QadjustOrder:
    222          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    223            frameInfo_t *pFI;
    224            uint8_t      i, num;
    225            bspIState_t  intState;
    226          
    227            if (INQ == which)
   \   000005   7401         MOV     A,#0x1
   \   000007   69           XRL     A,R1
   \   000008   7032         JNZ     ??nwk_QadjustOrder_0
    228            {
    229              pFI  = sInFrameQ;
   \   00000A   7C..         MOV     R4,#sInFrameQ & 0xff
   \   00000C   7D..         MOV     R5,#(sInFrameQ >> 8) & 0xff
    230              num  = SIZE_INFRAME_Q;
    231            }
    232            else
    233            {
    234          /*    pFI  = sOutFrameQ; */
    235          /*    num  = SIZE_OUTFRAME_Q; */
    236              return;
    237            }
    238          
    239            BSP_ENTER_CRITICAL_SECTION(intState);
   \   00000E   A2AF         MOV     C,0xa8.7
   \   000010   E4           CLR     A
   \   000011   33           RLC     A
   \   000012   FE           MOV     R6,A
   \   000013   C2AF         CLR     0xa8.7
    240          
    241            for (i=0; i<num; ++i, ++pFI)
   \   000015   7804         MOV     R0,#0x4
    242            {
    243              if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
   \                     ??nwk_QadjustOrder_1:
   \   000017   8C82         MOV     DPL,R4
   \   000019   8D83         MOV     DPH,R5
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   600B         JZ      ??nwk_QadjustOrder_2
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FB           MOV     R3,A
   \   000021   EA           MOV     A,R2
   \   000022   C3           CLR     C
   \   000023   9B           SUBB    A,R3
   \   000024   5003         JNC     ??nwk_QadjustOrder_2
    244              {
    245                pFI->orderStamp--;
   \   000026   E0           MOVX    A,@DPTR
   \   000027   14           DEC     A
   \   000028   F0           MOVX    @DPTR,A
    246              }
    247            }
   \                     ??nwk_QadjustOrder_2:
   \   000029   EC           MOV     A,R4
   \   00002A   2433         ADD     A,#0x33
   \   00002C   FC           MOV     R4,A
   \   00002D   ED           MOV     A,R5
   \   00002E   3400         ADDC    A,#0x0
   \   000030   FD           MOV     R5,A
   \   000031   18           DEC     R0
   \   000032   E8           MOV     A,R0
   \   000033   70E2         JNZ     ??nwk_QadjustOrder_1
    248          
    249            BSP_EXIT_CRITICAL_SECTION(intState);
   \   000035   EE           MOV     A,R6
   \   000036   A2E0         MOV     C,0xE0 /* A   */.0
   \   000038   92AF         MOV     0xa8.7,C
   \   00003A   E5A8         MOV     A,0xa8
    250          
    251            return;
   \                     ??nwk_QadjustOrder_0:
   \   00003C   7F01         MOV     R7,#0x1
   \   00003E   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000041                REQUIRE _A_IEN0
    252          }
    253          
    254          /******************************************************************************
    255           * @fn          nwk_QfindOldest
    256           *
    257           * @brief       Look through frame queue and find the oldest available frame
    258           *              in the context in question. Supports connection-based (user),
    259           *              non-connection based (NWK applications), and the special case
    260           *              of store-and-forward.
    261           *
    262           * input parameters
    263           * @param   which      - INQ or OUTQ to adjust
    264           * @param   rcvContext - context information for finding the oldest
    265           * @param   usage      - normal usage or store-and-forward usage
    266           *
    267           * output parameters
    268           *
    269           * @return      Pointer to frame that is the oldsest on the requested port, or
    270           *              0 if there are none.
    271           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    272          frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
   \                     nwk_QfindOldest:
    273          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7401         MOV     A,#0x1
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E9           MOV     A,R1
   \   000010   F0           MOVX    @DPTR,A
   \   000011   EC           MOV     A,R4
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   F0           MOVX    @DPTR,A
   \   000019   8A..         MOV     ?V0 + 12,R2
   \   00001B   8B..         MOV     ?V0 + 13,R3
    274            uint8_t      i, oldest, num, port;
    275            uint8_t      uType, addr12Compare;
    276            bspIState_t  intState;
    277            frameInfo_t *fPtr = 0, *wPtr;
   \   00001D   75..00       MOV     ?V0 + 4,#0x0
   \   000020   75..00       MOV     ?V0 + 5,#0x0
    278            connInfo_t  *pCInfo = 0;
   \   000023   7E00         MOV     R6,#0x0
   \   000025   7F00         MOV     R7,#0x0
    279            uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;
   \   000027   8E..         MOV     ?V0 + 2,R6
   \   000029   8E..         MOV     ?V0 + 3,R6
   \   00002B   8E..         MOV     ?V0 + 14,R6
   \   00002D   8E..         MOV     ?V0 + 15,R6
    280          
    281            if (INQ == which)
   \   00002F   7401         MOV     A,#0x1
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   6401         XRL     A,#0x1
   \   000037   7026         JNZ     ??nwk_QfindOldest_0
    282            {
    283              wPtr   = sInFrameQ;
   \   000039   75....       MOV     ?V0 + 0,#sInFrameQ & 0xff
   \   00003C   75....       MOV     ?V0 + 1,#(sInFrameQ >> 8) & 0xff
    284              num    = SIZE_INFRAME_Q;
    285              oldest = SIZE_INFRAME_Q+1;
   \   00003F   75..05       MOV     ?V0 + 7,#0x5
    286            }
    287            else
    288            {
    289          /*    pFI  = sOutFrameQ; */
    290          /*    num  = SIZE_OUTFRAME_Q; */
    291              return 0;
    292            }
    293          
    294            if (RCV_APP_LID == rcv->type)
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F8           MOV     R0,A
   \   000048   7401         MOV     A,#0x1
   \   00004A   68           XRL     A,R0
   \   00004B   7034         JNZ     ??nwk_QfindOldest_1
    295            {
    296              pCInfo = nwk_getConnInfo(rcv->t.lid);
   \   00004D                ; Setup parameters for call to function nwk_getConnInfo
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F9           MOV     R1,A
   \   000050   12....       LCALL   ??nwk_getConnInfo?relay
   \   000053   8A..         MOV     ?V0 + 8,R2
   \   000055   8B..         MOV     ?V0 + 9,R3
   \   000057   AE..         MOV     R6,?V0 + 8
   \   000059   AF..         MOV     R7,?V0 + 9
    297              if (!pCInfo)
   \   00005B   EE           MOV     A,R6
   \   00005C   4F           ORL     A,R7
   \   00005D   7007         JNZ     ??nwk_QfindOldest_2
   \                     ??nwk_QfindOldest_0:
   \   00005F   7A00         MOV     R2,#0x0
   \   000061   7B00         MOV     R3,#0x0
   \   000063   02....       LJMP    ??nwk_QfindOldest_3 & 0xFFFF
    298              {
    299                return (frameInfo_t *)0;
    300              }
    301              port   = pCInfo->portRx;
   \                     ??nwk_QfindOldest_2:
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F5..         MOV     ?V0 + 6,A
    302              pAddr2 = pCInfo->peerAddr;
   \   000075   EE           MOV     A,R6
   \   000076   2402         ADD     A,#0x2
   \   000078   F5..         MOV     ?V0 + 14,A
   \   00007A   EF           MOV     A,R7
   \   00007B   3400         ADDC    A,#0x0
   \   00007D   F5..         MOV     ?V0 + 15,A
   \   00007F   8007         SJMP    ??nwk_QfindOldest_4
    303            }
    304            else if (RCV_NWK_PORT == rcv->type)
   \                     ??nwk_QfindOldest_1:
   \   000081   E8           MOV     A,R0
   \   000082   70DB         JNZ     ??nwk_QfindOldest_0
    305            {
    306              port = rcv->t.port;
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F5..         MOV     ?V0 + 6,A
    307            }
    308          #ifdef ACCESS_POINT
    309            else if (RCV_RAW_POLL_FRAME == rcv->type)
    310            {
    311              port   = *(MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_PORT_OS);
    312              pAddr2 = MRFI_P_SRC_ADDR(rcv->t.pkt);
    313              pAddr3 = MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_ADDR_OS;
    314            }
    315          #endif
    316            else
    317            {
    318              return (frameInfo_t *)0;
    319            }
    320          
    321            uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
   \                     ??nwk_QfindOldest_4:
   \   000088   85..82       MOV     DPL,?XSP + 0
   \   00008B   85..83       MOV     DPH,?XSP + 1
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   6401         XRL     A,#0x1
   \   000091   7005         JNZ     ??nwk_QfindOldest_5
   \   000093   75..01       MOV     ?V0 + 8,#0x1
   \   000096   8003         SJMP    ??nwk_QfindOldest_6
   \                     ??nwk_QfindOldest_5:
   \   000098   75..03       MOV     ?V0 + 8,#0x3
    322          
    323            for (i=0; i<num; ++i, ++wPtr)
   \                     ??nwk_QfindOldest_6:
   \   00009B   75..04       MOV     ?V0 + 9,#0x4
    324            {
    325          
    326              BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */
   \                     ??nwk_QfindOldest_7:
   \   00009E   A2AF         MOV     C,0xa8.7
   \   0000A0   E4           CLR     A
   \   0000A1   33           RLC     A
   \   0000A2   F8           MOV     R0,A
   \   0000A3   C2AF         CLR     0xa8.7
    327          
    328              /* only check entries in use and waiting for this port */
    329              if (uType == wPtr->fi_usage)
   \   0000A5   85..82       MOV     DPL,?V0 + 0
   \   0000A8   85..83       MOV     DPH,?V0 + 1
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   65..         XRL     A,?V0 + 8
   \   0000AE   6003         JZ      $+5
   \   0000B0   02....       LJMP    ??nwk_QfindOldest_8 & 0xFFFF
    330              {
    331                wPtr->fi_usage = FI_INUSE_TRANSITION;
   \   0000B3   7404         MOV     A,#0x4
   \   0000B5   F0           MOVX    @DPTR,A
    332          
    333                BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
   \   0000B6   E8           MOV     A,R0
   \   0000B7   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B9   92AF         MOV     0xa8.7,C
   \   0000BB   E5A8         MOV     A,0xa8
    334                /* message sent to this device? */
    335                if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
   \   0000BD   E5..         MOV     A,?V0 + 0
   \   0000BF   240E         ADD     A,#0xe
   \   0000C1   F582         MOV     DPL,A
   \   0000C3   E5..         MOV     A,?V0 + 1
   \   0000C5   3400         ADDC    A,#0x0
   \   0000C7   F583         MOV     DPH,A
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   543F         ANL     A,#0x3f
   \   0000CC   65..         XRL     A,?V0 + 6
   \   0000CE   707B         JNZ     ??nwk_QfindOldest_9
    336                {
    337                  /* Port matches. If the port of interest is a NWK applicaiton we're a
    338                   * match...the NWK applications are not connection-based. If it is a
    339                   * NWK application we need to check the source address for disambiguation.
    340                   * Also need to check source address if it's a raw frame lookup (S&F frame)
    341                   */
    342                  if (RCV_APP_LID == rcv->type)
   \   0000D0   85..82       MOV     DPL,?V0 + 12
   \   0000D3   85..83       MOV     DPH,?V0 + 13
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   6401         XRL     A,#0x1
   \   0000D9   701A         JNZ     ??nwk_QfindOldest_10
    343                  {
    344                    if (SMPL_PORT_USER_BCAST == port)
   \   0000DB   743F         MOV     A,#0x3f
   \   0000DD   65..         XRL     A,?V0 + 6
   \   0000DF   7008         JNZ     ??nwk_QfindOldest_11
    345                    {
    346                      /* guarantee a match... */
    347                      pAddr1 = pCInfo->peerAddr;
   \   0000E1   EE           MOV     A,R6
   \   0000E2   2402         ADD     A,#0x2
   \   0000E4   F5..         MOV     ?V0 + 2,A
   \   0000E6   EF           MOV     A,R7
   \   0000E7   8008         SJMP    ??nwk_QfindOldest_12
    348                    }
    349                    else
    350                    {
    351                      pAddr1 = MRFI_P_SRC_ADDR(&wPtr->mrfiPkt);
   \                     ??nwk_QfindOldest_11:
   \   0000E9   E5..         MOV     A,?V0 + 0
   \   0000EB   240A         ADD     A,#0xa
   \   0000ED   F5..         MOV     ?V0 + 2,A
   \   0000EF   E5..         MOV     A,?V0 + 1
   \                     ??nwk_QfindOldest_12:
   \   0000F1   3400         ADDC    A,#0x0
   \   0000F3   F5..         MOV     ?V0 + 3,A
    352                    }
    353                  }
    354          #ifdef ACCESS_POINT
    355                  else if (RCV_RAW_POLL_FRAME == rcv->type)
    356                  {
    357                    pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
    358                  }
    359          #endif
    360          
    361                  addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
   \                     ??nwk_QfindOldest_10:
   \   0000F5                ; Setup parameters for call to function memcmp
   \   0000F5   75..04       MOV     ?V0 + 10,#0x4
   \   0000F8   75..00       MOV     ?V0 + 11,#0x0
   \   0000FB   78..         MOV     R0,#?V0 + 10
   \   0000FD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000100   AC..         MOV     R4,?V0 + 14
   \   000102   AD..         MOV     R5,?V0 + 15
   \   000104   AA..         MOV     R2,?V0 + 2
   \   000106   AB..         MOV     R3,?V0 + 3
   \   000108   12....       LCALL   ??memcmp?relay
   \   00010B   7402         MOV     A,#0x2
   \   00010D   12....       LCALL   ?DEALLOC_XSTACK8
    362                  if (  (RCV_NWK_PORT == rcv->type) ||
    363                        (!pAddr3 && !addr12Compare) ||
    364                        (pAddr3 && !memcmp(pAddr3, MRFI_P_SRC_ADDR(&wPtr->mrfiPkt), NET_ADDR_SIZE))
    365                     )
   \   000110   85..82       MOV     DPL,?V0 + 12
   \   000113   85..83       MOV     DPH,?V0 + 13
   \   000116   E0           MOVX    A,@DPTR
   \   000117   6003         JZ      ??nwk_QfindOldest_13
   \   000119   EA           MOV     A,R2
   \   00011A   702F         JNZ     ??nwk_QfindOldest_9
    366                  {
    367                    if (wPtr->orderStamp < oldest)
   \                     ??nwk_QfindOldest_13:
   \   00011C   85..82       MOV     DPL,?V0 + 0
   \   00011F   85..83       MOV     DPH,?V0 + 1
   \   000122   A3           INC     DPTR
   \   000123   A882         MOV     R0,DPL
   \   000125   A983         MOV     R1,DPH
   \   000127   E0           MOVX    A,@DPTR
   \   000128   C3           CLR     C
   \   000129   95..         SUBB    A,?V0 + 7
   \   00012B   501E         JNC     ??nwk_QfindOldest_9
    368                    {
    369                      if (fPtr)
   \   00012D   E5..         MOV     A,?V0 + 4
   \   00012F   45..         ORL     A,?V0 + 5
   \   000131   6009         JZ      ??nwk_QfindOldest_14
    370                      {
    371                        /* restore previous oldest one */
    372                        fPtr->fi_usage = uType;
   \   000133   85..82       MOV     DPL,?V0 + 4
   \   000136   85..83       MOV     DPH,?V0 + 5
   \   000139   E5..         MOV     A,?V0 + 8
   \   00013B   F0           MOVX    @DPTR,A
    373                      }
    374                      oldest = wPtr->orderStamp;
   \                     ??nwk_QfindOldest_14:
   \   00013C   8882         MOV     DPL,R0
   \   00013E   8983         MOV     DPH,R1
   \   000140   E0           MOVX    A,@DPTR
   \   000141   F5..         MOV     ?V0 + 7,A
    375                      fPtr   = wPtr;
   \   000143   85....       MOV     ?V0 + 4,?V0 + 0
   \   000146   85....       MOV     ?V0 + 5,?V0 + 1
    376                      continue;
   \   000149   8012         SJMP    ??nwk_QfindOldest_15
    377                    }
    378                    else
    379                    {
    380                      /* not oldest. restore state */
    381                      wPtr->fi_usage = uType;
   \                     ??nwk_QfindOldest_9:
   \   00014B   85..82       MOV     DPL,?V0 + 0
   \   00014E   85..83       MOV     DPH,?V0 + 1
   \   000151   E5..         MOV     A,?V0 + 8
   \   000153   F0           MOVX    @DPTR,A
   \   000154   8007         SJMP    ??nwk_QfindOldest_15
    382                    }
    383                  }
    384                  else
    385                  {
    386                    /* not a match. restore state */
    387                    wPtr->fi_usage = uType;
    388                  }
    389                }
    390                else
    391                {
    392                  /* wrong port. restore state */
    393                  wPtr->fi_usage = uType;
    394                }
    395              }
    396              else
    397              {
    398                BSP_EXIT_CRITICAL_SECTION(intState);
   \                     ??nwk_QfindOldest_8:
   \   000156   E8           MOV     A,R0
   \   000157   A2E0         MOV     C,0xE0 /* A   */.0
   \   000159   92AF         MOV     0xa8.7,C
   \   00015B   E5A8         MOV     A,0xa8
    399              }
    400            }
   \                     ??nwk_QfindOldest_15:
   \   00015D   E5..         MOV     A,?V0 + 0
   \   00015F   2433         ADD     A,#0x33
   \   000161   F5..         MOV     ?V0 + 0,A
   \   000163   E5..         MOV     A,?V0 + 1
   \   000165   3400         ADDC    A,#0x0
   \   000167   F5..         MOV     ?V0 + 1,A
   \   000169   15..         DEC     ?V0 + 9
   \   00016B   E5..         MOV     A,?V0 + 9
   \   00016D   6003         JZ      $+5
   \   00016F   02....       LJMP    ??nwk_QfindOldest_7 & 0xFFFF
    401          
    402            return fPtr;
   \   000172   AA..         MOV     R2,?V0 + 4
   \   000174   AB..         MOV     R3,?V0 + 5
   \                     ??nwk_QfindOldest_3:
   \   000176   7402         MOV     A,#0x2
   \   000178   12....       LCALL   ?DEALLOC_XSTACK8
   \   00017B   7F10         MOV     R7,#0x10
   \   00017D   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000180                REQUIRE _A_IEN0
    403          }
    404          
    405          /******************************************************************************
    406           * @fn          nwk_getQ
    407           *
    408           * @brief       Get location of teh specified frame queue.
    409           *
    410           * input parameters
    411           * @param   which   - INQ or OUTQ to get
    412           *
    413           * output parameters
    414           *
    415           * @return      Pointer to frame queue
    416           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    417          frameInfo_t *nwk_getQ(uint8_t which)
   \                     nwk_getQ:
    418          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    419            return (INQ == which) ? sInFrameQ : sOutFrameQ;
   \   000000   7401         MOV     A,#0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??nwk_getQ_0
   \   000005   7A..         MOV     R2,#sInFrameQ & 0xff
   \   000007   7B..         MOV     R3,#(sInFrameQ >> 8) & 0xff
   \   000009   8004         SJMP    ??nwk_getQ_1
   \                     ??nwk_getQ_0:
   \   00000B   7A..         MOV     R2,#sOutFrameQ & 0xff
   \   00000D   7B..         MOV     R3,#(sOutFrameQ >> 8) & 0xff
   \                     ??nwk_getQ_1:
   \   00000F   02....       LJMP    ?BRET
    420          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_QInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_QInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_QfindSlot?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_QfindSlot

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_QadjustOrder?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_QadjustOrder

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_QfindOldest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_QfindOldest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_getQ?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_getQ
    421          

   Maximum stack usage in bytes:

     Function              ISTACK PSTACK XSTACK
     --------              ------ ------ ------
     nwk_QInit                 0      0     12
       -> memset               0      0     24
       -> memset               0      0     24
     nwk_QadjustOrder          0      0     22
     nwk_QfindOldest           1      0     28
       -> nwk_getConnInfo      0      0     52
       -> memcmp               0      0     56
     nwk_QfindSlot             1      0     13
       -> nwk_QadjustOrder     0      0     26
     nwk_getQ                  0      0      0


   Segment part sizes:

     Function/Label           Bytes
     --------------           -----
     _A_IEN0                     1
     sInFrameQ                 204
     sOutFrameQ                102
     nwk_QInit                  61
     nwk_QfindSlot             175
     nwk_QadjustOrder           65
     nwk_QfindOldest           384
     nwk_getQ                   18
     ??nwk_QInit?relay           6
     ??nwk_QfindSlot?relay       6
     ??nwk_QadjustOrder?relay    6
     ??nwk_QfindOldest?relay     6
     ??nwk_getQ?relay            6

 
 703 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
 306 bytes in segment XDATA_Z
 
 733 bytes of CODE  memory
   0 bytes of DATA  memory (+ 1 byte shared)
 306 bytes of XDATA memory

Errors: none
Warnings: none
