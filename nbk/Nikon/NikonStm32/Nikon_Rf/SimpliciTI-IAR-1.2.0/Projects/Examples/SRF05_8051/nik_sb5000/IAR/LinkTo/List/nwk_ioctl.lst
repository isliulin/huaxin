###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.4.40412/W32 for 8051         04/Dec/2016  22:38:00 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpli #
#                          citi\nwk_applications\nwk_ioctl.c                  #
#    Command line       =  -f C:\Users\freeman\Documents\work\NBK\Nikon\Nikon #
#                          Stm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp #
#                          les\SRF05_8051\nik_sb5000\IAR\Configuration\LinkTo #
#                          \smpl_config.dat ("-DTHIS_DEVICE_ADDRESS={0x79,    #
#                          0x56, 0x34, 0x12}" -DxNWK_PLL_REFERENCE_CLOCK      #
#                          -DLINK_TO) -f C:\Users\freeman\Documents\work\NBK\ #
#                          Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Pro #
#                          jects\Examples\SRF05_8051\nik_sb5000\IAR\Configura #
#                          tion\smpl_nwk_config.dat (-DMAX_HOPS=3             #
#                          -DMAX_HOPS_FROM_AP=1 -DMAX_NWK_PAYLOAD=34          #
#                          -DMAX_APP_PAYLOAD=10 -DDEFAULT_LINK_TOKEN=0x010203 #
#                          04 -DDEFAULT_JOIN_TOKEN=0x05060708                 #
#                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK               #
#                          -DxEXTENDED_API -DxSMPL_SECURE                     #
#                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                    #
#                          -DNUM_CONNECTIONS=2 -DSIZE_INFRAME_Q=4             #
#                          -DSIZE_OUTFRAME_Q=2 -DxFREQUENCY_HOPPING           #
#                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                 #
#                          -DUART_NUMBER=UART_NUMBER_0                        #
#                          -DUART_LOCATION=UART_LOCATION_1                    #
#                          -DUART_BAUD_RATE=115200 -DUART_FLOW_CONTROL=UART_F #
#                          LOW_CONTROL_OFF -DUART_PARITY_MODE=UART_PARITY_NON #
#                          E -DUART_STOP_BITS=UART_1_STOP_BIT                 #
#                          -DBSP_TIMER_USED=1 -DEND_DEVICE)                   #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpli #
#                          citi\nwk_applications\nwk_ioctl.c -D               #
#                          MCU_H=<ioCC2530.h> -D MRFI_CC2530 -D ZTOOL_P1 -lC  #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\List\ -lA        #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\List\ -o         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\Obj\ -e --debug  #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs    #
#                          16 -I C:\Users\freeman\Documents\work\NBK\Nikon\Ni #
#                          konStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Ex #
#                          amples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Co #
#                          mponents\bsp\ -I C:\Users\freeman\Documents\work\N #
#                          BK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\ #
#                          Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\..\ #
#                          ..\..\..\Components\bsp\drivers\ -I                #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\bsp\boards\CC2530EM\ -I                         #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\mrfi\ -I C:\Users\freeman\Documents\work\NBK\Ni #
#                          kon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Proje #
#                          cts\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\.. #
#                          \..\Components\SimpliciTI\nwk\ -I                  #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\Applications\  #
#                          -I C:\Users\freeman\Documents\work\NBK\Nikon\Nikon #
#                          Stm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examp #
#                          les\SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Compo #
#                          nents\SimpliciTI\nwk_applications\ -I              #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\OSAL\INCLUDE\ -I C:\Users\freeman\Documents\wor #
#                          k\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2 #
#                          .0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\ #
#                          ..\..\..\..\Components\OSAL\MCU\CCSOC\ -I          #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\HAL\INCLUDE\ -I C:\Users\freeman\Documents\work #
#                          \NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2. #
#                          0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\. #
#                          .\..\..\..\Components\HAL\TARGET\CC2530EB\ -I      #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\SERVICES\SADDR\ -I C:\Users\freeman\Documents\w #
#                          ork\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1 #
#                          .2.0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\. #
#                          .\..\..\..\..\Components\SERVICES\SDATA\ -I        #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MT\ -I C:\Users\freeman\Documents\work\NBK\Niko #
#                          n\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Project #
#                          s\Examples\SRF05_8051\nik_sb5000\IAR\..\..\..\..\. #
#                          .\Components\STACK\AF\ -I                          #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\STACK\NWK\ -I C:\Users\freeman\Documents\work\N #
#                          BK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\ #
#                          Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\..\ #
#                          ..\..\..\Components\STACK\SEC\ -I                  #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\STACK\SAPI\ -I C:\Users\freeman\Documents\work\ #
#                          NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0 #
#                          \Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\.. #
#                          \..\..\..\Components\STACK\SYS\ -I                 #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\STACK\ZDO\ -I C:\Users\freeman\Documents\work\N #
#                          BK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\ #
#                          Projects\Examples\SRF05_8051\nik_sb5000\IAR\..\..\ #
#                          ..\..\..\Components\MAC\INCLUDE\ -I                #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MAC\HIGH_LEVEL\ -I C:\Users\freeman\Documents\w #
#                          ork\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1 #
#                          .2.0\Projects\Examples\SRF05_8051\nik_sb5000\IAR\. #
#                          .\..\..\..\..\Components\MAC\LOW_LEVEL\srf04\ -I   #
#                          C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\..\..\..\..\..\Componen #
#                          ts\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz           #
#                          --require_prototypes                               #
#    List file          =  C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\List\nwk_ioctl.l #
#                          st                                                 #
#    Object file        =  C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm #
#                          32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Projects\Examples #
#                          \SRF05_8051\nik_sb5000\IAR\LinkTo\Obj\nwk_ioctl.r5 #
#                          1                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\freeman\Documents\work\NBK\Nikon\NikonStm32\Nikon_Rf\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk_applications\nwk_ioctl.c
      1          
      2          /**************************************************************************************************
      3            Filename:       nwk_ioctl.c
      4            Revised:        $Date: 2009-01-13 11:31:14 -0800 (Tue, 13 Jan 2009) $
      5            Revision:       $Revision: 18744 $
      6            Author:         $Author: lfriedman $
      7          
      8            Description:    This file supports the SimpliciTI IOCTL implmentation. This interface
      9                            gives applications access to the "driver" network level functions
     10                            when necessary.
     11          
     12            Copyright 2004-2007 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights granted under
     15            the terms of a software license agreement between the user who downloaded the software,
     16            his/her employer (which must be your employer) and Texas Instruments Incorporated (the
     17            "License"). You may not use this Software unless you agree to abide by the terms of the
     18            License. The License limits your use, and you acknowledge, that the Software may not be
     19            modified, copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio frequency
     21            transceiver, which is integrated into your product. Other than for the foregoing purpose,
     22            you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
     23            perform, display or sell this Software and/or its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS”
     26            WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
     27            WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
     28            IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
     30            THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
     31            INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
     32            DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
     33            THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          **************************************************************************************************/
     38          
     39          
     40          /******************************************************************************
     41           * INCLUDES
     42           */
     43          #include <string.h>
     44          #include "bsp.h"
     45          #include "mrfi.h"
     46          #include "nwk_types.h"
     47          #include "nwk_frame.h"
     48          #include "nwk.h"
     49          #include "nwk_ioctl.h"
     50          #include "nwk_globals.h"
     51          #include "nwk_security.h"
     52          #ifdef ACCESS_POINT
     53          #include "nwk_join.h"
     54          #endif
     55          
     56          #ifdef NWK_PLL
     57          #include "nwk_pll.h"
     58          #endif
     59          /******************************************************************************
     60           * MACROS
     61           */
     62          
     63          /******************************************************************************
     64           * CONSTANTS AND DEFINES
     65           */
     66          
     67          /******************************************************************************
     68           * TYPEDEFS
     69           */
     70          
     71          /******************************************************************************
     72           * LOCAL VARIABLES
     73           */
     74          
     75          /******************************************************************************
     76           * LOCAL FUNCTIONS
     77           */
     78          
     79          /******************************************************************************
     80           * GLOBAL VARIABLES
     81           */
     82          
     83          /******************************************************************************
     84           * GLOBAL FUNCTIONS
     85           */
     86          
     87          
     88          /******************************************************************************
     89           * @fn          nwk_rawSend
     90           *
     91           * @brief       Builds an outut frame based on information provided by the
     92           *              caller. This function allows a raw transmission to the target
     93           *              if the network address is known. this function is used a lot
     94           *              to support NWK applications.
     95           *
     96           * input parameters
     97           * @param   info    - pointer to strcuture containing info on how to build
     98           *                    the outgoing frame.
     99           * output parameters
    100           *
    101           * @return         SMPL_SUCCESS
    102           *                 SMPL_NOMEM       - no room in output frame queue
    103           *                 SMPL_TX_CCA_FAIL - CCA failure
    104           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    105          smplStatus_t nwk_rawSend(ioctlRawSend_t *info)
   \                     nwk_rawSend:
    106          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    107            frameInfo_t *pOutFrame;
    108            uint8_t      hops;
    109          
    110            /* If we know frame is going to or from the AP then we can reduce the hop
    111             * count.
    112             */
    113            switch (info->port)
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   24FD         ADD     A,#-0x3
   \   000016   6007         JZ      ??nwk_rawSend_0
   \   000018   24FE         ADD     A,#-0x2
   \   00001A   6003         JZ      ??nwk_rawSend_0
   \   00001C   14           DEC     A
   \   00001D   7004         JNZ     ??nwk_rawSend_1
    114            {
    115              case SMPL_PORT_JOIN:
    116              case SMPL_PORT_FREQ:
    117              case SMPL_PORT_MGMT:
    118                hops = MAX_HOPS_FROM_AP;
   \                     ??nwk_rawSend_0:
   \   00001F   7D01         MOV     R5,#0x1
    119                break;
   \   000021   8002         SJMP    ??nwk_rawSend_2
    120          
    121              default:
    122                hops = MAX_HOPS;
   \                     ??nwk_rawSend_1:
   \   000023   7D03         MOV     R5,#0x3
    123                break;
    124            }
    125          
    126            if (pOutFrame = nwk_buildFrame(info->port, info->msg, info->len, hops))
   \                     ??nwk_rawSend_2:
   \   000025                ; Setup parameters for call to function nwk_buildFrame
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FC           MOV     R4,A
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FA           MOV     R2,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??nwk_buildFrame?relay
   \   00003D   8A..         MOV     ?V0 + 2,R2
   \   00003F   8B..         MOV     ?V0 + 3,R3
   \   000041   A8..         MOV     R0,?V0 + 2
   \   000043   A9..         MOV     R1,?V0 + 3
   \   000045   E8           MOV     A,R0
   \   000046   FE           MOV     R6,A
   \   000047   E9           MOV     A,R1
   \   000048   FF           MOV     R7,A
   \   000049   E8           MOV     A,R0
   \   00004A   49           ORL     A,R1
   \   00004B   6031         JZ      ??nwk_rawSend_3
    127            {
    128          #ifdef NWK_PLL
    129              // get access to the packet data
    130              void* pkt = MRFI_P_PAYLOAD(&pOutFrame->mrfiPkt)+F_APP_PAYLOAD_OS;
    131              // get a data logging command
    132              const uint8_t cmd = ( pll_cmd_LocateReference | pll_cmd_LocateResponse
    133                                    | pll_cmd_PumpRequest | pll_cmd_PumpResponse );
    134              if( info->port == SMPL_PORT_PLL // if sending to a pll port
    135                     // and its not a data logging packet
    136                     && ( ((pll_Packet_t*)pkt)->Cmd & cmd ) != cmd )
    137              {
    138                // update the transmit time stamp address to point
    139                // into where the message was copied to
    140                MRFI_SetTxTimeStampAddr( &(((pll_Packet_t*)pkt)->Time) );
    141              }
    142          #endif
    143              memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), info->addr, NET_ADDR_SIZE);
   \   00004D                ; Setup parameters for call to function memcpy
   \   00004D   75..04       MOV     ?V0 + 2,#0x4
   \   000050   75..00       MOV     ?V0 + 3,#0x0
   \   000053   78..         MOV     R0,#?V0 + 2
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   85..82       MOV     DPL,?V0 + 0
   \   00005B   85..83       MOV     DPH,?V0 + 1
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FC           MOV     R4,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FD           MOV     R5,A
   \   000063   EE           MOV     A,R6
   \   000064   2406         ADD     A,#0x6
   \   000066   FA           MOV     R2,A
   \   000067   EF           MOV     A,R7
   \   000068   3400         ADDC    A,#0x0
   \   00006A   FB           MOV     R3,A
   \   00006B   12....       LCALL   ??memcpy?relay
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
    144          #ifdef SMPL_SECURE
    145              nwk_setSecureFrame(&pOutFrame->mrfiPkt, info->len, 0);
    146          #endif  /* SMPL_SECURE */
    147              return nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_CCA);
   \   000073                ; Setup parameters for call to function nwk_sendFrame
   \   000073   7901         MOV     R1,#0x1
   \   000075   EE           MOV     A,R6
   \   000076   FA           MOV     R2,A
   \   000077   EF           MOV     A,R7
   \   000078   FB           MOV     R3,A
   \   000079   12....       LCALL   ??nwk_sendFrame?relay
   \   00007C   8002         SJMP    ??nwk_rawSend_4
    148            }
    149            return SMPL_NOMEM;
   \                     ??nwk_rawSend_3:
   \   00007E   7903         MOV     R1,#0x3
   \                     ??nwk_rawSend_4:
   \   000080                REQUIRE ?Subroutine0
   \   000080                ; // Fall through to label ?Subroutine0
    150          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    151          
    152          /******************************************************************************
    153           * @fn          nwk_rawReceive
    154           *
    155           * @brief       Retriievs specified from from the input frame queue. Additional
    156           *              information such as source address and hop count may also be
    157           *              retrieved
    158           *
    159           * input parameters
    160           * @param   info    - pointer to structure containing info on what to retrieve
    161           *
    162           * output parameters - actually populated by nwk_retrieveFrame()
    163           *      info->msg      - application payload copied here
    164           *      info->len      - length of received application payload
    165           *      info->addr     - if non-NULL points to memory to be populated with
    166           *                       source address of retrieved frame.
    167           *      info->hopCount - if non-NULL points to memory to be populated with
    168           *                       hop count of retrieved frame.
    169           *
    170           * @return   Status of operation.
    171           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    172          smplStatus_t nwk_rawReceive(ioctlRawReceive_t *info)
   \                     nwk_rawReceive:
    173          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    174            rcvContext_t rcv;
    175          
    176            rcv.type   = RCV_NWK_PORT;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
    177            rcv.t.port = info->port;
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   7401         MOV     A,#0x1
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   D0E0         POP     A
   \   000025   F0           MOVX    @DPTR,A
    178          
    179            return nwk_retrieveFrame(&rcv, info->msg, &info->len, info->addr, &info->hopCount);
   \   000026                ; Setup parameters for call to function nwk_retrieveFrame
   \   000026   EA           MOV     A,R2
   \   000027   2406         ADD     A,#0x6
   \   000029   F5..         MOV     ?V0 + 0,A
   \   00002B   EB           MOV     A,R3
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   F5..         MOV     ?V0 + 1,A
   \   000030   78..         MOV     R0,#?V0 + 0
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003C   EA           MOV     A,R2
   \   00003D   2404         ADD     A,#0x4
   \   00003F   F5..         MOV     ?V0 + 0,A
   \   000041   EB           MOV     A,R3
   \   000042   3400         ADDC    A,#0x0
   \   000044   F5..         MOV     ?V0 + 1,A
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   8B83         MOV     DPH,R3
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   FC           MOV     R4,A
   \   000053   A3           INC     DPTR
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FD           MOV     R5,A
   \   000056   7406         MOV     A,#0x6
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   AA82         MOV     R2,DPL
   \   00005D   AB83         MOV     R3,DPH
   \   00005F   12....       LCALL   ??nwk_retrieveFrame?relay
   \   000062   7406         MOV     A,#0x6
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   7403         MOV     A,#0x3
   \   000069   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006C                REQUIRE ?Subroutine1
   \   00006C                ; // Fall through to label ?Subroutine1
    180          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    181          
    182          /******************************************************************************
    183           * @fn          nwk_radioControl
    184           *
    185           * @brief       Handle radio control functions.
    186           *
    187           * input parameters
    188           * @param   action   - radio operation to perform. currently suppoerted:
    189           *                         sleep/unsleep
    190           * output parameters
    191           *
    192           * @return   Status of operation.
    193           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    194          smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
   \                     nwk_radioControl:
    195          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    196            smplStatus_t rc = SMPL_SUCCESS;
   \   00000B   75..00       MOV     ?V0 + 0,#0x0
    197          
    198            if (IOCTL_ACT_RADIO_SLEEP == action)
   \   00000E   7404         MOV     A,#0x4
   \   000010   65..         XRL     A,?V0 + 1
   \   000012   7008         JNZ     ??nwk_radioControl_0
    199            {
    200              /* go to sleep mode. */
    201              MRFI_RxIdle();
   \   000014                ; Setup parameters for call to function MRFI_RxIdle
   \   000014   12....       LCALL   ??MRFI_RxIdle?relay
    202              MRFI_Sleep();
   \   000017                ; Setup parameters for call to function MRFI_Sleep
   \   000017   12....       LCALL   ??MRFI_Sleep?relay
   \   00001A   8072         SJMP    ??nwk_radioControl_1
    203            }
    204            else if (IOCTL_ACT_RADIO_AWAKE == action)
   \                     ??nwk_radioControl_0:
   \   00001C   7405         MOV     A,#0x5
   \   00001E   65..         XRL     A,?V0 + 1
   \   000020   7005         JNZ     ??nwk_radioControl_2
    205            {
    206              MRFI_WakeUp();
   \   000022                ; Setup parameters for call to function MRFI_WakeUp
   \   000022   12....       LCALL   ??MRFI_WakeUp?relay
   \   000025   8067         SJMP    ??nwk_radioControl_1
    207          
    208          #if !defined( END_DEVICE )
    209              MRFI_RxOn();
    210          #endif
    211          
    212            }
    213            else if (IOCTL_ACT_RADIO_SIGINFO == action)
   \                     ??nwk_radioControl_2:
   \   000027   7406         MOV     A,#0x6
   \   000029   65..         XRL     A,?V0 + 1
   \   00002B   7037         JNZ     ??nwk_radioControl_3
    214            {
    215              ioctlRadioSiginfo_t *pSigInfo = (ioctlRadioSiginfo_t *)val;
    216              connInfo_t          *pCInfo   = nwk_getConnInfo(pSigInfo->lid);
   \   00002D                ; Setup parameters for call to function nwk_getConnInfo
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F9           MOV     R1,A
   \   000033   12....       LCALL   ??nwk_getConnInfo?relay
    217          
    218              if (!pCInfo)
   \   000036   EA           MOV     A,R2
   \   000037   4B           ORL     A,R3
   \   000038   7004         JNZ     ??nwk_radioControl_4
    219              {
    220                return SMPL_BAD_PARAM;
   \   00003A   7902         MOV     R1,#0x2
   \   00003C   8052         SJMP    ??nwk_radioControl_5
    221              }
    222              memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
   \                     ??nwk_radioControl_4:
   \   00003E                ; Setup parameters for call to function memcpy
   \   00003E   75..02       MOV     ?V0 + 2,#0x2
   \   000041   75..00       MOV     ?V0 + 3,#0x0
   \   000044   78..         MOV     R0,#?V0 + 2
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   EA           MOV     A,R2
   \   00004A   2406         ADD     A,#0x6
   \   00004C   FC           MOV     R4,A
   \   00004D   EB           MOV     A,R3
   \   00004E   3400         ADDC    A,#0x0
   \   000050   FD           MOV     R5,A
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   A3           INC     DPTR
   \   000056   AA82         MOV     R2,DPL
   \   000058   AB83         MOV     R3,DPH
   \   00005A   12....       LCALL   ??memcpy?relay
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   802A         SJMP    ??nwk_radioControl_1
    223            }
    224            else if (IOCTL_ACT_RADIO_RSSI == action)
   \                     ??nwk_radioControl_3:
   \   000064   7407         MOV     A,#0x7
   \   000066   65..         XRL     A,?V0 + 1
   \   000068   700B         JNZ     ??nwk_radioControl_6
    225            {
    226              *((rssi_t *)val) = MRFI_Rssi();
   \   00006A                ; Setup parameters for call to function MRFI_Rssi
   \   00006A   12....       LCALL   ??MRFI_Rssi?relay
   \   00006D   E9           MOV     A,R1
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   F0           MOVX    @DPTR,A
   \   000073   8019         SJMP    ??nwk_radioControl_1
    227            }
    228            else if (IOCTL_ACT_RADIO_RXON == action)
   \                     ??nwk_radioControl_6:
   \   000075   7408         MOV     A,#0x8
   \   000077   65..         XRL     A,?V0 + 1
   \   000079   7005         JNZ     ??nwk_radioControl_7
    229            {
    230              MRFI_RxOn();
   \   00007B                ; Setup parameters for call to function MRFI_RxOn
   \   00007B   12....       LCALL   ??MRFI_RxOn?relay
   \   00007E   800E         SJMP    ??nwk_radioControl_1
    231            }
    232            else if (IOCTL_ACT_RADIO_RXIDLE == action)
   \                     ??nwk_radioControl_7:
   \   000080   7409         MOV     A,#0x9
   \   000082   65..         XRL     A,?V0 + 1
   \   000084   7005         JNZ     ??nwk_radioControl_8
    233            {
    234              MRFI_RxIdle();
   \   000086                ; Setup parameters for call to function MRFI_RxIdle
   \   000086   12....       LCALL   ??MRFI_RxIdle?relay
   \   000089   8003         SJMP    ??nwk_radioControl_1
    235            }
    236          #ifdef EXTENDED_API
    237            else if (IOCTL_ACT_RADIO_SETPWR == action)
    238            {
    239              uint8_t idx;
    240          
    241              switch (*(ioctlLevel_t *)val)
    242              {
    243                case IOCTL_LEVEL_2:
    244                  idx = 2;
    245                  break;
    246          
    247                case IOCTL_LEVEL_1:
    248                  idx = 1;
    249                  break;
    250          
    251                case IOCTL_LEVEL_0:
    252                  idx = 0;
    253                  break;
    254          
    255                default:
    256                  return SMPL_BAD_PARAM;
    257              }
    258              MRFI_SetRFPwr(idx);
    259              return SMPL_SUCCESS;
    260            }
    261          #endif  /* EXTENDED_API */
    262            else
    263            {
    264              rc = SMPL_BAD_PARAM;
   \                     ??nwk_radioControl_8:
   \   00008B   75..02       MOV     ?V0 + 0,#0x2
    265            }
    266            return rc;
   \                     ??nwk_radioControl_1:
   \   00008E   A9..         MOV     R1,?V0 + 0
   \                     ??nwk_radioControl_5:
   \   000090   02....       LJMP    ?Subroutine0 & 0xFFFF
    267          }
    268          
    269          /******************************************************************************
    270           * @fn          nwk_joinContext
    271           *
    272           * @brief       For Access Points we need a way to support changing the Join
    273           *              context. This will allow arbitration bewteen potentially nearby
    274           *              Access Points when a new device is joining.
    275           *
    276           * input parameters
    277           * @param   action  - Join context is either on or off.
    278           *
    279           * output parameters
    280           *
    281           * @return   Status of operation. Currently always succeeds.
    282           */
    283          #ifdef ACCESS_POINT
    284          smplStatus_t nwk_joinContext(ioctlAction_t action)
    285          {
    286            nwk_setJoinContext((IOCTL_ACT_ON == action) ? JOIN_CONTEXT_ON : JOIN_CONTEXT_OFF);
    287          
    288            return SMPL_SUCCESS;
    289          }
    290          #endif
    291          
    292          /******************************************************************************
    293           * @fn          nwk_deviceAddress
    294           *
    295           * @brief       Set or Get this device address. The Set must be done before
    296           *              SMPL_Init() for it to take effect. The Get is always legal but
    297           *              the value could be invalid if it is called before a valid set
    298           *              call is made.
    299           *
    300           * input parameters
    301           * @param   action  - Gte or Set
    302           * @param   addr    - pointer to address object containing value on Set
    303           *
    304           * output parameters
    305           * @param   addr    - pointer to address object to receive value on Get.
    306           *
    307           * @return   SMPL_SUCCESS
    308           *           SMPL_BAD_PARAM  Action request illegal or a Set request
    309           *                           was not respected.
    310           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    311          smplStatus_t nwk_deviceAddress(ioctlAction_t action, addr_t *addr)
   \                     nwk_deviceAddress:
    312          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    313            smplStatus_t rc = SMPL_BAD_PARAM;
   \   00000B   75..02       MOV     ?V0 + 0,#0x2
    314          
    315            if (IOCTL_ACT_GET == action)
   \   00000E   7401         MOV     A,#0x1
   \   000010   65..         XRL     A,?V0 + 1
   \   000012   7020         JNZ     ??nwk_deviceAddress_0
    316            {
    317              memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
   \   000014                ; Setup parameters for call to function memcpy
   \   000014   75..04       MOV     ?V0 + 2,#0x4
   \   000017   75..00       MOV     ?V0 + 3,#0x0
   \   00001A   78..         MOV     R0,#?V0 + 2
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F                ; Setup parameters for call to function nwk_getMyAddress
   \   00001F   12....       LCALL   ??nwk_getMyAddress?relay
   \   000022   EA           MOV     A,R2
   \   000023   FC           MOV     R4,A
   \   000024   EB           MOV     A,R3
   \   000025   FD           MOV     R5,A
   \   000026   EE           MOV     A,R6
   \   000027   FA           MOV     R2,A
   \   000028   EF           MOV     A,R7
   \   000029   FB           MOV     R3,A
   \   00002A   12....       LCALL   ??memcpy?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
    318              rc = SMPL_SUCCESS;
   \   000032   8009         SJMP    ??nwk_deviceAddress_1
    319            }
    320            else if (IOCTL_ACT_SET == action)
   \                     ??nwk_deviceAddress_0:
   \   000034   E9           MOV     A,R1
   \   000035   7009         JNZ     ??nwk_deviceAddress_2
    321            {
    322              if (nwk_setMyAddress(addr))
   \   000037                ; Setup parameters for call to function nwk_setMyAddress
   \   000037   12....       LCALL   ??nwk_setMyAddress?relay
   \   00003A   E9           MOV     A,R1
   \   00003B   6003         JZ      ??nwk_deviceAddress_2
    323              {
    324                rc = SMPL_SUCCESS;
   \                     ??nwk_deviceAddress_1:
   \   00003D   75..00       MOV     ?V0 + 0,#0x0
    325              }
    326            }
    327          
    328            return rc;
   \                     ??nwk_deviceAddress_2:
   \   000040   A9..         MOV     R1,?V0 + 0
   \   000042   02....       LJMP    ?Subroutine0 & 0xFFFF
    329          }
    330          
    331          /******************************************************************************
    332           * @fn          nwk_connectionControl
    333           *
    334           * @brief       Access to connection table. Currently supports only deleting
    335           *              a connection from the table.
    336           *
    337           * input parameters
    338           * @param   action  - Connection control action (only delete is curently valid).
    339           * @param   val     - pointer to Link ID of connection on which to operate.
    340           *
    341           * output parameters
    342           *
    343           * @return   SMPL_SUCCESS
    344           *           SMPL_BAD_PARAM  Action is not delete
    345           *                           Link ID is the UUD Link ID
    346           *                           No connection table info for Link ID
    347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          smplStatus_t nwk_connectionControl(ioctlAction_t action, void *val)
   \                     nwk_connectionControl:
    349          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    350            connInfo_t *pCInfo;
    351            linkID_t    lid = *((linkID_t *)val);
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
    352          
    353            if (IOCTL_ACT_DELETE != action)
   \   00000D   740E         MOV     A,#0xe
   \   00000F   6E           XRL     A,R6
   \   000010   6004         JZ      ??nwk_connectionControl_0
    354            {
    355              return SMPL_BAD_PARAM;
   \                     ??nwk_connectionControl_1:
   \   000012   7902         MOV     R1,#0x2
   \   000014   8011         SJMP    ??nwk_connectionControl_2
    356            }
    357          
    358            if ((SMPL_LINKID_USER_UUD == lid) ||
    359                (!(pCInfo=nwk_getConnInfo(lid))))
   \                     ??nwk_connectionControl_0:
   \   000016   74FF         MOV     A,#-0x1
   \   000018   69           XRL     A,R1
   \   000019   60F7         JZ      ??nwk_connectionControl_1
   \   00001B                ; Setup parameters for call to function nwk_getConnInfo
   \   00001B   12....       LCALL   ??nwk_getConnInfo?relay
   \   00001E   EA           MOV     A,R2
   \   00001F   4B           ORL     A,R3
   \   000020   60F0         JZ      ??nwk_connectionControl_1
    360            {
    361              return SMPL_BAD_PARAM;
    362            }
    363          
    364            nwk_freeConnection(pCInfo);
   \   000022                ; Setup parameters for call to function nwk_freeConnection
   \   000022   12....       LCALL   ??nwk_freeConnection?relay
    365          
    366            return SMPL_SUCCESS;
   \   000025   7900         MOV     R1,#0x0
   \                     ??nwk_connectionControl_2:
   \   000027   02....       LJMP    ?Subroutine1 & 0xFFFF
    367          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_rawSend?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_rawSend

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_rawReceive?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_rawReceive

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_radioControl?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_radioControl

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_deviceAddress?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_deviceAddress

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??nwk_connectionControl?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    nwk_connectionControl

   Maximum stack usage in bytes:

     Function                ISTACK PSTACK XSTACK
     --------                ------ ------ ------
     nwk_connectionControl       0      0     10
       -> nwk_getConnInfo        0      0     20
       -> nwk_freeConnection     0      0     20
     nwk_deviceAddress           0      0     14
       -> nwk_getMyAddress       0      0     28
       -> memcpy                 0      0     28
       -> nwk_setMyAddress       0      0     24
     nwk_radioControl            1      0     14
       -> MRFI_RxIdle            0      0     24
       -> MRFI_Sleep             0      0     24
       -> MRFI_WakeUp            0      0     24
       -> nwk_getConnInfo        0      0     24
       -> memcpy                 0      0     28
       -> MRFI_Rssi              0      0     24
       -> MRFI_RxOn              0      0     24
       -> MRFI_RxIdle            0      0     24
     nwk_rawReceive              1      0     19
       -> nwk_retrieveFrame      0      0     38
     nwk_rawSend                 0      0     14
       -> nwk_buildFrame         0      0     24
       -> memcpy                 0      0     28
       -> nwk_sendFrame          0      0     24


   Segment part sizes:

     Function/Label                Bytes
     --------------                -----
     nwk_rawSend                    128
     ?Subroutine0                     5
     nwk_rawReceive                 108
     ?Subroutine1                     5
     nwk_radioControl               147
     nwk_deviceAddress               69
     nwk_connectionControl           42
     ??nwk_rawSend?relay              6
     ??nwk_rawReceive?relay           6
     ??nwk_radioControl?relay         6
     ??nwk_deviceAddress?relay        6
     ??nwk_connectionControl?relay    6

 
 504 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
 
 534 bytes of CODE memory

Errors: none
Warnings: none
