///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.4.40412/W32 for 8051        06/Nov/2016  20:51:49 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  near                                              /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//    Source file        =  C:\Users\freeman\Documents\work\NBK\Canon\Nbk600E /
//                          X - RF\Components\hal\target\CC2530EB\hal_flash.c /
//    Command line       =  "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Components\hal\target\CC2530EB\hal_flash. /
//                          c" -D HAL_OAD_BOOT_CODE -lC                       /
//                          "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Projects\zstack\Utilities\OAD\CC2530DB\OA /
//                          D-Boot\List\" -lA "C:\Users\freeman\Documents\wor /
//                          k\NBK\Canon\Nbk600EX - RF\Projects\zstack\Utiliti /
//                          es\OAD\CC2530DB\OAD-Boot\List\" --remarks -o      /
//                          "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Projects\zstack\Utilities\OAD\CC2530DB\OA /
//                          D-Boot\Obj\" -e --debug --core=plain --dptr=16,1  /
//                          --data_model=large --code_model=near              /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data --nr_virtual_regs 16 -I    /
//                          "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Projects\zstack\Utilities\OAD\CC2530DB\"  /
//                          -I "C:\Users\freeman\Documents\work\NBK\Canon\Nbk /
//                          600EX - RF\Projects\zstack\Utilities\OAD\CC2530DB /
//                          \SOURCE\" -I "C:\Users\freeman\Documents\work\NBK /
//                          \Canon\Nbk600EX - RF\Projects\zstack\Utilities\OA /
//                          D\CC2530DB\..\..\..\Tools\CC2530DB\" -I           /
//                          "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Projects\zstack\Utilities\OAD\CC2530DB\.. /
//                          \..\..\ZMAIN\TI2530DB\" -I                        /
//                          "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Projects\zstack\Utilities\OAD\CC2530DB\.. /
//                          \..\..\..\..\COMPONENTS\HAL\INCLUDE\" -I          /
//                          "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Projects\zstack\Utilities\OAD\CC2530DB\.. /
//                          \..\..\..\..\COMPONENTS\OSAL\INCLUDE\" -Ohz       /
//                          --require_prototypes --mfc                        /
//                          --discard_unused_publics                          /
//                          "C:\Users\freeman\Documents\work\NBK\Canon\Nbk600 /
//                          EX - RF\Components\hal\target\CC2530EB\hal_oad.c" /
//                           "C:\Users\freeman\Documents\work\NBK\Canon\Nbk60 /
//                          0EX - RF\Components\hal\target\CC2530EB\hal_uart. /
//                          c"                                                /
//    List file          =  C:\Users\freeman\Documents\work\NBK\Canon\Nbk600E /
//                          X - RF\Projects\zstack\Utilities\OAD\CC2530DB\OAD /
//                          -Boot\List\hal_flash.s51                          /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME hal_flash

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "near"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?L_EQ_X
        EXTERN ?L_MOV_X
        EXTERN ?MOVE_LONG8_XDATA_XDATA
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?US_SHR
        EXTERN ?V0
        EXTERN ?XLOAD_R2345
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTORE_R2345
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        FUNCTION ??HalFlashWriteTrigger,0203H
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION ??MemReadRam,0203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        FUNCTION ??Message_Rcv,021203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 9, STACK
        FUNCTION ??Message_Send,021203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        FUNCTION ??RcvData,0203H
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION ??SendData,0203H
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCTION ??Uart_Send_String,0203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 8, STACK
        FUNCTION ??delay,0203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCTION ??halAesEncrDecr,0203H
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 17, STACK
        FUNCTION ??halAesLoadKeyOrInitVector,0203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        FUNCTION ??putsDialog,021203H
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBWEAK CLKCONCMD
        PUBWEAK CLKCONSTA
        PUBWEAK DMA0CFGH
        PUBWEAK DMA0CFGL
        PUBWEAK DMAARM
        PUBWEAK DMAIRQ
        PUBWEAK ENCCS
        PUBWEAK ENCDI
        PUBWEAK ENCDO
        PUBLIC HalFlashRead
        FUNCTION HalFlashRead,0203H
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC HalFlashWrite
        FUNCTION HalFlashWrite,021203H
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBWEAK MEMCTR
        PUBWEAK P0DIR
        PUBWEAK P0INP
        PUBWEAK P0SEL
        PUBWEAK P1DIR
        PUBWEAK P2DIR
        PUBWEAK PERCFG
        PUBWEAK SLEEPCMD
        PUBWEAK SLEEPSTA
        PUBWEAK U0BAUD
        PUBWEAK U0CSR
        PUBWEAK U0DBUF
        PUBWEAK U0GCR
        PUBWEAK _A_IRCON2
        PUBWEAK _A_P0
        PUBWEAK _A_P1
        PUBWEAK _A_TCON
        PUBWEAK __Constant_3a4d3254
        PUBWEAK __Constant_f8900a6
        PUBLIC dmaCh0
        PUBLIC main
        FUNCTION main,0a1a03H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 38, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:16, ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
// C:\Users\freeman\Documents\work\NBK\Canon\Nbk600EX - RF\Components\hal\target\CC2530EB\hal_flash.c
//    1 /**************************************************************************************************
//    2   Filename:       _hal_flash.c
//    3   Revised:        $Date:$
//    4   Revision:       $Revision:$
//    5 
//    6   Description: This file contains the interface to the H/W Flash driver.
//    7 
//    8 
//    9   Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 #include "hal_board_cfg.h"

        ASEGN SFR_AN:DATA:NOROOT,080H
// union <unnamed> volatile __sfr _A_P0
_A_P0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,086H
// unsigned char volatile __sfr U0CSR
U0CSR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,088H
// union <unnamed> volatile __sfr _A_TCON
_A_TCON:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,08fH
// unsigned char volatile __sfr P0INP
P0INP:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,090H
// union <unnamed> volatile __sfr _A_P1
_A_P1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09dH
// unsigned char volatile __sfr SLEEPSTA
SLEEPSTA:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09eH
// unsigned char volatile __sfr CLKCONSTA
CLKCONSTA:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b1H
// unsigned char volatile __sfr ENCDI
ENCDI:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b2H
// unsigned char volatile __sfr ENCDO
ENCDO:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0b3H
// unsigned char volatile __sfr ENCCS
ENCCS:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0beH
// unsigned char volatile __sfr SLEEPCMD
SLEEPCMD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c1H
// unsigned char volatile __sfr U0DBUF
U0DBUF:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c2H
// unsigned char volatile __sfr U0BAUD
U0BAUD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c5H
// unsigned char volatile __sfr U0GCR
U0GCR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c6H
// unsigned char volatile __sfr CLKCONCMD
CLKCONCMD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c7H
// unsigned char volatile __sfr MEMCTR
MEMCTR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d1H
// unsigned char volatile __sfr DMAIRQ
DMAIRQ:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d4H
// unsigned char volatile __sfr DMA0CFGL
DMA0CFGL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d5H
// unsigned char volatile __sfr DMA0CFGH
DMA0CFGH:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0d6H
// unsigned char volatile __sfr DMAARM
DMAARM:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e8H
// union <unnamed> volatile __sfr _A_IRCON2
_A_IRCON2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f1H
// unsigned char volatile __sfr PERCFG
PERCFG:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0f3H
// unsigned char volatile __sfr P0SEL
P0SEL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0fdH
// unsigned char volatile __sfr P0DIR
P0DIR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0feH
// unsigned char volatile __sfr P1DIR
P1DIR:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0ffH
// unsigned char volatile __sfr P2DIR
P2DIR:
        DATA8
        DS 1
//   46 #include "hal_dma.h"
//   47 #include "hal_flash.h"
//   48 #include "hal_types.h"
//   49 
//   50 /* ------------------------------------------------------------------------------------------------
//   51  *                                           Macros
//   52  * ------------------------------------------------------------------------------------------------
//   53  */
//   54 
//   55 /* ------------------------------------------------------------------------------------------------
//   56  *                                          Constants
//   57  * ------------------------------------------------------------------------------------------------
//   58  */
//   59 
//   60 // These values depend on RAM_CODE_FLASH in the .xcl file used.
//   61 #if defined CC2530F64     // RemoTI is using 0x01DDD --> pg 3, offset 0x5DD.
//   62 #define OSET_OF_RAM_CODE  0x5DD
//   63 #define PAGE_OF_RAM_CODE  3
//   64 #define SIZE_OF_RAM_CODE  0x23
//   65 #elif defined HAL_OAD_BOOT_CODE
//   66                           // OAD boot code is using 0x7E3 --> pg 0, so same as offset 0x7E3.
//   67 #define OSET_OF_RAM_CODE  0x7E3
//   68 #define PAGE_OF_RAM_CODE  0
//   69 #define SIZE_OF_RAM_CODE  0x1D
//   70 #elif defined HAL_USB_BOOT_CODE
//   71                           // USB boot code is using 0x7DD --> pg 0, so same as offset 0x7DD.
//   72 #define OSET_OF_RAM_CODE  0x7DD
//   73 #define PAGE_OF_RAM_CODE  0
//   74 #define SIZE_OF_RAM_CODE  0x23
//   75 #else                     // Z-Stack is using 0x39EDD --> pg 51, offset 0x6DD.
//   76 #define OSET_OF_RAM_CODE  0x6DD
//   77 #define PAGE_OF_RAM_CODE  51
//   78 #define SIZE_OF_RAM_CODE  0x23
//   79 #endif
//   80 
//   81 /* ------------------------------------------------------------------------------------------------
//   82  *                                          Typedefs
//   83  * ------------------------------------------------------------------------------------------------
//   84  */
//   85 
//   86 /* ------------------------------------------------------------------------------------------------
//   87  *                                       Global Variables
//   88  * ------------------------------------------------------------------------------------------------
//   89  */
//   90 
//   91 /* ------------------------------------------------------------------------------------------------
//   92  *                                       Global Functions
//   93  * ------------------------------------------------------------------------------------------------
//   94  */
//   95 
//   96 /* ------------------------------------------------------------------------------------------------
//   97  *                                       Local Variables
//   98  * ------------------------------------------------------------------------------------------------
//   99  */
//  100 
//  101 #pragma location="RAM_CODE_XDATA"

        RSEG RAM_CODE_XDATA:XDATA:REORDER:NOROOT(0)
        DATA8
//  102 static __no_init uint8 ramCode[SIZE_OF_RAM_CODE];
??ramCode:
        DS 29
//  103 
//  104 /* ------------------------------------------------------------------------------------------------
//  105  *                                       Local Functions
//  106  * ------------------------------------------------------------------------------------------------
//  107  */
//  108 
//  109 #pragma location="RAM_CODE_FLASH"
//  110 #if defined HAL_OAD_BOOT_CODE
//  111 static void HalFlashWriteTrigger(void);
//  112 #else
//  113 static __monitor void HalFlashWriteTrigger(void);
//  114 #endif
//  115 
//  116 /**************************************************************************************************
//  117  * @fn          HalFlashInit
//  118  *
//  119  * @brief       This function initializes the environment for this module.
//  120  *
//  121  * input parameters
//  122  *
//  123  * None.
//  124  *
//  125  * output parameters
//  126  *
//  127  * None.
//  128  *
//  129  * @return      None.
//  130  **************************************************************************************************
//  131  */
//  132 void HalFlashInit(void)
//  133 {
//  134   // Load the code to run from RAM into its reserved area of RAM once at startup.
//  135   HalFlashRead(PAGE_OF_RAM_CODE, OSET_OF_RAM_CODE, ramCode, SIZE_OF_RAM_CODE);
//  136 }
//  137 
//  138 
//  139 /**************************************************************************************************
//  140  * @fn          HalFlashRead
//  141  *
//  142  * @brief       This function reads 'cnt' bytes from the internal flash.
//  143  *
//  144  * input parameters
//  145  *
//  146  * @param       pg - A valid flash page number.
//  147  * @param       offset - A valid offset into the page.
//  148  * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
//  149  * @param       cnt - A valid number of bytes to read.
//  150  *
//  151  * output parameters
//  152  *
//  153  * None.
//  154  *
//  155  * @return      None.
//  156  **************************************************************************************************
//  157  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  158 void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
HalFlashRead:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function HalFlashRead
        CODE
//  159 {
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
        MOV     ?V0 + 0,R1
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  160   // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
//  161   uint8 *ptr = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
//  162                ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
        MOV     A,#0xf
        ANL     A,?V0 + 0
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,#0x0
        MOV     A,#0xb
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,R2
        ADD     A,#0x0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,#-0x80
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x0
        MOV     A,R1
        ADDC    A,?V0 + 3
        MOV     R1,A
//  163   uint8 memctr = MEMCTR;  // Save to restore.
        MOV     A,0xc7
        MOV     ?V0 + 1,A
//  164 
//  165 #if !defined HAL_OAD_BOOT_CODE
//  166   halIntState_t is;
//  167 #endif
//  168 
//  169   pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
//  170 
//  171 #if !defined HAL_OAD_BOOT_CODE
//  172   HAL_ENTER_CRITICAL_SECTION(is);
//  173 #endif
//  174 
//  175   // Calculate and map the containing flash bank into XDATA.
//  176   MEMCTR = (MEMCTR & 0xF8) | pg;
        MOV     A,?V0 + 0
        SWAP    A
        ANL     A,#0xf
        MOV     R2,A
        MOV     A,0xc7
        ANL     A,#0xf8
        ORL     A,R2
        MOV     0xc7,A
        SJMP    ??HalFlashRead_0
//  177 
//  178   while (cnt--)
//  179   {
//  180     *buf++ = *ptr++;
??HalFlashRead_1:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  181   }
??HalFlashRead_0:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     A,R2
        ADD     A,#-0x1
        DEC     R6
        MOV     A,R3
        ADDC    A,#-0x1
        MOV     R7,A
        MOV     A,R2
        ORL     A,R3
        JNZ     ??HalFlashRead_1
//  182 
//  183   MEMCTR = memctr;
        MOV     0xc7,?V0 + 1
//  184 
//  185 #if !defined HAL_OAD_BOOT_CODE
//  186   HAL_EXIT_CRITICAL_SECTION(is);
//  187 #endif
//  188 }
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock0
        REQUIRE MEMCTR
//  189 
//  190 /**************************************************************************************************
//  191  * @fn          HalFlashWrite
//  192  *
//  193  * @brief       This function writes 'cnt' bytes to the internal flash.
//  194  *
//  195  * input parameters
//  196  *
//  197  * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
//  198  * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
//  199  * @param       cnt - Number of 4-byte blocks to write.
//  200  *
//  201  * output parameters
//  202  *
//  203  * None.
//  204  *
//  205  * @return      None.
//  206  **************************************************************************************************
//  207  */
//  208  #if HAL_DMA

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  209 void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
HalFlashWrite:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function HalFlashWrite
        CODE
//  210 {
        FUNCALL HalFlashWrite, ??HalFlashWriteTrigger
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
//  211   halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
//  212 
//  213   HAL_DMA_SET_SOURCE(ch, buf);
        MOV     A,R5
        MOV     DPTR,#dmaCh0
        MOVX    @DPTR,A
        MOV     A,R4
        INC     DPTR
        MOVX    @DPTR,A
//  214   HAL_DMA_SET_DEST(ch, &FWDATA);
        INC     DPTR
        MOV     A,#0x62
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x73
        MOVX    @DPTR,A
//  215   HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x1f
        MOVX    @DPTR,A
//  216   HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
        MOV     A,?V0 + 0
        RLC     A
        RLC     A
        ANL     A,#0xfc
        INC     DPTR
        MOVX    @DPTR,A
        MOV     A,#0x6
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
        MOV     A,?V0 + 0
        MOV     DPTR,#dmaCh0 + 4
        MOVX    @DPTR,A
//  217   HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
//  218   HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
//  219   HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
        MOV     DPTR,#dmaCh0 + 6
        MOV     A,#0x12
        MOVX    @DPTR,A
//  220   HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
//  221   HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
//  222   // The DMA is to be polled and shall not issue an IRQ upon completion.
//  223   HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
//  224   HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
//  225   HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
        INC     DPTR
        MOV     A,#0x42
        MOVX    @DPTR,A
//  226   HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
        ANL     0xd1,#0xfe
//  227   HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
        MOV     0xd6,#0x1
//  228 
//  229   FADDRL = (uint8)addr;
        MOV     A,R2
        MOV     DPTR,#0x6271
        MOVX    @DPTR,A
//  230   FADDRH = (uint8)(addr >> 8);
        MOV     A,R3
        INC     DPTR
        MOVX    @DPTR,A
//  231   HalFlashWriteTrigger();
        ; Setup parameters for call to function HalFlashWriteTrigger
        LCALL   ??HalFlashWriteTrigger
//  232 }
        LJMP    ?Subroutine0
        CFI EndBlock cfiBlock1
        REQUIRE DMAIRQ
        REQUIRE DMAARM
//  233 #else
//  234 void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
//  235 {
//  236   return;
//  237 }
//  238  #endif
//  239 
//  240 /**************************************************************************************************
//  241  * @fn          HalFlashErase
//  242  *
//  243  * @brief       This function erases the specified page of the internal flash.
//  244  *
//  245  * input parameters
//  246  *
//  247  * @param       pg - A valid flash page number to erase.
//  248  *
//  249  * output parameters
//  250  *
//  251  * None.
//  252  *
//  253  * @return      None.
//  254  **************************************************************************************************
//  255  */
//  256 void HalFlashErase(uint8 pg)
//  257 {
//  258   FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
//  259   FCTL |= 0x01;
//  260 }
//  261 
//  262 /**************************************************************************************************
//  263  * @fn          HalFlashWriteTrigger
//  264  *
//  265  * @brief       This function must be copied to RAM before running because it triggers and then
//  266  *              awaits completion of Flash write, which can only be done from RAM.
//  267  *
//  268  * input parameters
//  269  *
//  270  * None.
//  271  *
//  272  * output parameters
//  273  *
//  274  * None.
//  275  *
//  276  * @return      None.
//  277  **************************************************************************************************
//  278  */
//  279 #if defined HAL_OAD_BOOT_CODE
//  280 #pragma optimize=medium

        RSEG RAM_CODE_FLASH:CODE:NOROOT(0)
//  281 static void HalFlashWriteTrigger(void)
??HalFlashWriteTrigger:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function ??HalFlashWriteTrigger
        CODE
//  282 #else
//  283 static __monitor void HalFlashWriteTrigger(void)
//  284 #endif
//  285 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
//  286   MEMCTR |= 0x08;       // Start the Memory Arbiter running CODE from RAM.
        ORL     0xc7,#0x8
//  287   FCTL |= 0x02;         // Trigger the DMA writes.
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
//  288   while (FCTL & 0x80);  // Wait until writing is done.
??HalFlashWriteTrigger_1:
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.7
        JC      ??HalFlashWriteTrigger_1
//  289   MEMCTR &= ~0x08;      // Stop the Memory Arbiter.
        ANL     0xc7,#0xf7
//  290 }
        POP     DPH
        CFI DPH0 SameValue
        CFI CFA_SP SP+-3
        POP     DPL
        CFI DPL0 SameValue
        CFI CFA_SP SP+-2
        RET
        CFI EndBlock cfiBlock2
        REQUIRE MEMCTR
//  291 
//  292 
//  293 /**************************************************************************************************
//  294 */
// C:\Users\freeman\Documents\work\NBK\Canon\Nbk600EX - RF\Components\hal\target\CC2530EB\hal_oad.c
//    1 /**************************************************************************************************
//    2   Filename:       _hal_oad.c
//    3   Revised:        $Date: 2008-01-17 12:32:06 -0800 (Thu, 17 Jan 2008) $
//    4   Revision:       $Revision: 16224 $
//    5 
//    6   Description:    This module contains optionally-compiled Boot Code to support OAD.
//    7                   The rest of the functionality is the H/W specific drivers to read/write
//    8                   the flash/NV containing the ACTIVE and the DOWNLOADED images.
//    9   Notes:          This version targets the Texas Instruments CC2x3x family of processors.
//   10 
//   11 
//   12   Copyright 2008-2009 Texas Instruments Incorporated. All rights reserved.
//   13 
//   14   IMPORTANT: Your use of this Software is limited to those specific rights
//   15   granted under the terms of a software license agreement between the user
//   16   who downloaded the software, his/her employer (which must be your employer)
//   17   and Texas Instruments Incorporated (the "License").  You may not use this
//   18   Software unless you agree to abide by the terms of the License. The License
//   19   limits your use, and you acknowledge, that the Software may not be modified,
//   20   copied or distributed unless embedded on a Texas Instruments microcontroller
//   21   or used solely and exclusively in conjunction with a Texas Instruments radio
//   22   frequency transceiver, which is integrated into your product.  Other than for
//   23   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   24   works of, modify, distribute, perform, display or sell this Software and/or
//   25   its documentation for any purpose.
//   26 
//   27   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   28   PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   29   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   30   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   31   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   32   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   33   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   34   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   35   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   36   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   37   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   38 
//   39   Should you have any questions regarding your right to use this Software,
//   40   contact Texas Instruments Incorporated at www.TI.com.
//   41 **************************************************************************************************/
//   42 
//   43 /* ------------------------------------------------------------------------------------------------
//   44  *                                          Includes
//   45  * ------------------------------------------------------------------------------------------------
//   46  */
//   47 #include <ioCC2530.h>
//   48 #include "comdef.h"
//   49 #include "hal_board_cfg.h"
//   50 #include "hal_dma.h"
//   51 #include "hal_flash.h"
//   52 #include "hal_oad.h"
//   53 #include "hal_types.h"
//   54 #include <stdio.h>
//   55 //#include "hal_aes.h"
//   56 
//   57 /* ------------------------------------------------------------------------------------------------
//   58  *                                           Macros
//   59  * ------------------------------------------------------------------------------------------------
//   60  */
//   61 
//   62 /* ------------------------------------------------------------------------------------------------
//   63  *                                          Constants
//   64  * ------------------------------------------------------------------------------------------------
//   65  */
//   66 
//   67 /* ------------------------------------------------------------------------------------------------
//   68  *                                          Typedefs
//   69  * ------------------------------------------------------------------------------------------------
//   70  */
//   71 
//   72 /* ------------------------------------------------------------------------------------------------
//   73  *                                       Global Variables
//   74  * ------------------------------------------------------------------------------------------------
//   75  */
//   76 
//   77 /* ------------------------------------------------------------------------------------------------
//   78  *                                       Global Functions
//   79  * ------------------------------------------------------------------------------------------------
//   80  */
//   81 
//   82 /* ------------------------------------------------------------------------------------------------
//   83  *                                       Local Variables
//   84  * ------------------------------------------------------------------------------------------------
//   85  */
//   86 
//   87 #if HAL_OAD_BOOT_CODE

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   88 halDMADesc_t dmaCh0;
dmaCh0:
        DS 8
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant {63, 221, 251, 183, 32, 177, 149, 1`:
        DS 16
        REQUIRE `?<Initializer for <Constant {63, 221, 251, 183`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "MakeTomorrowBest">`:
        DS 17
        REQUIRE `?<Initializer for <Constant "MakeTomorrowBest"`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "BOOT\\r\\n">`:
        DS 7
        REQUIRE `?<Initializer for <Constant "BOOT\\r\\n">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "Initial\\r\\n">`:
        DS 10
        REQUIRE `?<Initializer for <Constant "Initial\\r\\n">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "Start\\r\\n">`:
        DS 8
        REQUIRE `?<Initializer for <Constant "Start\\r\\n">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "boot">`:
        DS 5
        REQUIRE `?<Initializer for <Constant "boot">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "jump">`:
        DS 5
        REQUIRE `?<Initializer for <Constant "jump">>`
        REQUIRE __INIT_XDATA_I
//   89 #endif
//   90 
//   91 #define LED_GREEN_ON()          st(HAL_TURN_ON_LED1();)
//   92 #define LED_GREEN_OFF()        st(HAL_TURN_OFF_LED1();)
//   93 #define LED_GREEN_TOGGLE()  st(HAL_TOGGLE_LED1();)
//   94 
//   95 #define LED_RED_ON()          st(HAL_TURN_ON_LED2();)
//   96 #define LED_RED_OFF()        st(HAL_TURN_OFF_LED2();)
//   97 #define LED_RED_TOGGLE()  st(HAL_TOGGLE_LED2();)
//   98 
//   99 #define LED_INS_LINKED()    st(LED_GREEN_ON();LED_RED_OFF();)
//  100 #define LED_INS_UNLINK()    st(LED_GREEN_OFF();LED_RED_ON();)
//  101 #define LED_INS_BRIGDE()    st(LED_GREEN_ON();LED_RED_ON();)
//  102 #define LED_INS_ALLOFF()    st(LED_GREEN_OFF();LED_RED_OFF();)
//  103 
//  104 /* ------------------------------------------------------------------------------------------------
//  105  *                                       Local Functions
//  106  * ------------------------------------------------------------------------------------------------
//  107  */
//  108 
//  109 static uint16 runPoly(uint16 crc, uint8 val);
//  110 
//  111 #define	 ucLDR_Security_F	(*(unsigned char *)0x100)	
//  112 #define	 start_flag	(*(unsigned char *)0x101)	
//  113 #define	 ucLDR_Ret	(*(unsigned char *)0x102)
//  114 #define	 ucLDR_Message	(*(Uart_message *)0x110)
//  115 #define	 stCommand	(*(union  u_stCommand *)0x1E0)	
//  116 #define	 ucLDR_WorkRam	(*(unsigned char *)0x200)
//  117 //#define 	 dmaCh0		(*(halDMADesc_t*)0x201)
//  118 
//  119 #define LED_1 P1_3
//  120 #define LED_2 P1_4
//  121 
//  122 #define OAD_AES_VERI
//  123 
//  124 // _mode_ is one of
//  125 #define CBC         0x00
//  126 #define CFB         0x10
//  127 #define OFB         0x20
//  128 #define CTR         0x30
//  129 #define ECB         0x40
//  130 #define CBC_MAC     0x50
//  131 
//  132 #define AES_BUSY    0x08
//  133 #define ENCRYPT     0x00
//  134 #define DECRYPT     0x01
//  135 
//  136 // Macro for starting or stopping encryption or decryption
//  137 #define AES_SET_ENCR_DECR_KEY_IV(mode) \ 
//  138    do {                                \ 
//  139     ENCCS = (ENCCS & ~0x07) | mode     \ 
//  140    } while(0)
//  141 
//  142 #define VALID_INIT_SN				(978137684l)
//  143 #define VALID_START_SN				(260636838l)
//  144 
//  145 typedef volatile unsigned char XDATA macRam_t;
//  146 #define TI_EXTADDR  PXREG( 0x780C )  /* Pointer to Start of Flash Information Page          */
//  147 
//  148 // Where _mode_ is one of
//  149 #define AES_ENCRYPT     0x00;
//  150 #define AES_DECRYPT     0x02;
//  151 #define AES_LOAD_KEY    0x04;
//  152 #define AES_LOAD_IV     0x06;
//  153 
//  154 #define LENGTH_IV  16
//  155 #define LENGTH_KEY 16
//  156 
//  157 #define STRING_LENGTH       16
//  158 
//  159 
//  160 // Macro for setting the mode of the AES operation
//  161 #define AES_SETMODE(mode) do { ENCCS &= ~0x70; ENCCS |= mode; } while (0)
//  162 
//  163 // Macro for starting the AES module for either encryption, decryption,
//  164 // key or initialisation vector loading.
//  165 #define AES_START()     ENCCS |= 0x01
//  166 
//  167 #define DELAY 0x0F
//  168 
//  169 typedef unsigned char       BOOL;
//  170 
//  171 // Data
//  172 typedef unsigned char       BYTE;
//  173 typedef unsigned short      WORD;
//  174 typedef unsigned long       DWORD;
//  175 
//  176 // Unsigned numbers
//  177 typedef unsigned char       UINT8;
//  178 typedef unsigned short      UINT16;
//  179 typedef unsigned long       UINT32;
//  180 
//  181 // Signed numbers
//  182 typedef signed char         INT8;
//  183 typedef signed short        INT16;
//  184 typedef signed long         INT32;
//  185 
//  186 #if HAL_OAD_XNV_IS_SPI
//  187 //static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len);
//  188 //static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len);
//  189 static unsigned char RcvData(void);
//  190 static unsigned char Message_Rcv(void);
//  191 static void Message_Send(void);
//  192 static void SendData(char dat);
//  193 static void delay(unsigned int de);
//  194 static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key);
//  195 static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr);
//  196 static void MemReadRam(macRam_t * pRam, uint8 * pData, uint8 len);
//  197 static uint8 OAD_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len );
//  198 static void putsDialog(const char *str);
//  199 #endif
//  200 
//  201 //char g_cupIdRst[16] = {0x08,0x3f,0x37,0x9f,0xb6,0xe6,0x5d,0x1f,0x3d,0xb9,0xdb,0x9c,0x4f,0xf3,0x6f,0xf0};
//  202 
//  203 //#define DEBUG_TRACE
//  204 
//  205 #if HAL_OAD_BOOT_CODE
//  206 static void dl2rc(void);
//  207 static uint16 crcCalc(void);
//  208 static void InitUart(void);
//  209 static void Uart_Send_String(char *Data,int len);
//  210 #endif
//  211 
//  212 #ifdef DEBUG_TRACE
//  213 static void PutChar(const char Tbyte);
//  214 static void putsStr(const char *str);
//  215 static char *mac_itoa(long n, int base);
//  216 int Printf(const char *fmt, ...);
//  217 #endif
//  218 
//  219 /**************************************************************************************************
//  220  * @fn          main
//  221  *
//  222  * @brief       ISR for the reset vector.
//  223  *
//  224  * input parameters
//  225  *
//  226  * None.
//  227  *
//  228  * output parameters
//  229  *
//  230  * None.
//  231  *
//  232  * @return      None.
//  233  **************************************************************************************************
//  234  */
//  235  
//  236 //#pragma location="RAM_CODE_XDATA"
//  237 
//  238 //unsigned char ucLDR_Security_F;
//  239 //unsigned char start_flag;
//  240 //unsigned char ucLDR_Ret;
//  241 //Uart_message ucLDR_Message;
//  242 //unsigned char ucLDR_WorkRam;
//  243 
//  244 // char *g_decKey = "WorkForYourDream";
//  245 //    char *g_decKey = "MakeTomorrowBest";
//  246  //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//  247 
//  248 /****************
//  249 
//  250 :101FF000e560f3070687996742fdfbc684bdc655B9
//  251 :100FF000e560f3070687996742fdfbc684bdc655C9
//  252 e5 60 f3 07 06 87 99 67 42 fd fb c6 84 bd c6 55
//  253 
//  254 938
//  255 *****************/
//  256 
//  257 /********************************************/
//  258 //F0 02 2D 76 AA 9C C7 D7 2A B3 24 53 98 B9 62 93
//  259 //:101FF000F0022D76AA9CC7D72AB3245398B96293CE
//  260 //
//  261 /********************************************/
//  262 
//  263 
//  264 #pragma location="NEAR_CODE"
//  265 //char g_cupIdRst[16] = {0xE8,0xF7,0x0C,0x78,0xCB,0xDF,0xE6,0x5D,0xD1,0x4B,0xF7,0x51,0xA6,0x01,0x98,0x22};
//  266 
//  267 void main(void)
//  268 {
//  269   //uint16 crc[2];
//  270   //uint8 g_extAddr[8] = {0x38,0x15,0xC6,0xFE,0xFF,0x17,0x87,0x88};

        RSEG XDATA_I:XDATA:NOROOT(0)
//  271   static char cpuIdKey[16] = {0x24,0x98,0xb7,0xA0,0xCB,0xDF,0xE6,0x5D,0xD1,0x4B,0xF7,0x51,0xA6,0x01,0x98,0x22};
??cpuIdKey:
        DATA8
        DS 16
        REQUIRE `?<Initializer for cpuIdKey>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_3a4d3254:
        DS 4
        REQUIRE `?<Initializer for __Constant_3a4d3254>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_f8900a6:
        DS 4
        REQUIRE `?<Initializer for __Constant_f8900a6>`
        REQUIRE __INIT_XDATA_I
//  272   //char cpuIdRst[16] = {0xE8,0xF7,0x0C,0x78,0xCB,0xDF,0xE6,0x5D,0xD1,0x4B,0xF7,0x51,0xA6,0x01,0x98,0x22};
//  273   char cpuIdRst[16]  = {0x3f ,0xdd ,0xfb ,0xb7 ,0x20 ,0xb1 ,0x95 ,0x89 ,0x75 ,0xd6 ,0x6e ,0x92 ,0x3f ,0xf7 ,0xf0 ,0xad};
//  274   //uint8 veriBuf[16];
//  275   uint8 veriBuf[20];
//  276   uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;
//  277   uint16 oset;
//  278   uint8 page=HAL_OAD_RC_START/HAL_FLASH_PAGE_SIZE;
//  279   //char *decKey = "WorkForYourDream";
//  280   //char *g_decKey = "MakeTomorrowBest";
//  281   char *decKey = "MakeTomorrowBest";
//  282   uint8 buf[16];
//  283   uint32 *pVeriFlag;
//  284   uint8 i = 0;
//  285   uint16 *cpuIdAddr;
//  286  // char *g_decKey = "WorkForYourDream";
//  287  //BYTE  IV[LENGTH_IV ] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//  288   //uint8 buf[8] = {0};  
//  289 
//  290   HAL_BOARD_INIT();
//  291 #if HAL_OAD_XNV_IS_SPI
//  292   //XNV_SPI_INIT(); 
//  293 #endif
//  294   /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
//  295    * descriptors in addition to just Channel 0.
//  296    */
//  297   HAL_DMA_SET_ADDR_DESC0( &dmaCh0 );
//  298   HalFlashInit();
//  299 
//  300 #ifdef _USER_OAD_FLASH_WRITE_
//  301   HalFlashRead(HAL_OAD_CRC_ADDR / HAL_FLASH_PAGE_SIZE,
//  302                HAL_OAD_CRC_ADDR % HAL_FLASH_PAGE_SIZE,
//  303                (uint8 *)crc, sizeof(crc));
//  304 
//  305 
//  306   if (crc[0] != crc[1])
//  307   {
//  308     // If the CRC is erased or the RC code fails a sanity check, instantiate the DL code (again).
//  309     if ((crc[0] == 0) || (crc[0] != crcCalc()))
//  310     {
//  311       dl2rc();
//  312 
//  313       /* If dl2rc() fails, a flawed image is allowed to run - 
//  314        * maybe the damage is not fatal to OTA ops?
//  315        */
//  316     }
//  317     else
//  318     {
//  319       crc[1] = crc[0];
//  320       HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
//  321     }
//  322   }
//  323 #endif
//  324 
//  325   //InitUart();
//  326   //Uart_Send_String("boot",4);
//  327   
//  328   //P1DIR &=( ~0x04);
//  329   //P1DIR |= 0x08;				//P1_3
//  330   //P1DIR |= 0x08;
//  331   //P1DIR |= 0x10;
//  332   //P1DIR |= 0x18;
//  333   //P1_3 = 0;
//  334   //P1_4 = 0;
//  335   P0DIR &= 0xDF;
//  336   P0SEL&=~(1<<5);//ÉèÖÃP0_5ÎªÒ»°ãIO¿Ú¹¦ÄÜ
//  337   P0DIR&=~(1<<5);//ÉèÖÃP0_5ÎªÊäÈë¹¦ÄÜ
//  338   P0INP&=~(1<<5);//ÉèÖÃÎªÉÏÀ­
//  339   //P0DIR |= 0x20;					//P05
//  340   InitUart();
//  341   AES_SETMODE(ECB);
//  342   //halAesLoadKeyOrInitVector(g_decKey, TRUE);
//  343   //halAesLoadKeyOrInitVector(decKey, TRUE);
//  344 
//  345   putsDialog("BOOT\r\n");
//  346 
//  347 #ifdef OAD_AES_VERI
//  348   //halAesLoadKeyOrInitVector(decKey, TRUE);
//  349 #if 1
//  350 //****************************************************************
//  351 // encrpto CPUID
//  352 //****************************************************************
//  353   halAesLoadKeyOrInitVector(cpuIdKey, TRUE);
//  354   //halAesEncrDecr(cpuIdRst, 16, cpuIdRst, ENCRYPT);
//  355   //putsDialog("key enc\r\n");
//  356   //for(i=0;i<16;i++)
//  357   //{
//  358   //    Printf("%x ",cpuIdRst[i]);
//  359   //}
//  360   //putsDialog("\r\nkey dec\r\n");
//  361   halAesEncrDecr(cpuIdRst, 16, cpuIdRst, DECRYPT);
//  362   //for(i=0;i<16;i++)
//  363   //{
//  364       //Printf("%x ",cpuIdRst[i]);
//  365   //}
//  366   //putsDialog("\r\n");
//  367 
//  368   cpuIdAddr = (uint16*)(cpuIdRst+2);
//  369 
//  370   //Printf("cpuIdAddr %x\r\n",*cpuIdAddr);
//  371 #endif
//  372 //****************************************************************
//  373 // end
//  374 //****************************************************************
//  375 // resume the decrypto key
//  376   halAesLoadKeyOrInitVector(decKey, TRUE);
//  377 //****************************************************************
//  378 // end
//  379 //****************************************************************
//  380 
//  381   MemReadRam((macRam_t *)TI_EXTADDR, veriBuf, 8);                             // initialize the veriBuf
//  382   
//  383   HalFlashRead(CPUID_VERI_ADDR / HAL_FLASH_PAGE_SIZE,
//  384                CPUID_VERI_ADDR % HAL_FLASH_PAGE_SIZE,
//  385                veriBuf, sizeof(veriBuf));
//  386 
//  387   halAesEncrDecr((BYTE *)veriBuf, CPUID_VERI_LEN, (BYTE *)veriBuf/*, ucLDR_Message.com_data*/, DECRYPT); 
//  388   
//  389   pVeriFlag = (uint32*)veriBuf;
//  390   if(VALID_INIT_SN==*pVeriFlag)
//  391   {
//  392   	putsDialog("Initial\r\n");
//  393 
//  394 	//dl2rc();
//  395 	//HalFlashErase(HAL_OAD_RC_START / HAL_FLASH_PAGE_SIZE );
//  396 	//HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);		//²»ÄÜÅúÁ¿ÉÕÂ¼
//  397 	
//  398   	*pVeriFlag = VALID_START_SN;						//first start 
//  399   	//MemReadRam((macRam_t *)TI_EXTADDR, (veriBuf+4), 8);
//  400   	MemReadRam((macRam_t *)(PXREG(*cpuIdAddr)),(veriBuf+4), 8);
//  401 //	 test for read cpuid
//  402 //	putsDialog("cpu id\r\n");
//  403 //	for(i=0;i<8;i++)
//  404 //	{
//  405 //	    Printf("%x ",veriBuf[i]);
//  406 //	}
//  407 //	putsDialog("\r\n");
//  408 //
//  409 	halAesEncrDecr((BYTE *)veriBuf, CPUID_VERI_LEN, (BYTE *)veriBuf/*, ucLDR_Message.com_data*/, ENCRYPT); 
//  410 	HalFlashErase(CPUID_VERI_ADDR / HAL_FLASH_PAGE_SIZE);
//  411 	HalFlashWrite((CPUID_VERI_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)veriBuf, CPUID_VERI_LEN/4);	
//  412   }else if(VALID_START_SN==*pVeriFlag)
//  413   {
//  414   	//MemReadRam((macRam_t *)TI_EXTADDR, (veriBuf+12), 8);		//read mac iD
//  415   	MemReadRam((macRam_t *)(PXREG(*cpuIdAddr)),(veriBuf+12), 8);
//  416 	if(FALSE==OAD_memcmp((veriBuf+4), (veriBuf+12), 8))
//  417 	{
//  418 		//putsDialog("Verified Error");
//  419 		//while(1);
//  420 		for(oset=0;oset<1000;oset++)
//  421 		{
//  422 			delay(1000);
//  423 		}
//  424 		asm("LJMP 0x0000\n");
//  425 	}
//  426 	putsDialog("Start\r\n");
//  427   }else
//  428   {
//  429   	//putsDialog("Verified Error");
//  430 	//while(1);
//  431 	for(oset=0;oset<1000;oset++)
//  432 	{
//  433 		delay(1000);
//  434 	}
//  435 	asm("LJMP 0x0000\n");
//  436   }
//  437 
//  438 #endif
//  439   
//  440  //if(!P1_2)
//  441   if(!P0_5)
//  442   {
//  443 
//  444 	Uart_Send_String("boot",4);
//  445         P1DIR |= 0x18;
//  446         P1_4 = 0;
//  447 	
//  448 	while(1)
//  449 	{
//  450                 //LED_RED_TOGGLE();
//  451 		if(Message_Rcv())
//  452 		{	
//  453 			//P1_3 = !P1_3;
//  454 			LED_RED_TOGGLE();
//  455 			ucLDR_Security_F = 0;
//  456 			ucLDR_Ret = 0x00;
//  457 			//Uart_Send_String("rcv",3);
//  458 #if 1
//  459 			switch(ucLDR_Message.protocol_command )
//  460 			{
//  461 
//  462 				case AM1_IAP_READ_64BYTE:
//  463 #if 1
//  464 					//P1_3 = !P1_3;
//  465                                    //     P1_4 = !P1_4;
//  466 				  	for (oset = 0; oset < HAL_FLASH_PAGE_SIZE; oset += 64)
//  467 				  	{
//  468 						HalFlashRead(page,oset,ucLDR_Message.com_data,64);
//  469 						ucLDR_Message.data_length=64;
//  470 						Message_Send();		
//  471 						//Uart_Send_String(buf,4);
//  472 					
//  473 				  	}
//  474 					page++;
//  475 #endif
//  476 				break;
//  477 /*
//  478 				case BOOT_FIRMWARE_VERSION:
//  479 					ucLDR_Message.com_data[0]=1;
//  480 					ucLDR_Message.com_data[1]=0;      
//  481 					ucLDR_Message.com_data[12]=5;	//for AM1_IAP
//  482 					ucLDR_Message.data_length=20;
//  483 					Message_Send();
//  484 					break;
//  485 					
//  486 				case AM1_IAP_READ_64BYTE:
//  487 					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
//  488 					stCommand.Program_Lib.dst_adr	+= 64;
//  489 					if( stCommand.Program_Lib.dst_adr == 0x00 )
//  490 					stCommand.Program_Lib.dst_bank++;	
//  491 					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
//  492 					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
//  493 					ucLDR_Read_64Byte_Ram();
//  494 					ucLDR_Message.data_length=64;
//  495 					Message_Send();
//  496 					break;
//  497 
//  498 						
//  499 				case AM1_IAP_READ_STATUS:
//  500 					stCommand.ReadStatus_Lib.ram_adr = (unsigned char*)&ucLDR_WorkRam;
//  501 					ucLDR_Ret=0;//test
//  502 					ucLDR_ReadStatus_Ram();//test
//  503 					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
//  504 					ucLDR_Message.data_length=2;
//  505 					Message_Send();
//  506 					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
//  507 					stCommand.Program_Lib.dst_bank	= 0;	
//  508 					break;
//  509 
//  510 					  
//  511 				case AM1_IAP_SECURITYCHECK:
//  512 		 			stCommand.Security_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam;
//  513 			 		stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
//  514 					ucLDR_Ret = 0x00;
//  515 					ucLDR_SecurityCheck_Ram();
//  516 					ucLDR_Message.com_data[0]=ucLDR_Ret;// No Key	
//  517 					ucLDR_Message.data_length=2;		
//  518 					Message_Send();
//  519 					stCommand.Program_Lib.dst_adr	= (unsigned char*)(LDR_WRITE_ADDRESS-64);	   
//  520 					stCommand.Program_Lib.dst_bank	= 0;	
//  521 				      break;
//  522 */
//  523 						
//  524 	//=================================================================================
//  525 				case AM1_IAP_WRITE_PAGE:	
//  526 /*
//  527 					stCommand.Program_Lib.ram_adr	= &ucLDR_WorkRam;
//  528 					stCommand.Program_Lib.dst_adr	+= 64;
//  529 					if( stCommand.Program_Lib.dst_adr == 0x00 )
//  530 					stCommand.Program_Lib.dst_bank++;	
//  531 					stCommand.Program_Lib.bc		=  LDR_WRITE_SIZE;
//  532 					stCommand.Program_Lib.src_adr  =   &ucLDR_Message.com_data[0];
//  533 					ucLDR_Ret=0x00;//test	
//  534 					ucLDR_Program_Ram();//test
//  535 */
//  536 					halAesEncrDecr((BYTE *)ucLDR_Message.com_data, STRING_LENGTH, (BYTE *)ucLDR_Message.com_data/*, ucLDR_Message.com_data*/, DECRYPT);
//  537 					//Uart_Send_String((BYTE *)buf,16);
//  538 					if(addr>=(HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE))
//  539 					{
//  540 						if ((addr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
//  541 						{
//  542 							HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
//  543 						}
//  544 						//HalFlashWrite(addr++, ucLDR_Message.com_data, 1);
//  545 						HalFlashWrite(addr, ucLDR_Message.com_data, ucLDR_Message.data_length/4);
//  546 						addr+=(ucLDR_Message.data_length/4);
//  547 						delay(1000);
//  548 					    //ucLDR_Read_64Byte_Ram();
//  549 						ucLDR_Message.com_data[0]=0x00;
//  550 					}else
//  551 					{
//  552 						ucLDR_Message.com_data[0]=0x01;
//  553 					}
//  554 					ucLDR_Message.data_length=2;
//  555 					Message_Send();					
//  556 					break;
//  557 
//  558 				case AM1_IAP_RST_POINT:
//  559 					addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;
//  560 					ucLDR_Message.com_data[0]=0x00;
//  561 					ucLDR_Message.data_length=2;
//  562 					Message_Send();	
//  563 				break;
//  564 
//  565 				case AM1_IAP_ERASE_DEVICE:
//  566 					ucLDR_Message.com_data[0]=0x55;
//  567 					ucLDR_Message.com_data[1]=0x00;
//  568 					ucLDR_Message.data_length=3;
//  569 					Message_Send();	
//  570 				break;
//  571 	//=================================================================================
//  572 /*
//  573 				case AM1_IAP_ERASE_DEVICE:		
//  574 					ucLDR_Security_F = 0;
//  575 					stCommand.ReadStatus_Lib.ram_adr = &ucLDR_WorkRam;
//  576 					ucLDR_Ret=0;//test
//  577 					ucLDR_ReadStatus_Ram();//test
//  578 					if( (ucLDR_Ret&0x01) == 0x01 )
//  579 						{
//  580 						ucLDR_Message.com_data[0]=0x55;// No Key	
//  581 						ucLDR_Security_F=1;
//  582 					     }
//  583 					else
//  584 						{
//  585 						ucLDR_Ret = 0x00;
//  586 			 			stCommand.Security_Lib.ram_adr	= &ucLDR_WorkRam;
//  587 			 			stCommand.Security_Lib.key_adr = (unsigned char*)&ucLDR_Message.com_data[0];
//  588 						ucLDR_SecurityCheck_Ram();
//  589 						if( ucLDR_Ret != 0x00 )
//  590 							{
//  591 							ucLDR_Message.com_data[0]=0xEE;   //Key Verify error
//  592 			
//  593 							}
//  594 						else
//  595 							{
//  596 							 ucLDR_Message.com_data[0]=0xaa ;//Key Verify Pass
//  597 		                                 ucLDR_Security_F=1;
//  598 						       }
//  599 						}
//  600 
//  601 						 if(ucLDR_Security_F==1)
//  602 							{
//  603 								stCommand.Erase_Lib.ram_adr	= &ucLDR_WorkRam;
//  604 								ucLDR_Ret=0x00;//test
//  605 								ucLDR_Erase_Ram();//test
//  606 								ucLDR_Message.com_data[1]= ucLDR_Ret;
//  607 								#if 0
//  608 								if(ucLDR_Ret==0)
//  609 								{
//  610 								stCommand.Secter_Lib.ram_adr	= (unsigned char*)&ucLDR_WorkRam[0];
//  611 								ucLDR_Ret=0x00;//test
//  612 								ucLDR_BankCheck_Ram();  //test 
//  613 								ucLDR_Message.com_data[2]=ucLDR_Ret;
//  614 								}
//  615 								#endif
//  616 							}
//  617 					delay(60000);		
//  618 					stCommand.Program_Lib.dst_adr	= (unsigned char*)(0x4000-64);	   
//  619 					stCommand.Program_Lib.dst_bank	= 0;
//  620 					Message_Send();	
//  621 					break;
//  622 */
//  623 //=================================================================================
//  624 				  default:
//  625 					//Message_Send();		
//  626 					break;
//  627 				}
//  628 #endif
//  629 		}
//  630 		//start_flag = 0;
//  631 		//InitUart();
//  632 		//Uart_Send_String("test",4);
//  633 		//P1_3 = !P1_3;
//  634 
//  635 	}
//  636   }else
//  637   {
//  638   	Uart_Send_String("jump",4);
//  639 	asm("LJMP 0x2000\n");
//  640 	//asm("LJMP 0x800\n");
//  641 	//asm("LJMP 0x2000\n");
//  642 	//asm("LJMP 0x1000\n");
//  643 	//asm("LJMP 0x5000\n");
//  644   }
//  645   
//  646   //Uart_Send_String("boot",4);
//  647   /*
//  648   for(page=0;page<10;page++)
//  649   {
//  650   	for (oset = 0; oset < 512; oset += HAL_FLASH_WORD_SIZE)
//  651   	{
//  652 		HalFlashRead(page,oset,buf,4);
//  653 		Uart_Send_String(buf,4);
//  654 	
//  655   	}
//  656   }*/
//  657   //HalFlashInit();
//  658   //HalFlashWrite(addr++, buf, 1);
//  659 
//  660   //HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
//  661   //HalFlashWrite(addr, g_extAddr, 1);
//  662   //HalFlashWrite(addr+1, g_extAddr+4, 2);
//  663   //HalFlashRead(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE),0,g_extAddr,8);
//  664   //Uart_Send_String(g_extAddr,8);
//  665   
//  666   // Simulate a reset for the Application code by an absolute jump to location 0x0800.
//  667   //asm("LJMP 0x800\n");
//  668 }
//  669 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  670 static void MemReadRam(macRam_t * pRam, uint8 * pData, uint8 len)
??MemReadRam:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function ??MemReadRam
        CODE
//  671 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
        SJMP    ??MemReadRam_1
//  672   while (len)
//  673   {
//  674     len--;
??MemReadRam_2:
        DEC     R1
//  675     *pData = *pRam;
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    @DPTR,A
//  676     pRam++;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
//  677     pData++;
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R4,DPL
        MOV     R5,DPH
//  678   }
??MemReadRam_1:
        MOV     A,R1
        JNZ     ??MemReadRam_2
        CFI EndBlock cfiBlock3
//  679 }
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-4
        CFI DPL0 Frame(CFA_SP, 3)
        CFI DPH0 Frame(CFA_SP, 4)
        POP     DPH
        CFI CFA_SP SP+-3
        CFI DPH0 SameValue
        POP     DPL
        CFI CFA_SP SP+-2
        CFI DPL0 SameValue
        RET
        CFI EndBlock cfiBlock4
//  680 
//  681 static uint8 OAD_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
//  682 {
//  683   const uint8 GENERIC *pSrc1;
//  684   const uint8 GENERIC *pSrc2;
//  685 
//  686   pSrc1 = src1;
//  687   pSrc2 = src2;
//  688 
//  689   while ( len-- )
//  690   {
//  691     if( *pSrc1++ != *pSrc2++ )
//  692       return FALSE;
//  693   }
//  694   return TRUE;
//  695 }
//  696 
//  697 static void InitUart(void)
//  698 {
//  699     CLKCONCMD &= ~0x40; // ÉèÖÃÏµÍ³Ê±ÖÓÔ´Îª 32MHZ¾§Õñ
//  700     while(CLKCONSTA & 0x40);                     // µÈ´ý¾§ÕñÎÈ¶¨ 
//  701     CLKCONCMD &= ~0x47;                          // ÉèÖÃÏµÍ³Ö÷Ê±ÖÓÆµÂÊÎª 32MHZ
//  702 
//  703     PERCFG = 0x00;        //Î»ÖÃ1 P0¿Ú 
//  704     //P0SEL = 0x3c;        //P0_2,P0_3,P0_4,P0_5ÓÃ×÷´®¿Ú,µÚ¶þ¹¦ÄÜ 
//  705     P0SEL |= 0x0c;
//  706     //P0DIR |= 0x08;
//  707     P2DIR &= ~0XC0;      //P0 ÓÅÏÈ×÷ÎªUART0 £¬ÓÅÏÈ¼¶
//  708     //PERCFG &= ~(BV(0)); //Ñ¡ÔñP0¶Ë¿Úuart
//  709     //P0SEL |=BV(5)|BV(4)|BV(3)|BV(2);
//  710     //P2DIR &=~(BV(7)|BV(6));
//  711 
//  712     U0CSR |= 0x80;       //UART ·½Ê½ 
//  713     U0GCR |= 11;         //U0GCRÓëU0BAUDÅäºÏ     
//  714     U0BAUD |= 216;       // ²¨ÌØÂÊÉèÎª115200 
//  715     UTX0IF = 0;          //UART0 TX ÖÐ¶Ï±êÖ¾³õÊ¼ÖÃÎ»1  £¨ÊÕ·¢Ê±ºò£©
//  716     U0CSR |= 0X40;       //ÔÊÐí½ÓÊÕ 
//  717    // IEN0 |= 0x84;        // ¿ª×ÜÖÐ¶Ï£¬½ÓÊÕÖÐ¶Ï    
//  718 
//  719    URX0IF = 0;
//  720 
//  721   // P1_3 = !P1_3;
//  722 }
//  723 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  724 static void SendData(char dat)
??SendData:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function ??SendData
        CODE
//  725 {
        ; Saved register size: 0
        ; Auto size: 0
//  726 	U0DBUF = dat;
        MOV     0xc1,R1
//  727 	while(!UTX0IF);
??SendData_1:
        MOV     C,0xe8.1
        JNC     ??SendData_1
//  728 	UTX0IF = 0; 	
        CLR     0xe8.1
//  729 }
        RET
        CFI EndBlock cfiBlock5
        REQUIRE U0DBUF
        REQUIRE _A_IRCON2
//  730 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  731 static void putsDialog(const char *str)
??putsDialog:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function ??putsDialog
        CODE
//  732 {
        FUNCALL ??putsDialog, ??SendData
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
        MOV     DPL,R2
        MOV     DPH,R3
        SJMP    ??putsDialog_1
//  733 	 //UartDecode(str);
//  734 	 while(*str != '\0')
//  735 	{
//  736         	SendData(*str++);
??putsDialog_2:
        ; Setup parameters for call to function SendData
        LCALL   ??SendData
        INC     DPTR
//  737     }
??putsDialog_1:
        MOVX    A,@DPTR
        MOV     R1,A
        JNZ     ??putsDialog_2
//  738 }
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock6
//  739 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  740 static void Uart_Send_String(char *Data,int len) 
??Uart_Send_String:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI Function ??Uart_Send_String
        CODE
//  741 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 8)
        ; Saved register size: 8
        ; Auto size: 0
//  742 	  int j; 
//  743 	  for(j=0;j<len;j++) 
        MOV     R0,#0x0
        MOV     R1,#0x0
        SJMP    ??Uart_Send_String_1
//  744 	  { 
//  745 		    U0DBUF = *Data++; 
??Uart_Send_String_2:
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     0xc1,A
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
//  746 		    while(UTX0IF == 0); //·¢ËÍÍê³É±êÖ¾Î»
??Uart_Send_String_3:
        MOV     C,0xe8.1
        JNC     ??Uart_Send_String_3
//  747 		    UTX0IF = 0; 
        CLR     0xe8.1
//  748 	  } 
        MOV     A,R0
        ADD     A,#0x1
        INC     R0
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
??Uart_Send_String_1:
        CLR     C
        MOV     A,R0
        SUBB    A,R4
        MOV     A,R1
        SUBB    A,R5
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??Uart_Send_String_2
//  749 }
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock7
        REQUIRE U0DBUF
        REQUIRE _A_IRCON2
//  750 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  751 static void delay(unsigned int de)
??delay:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function ??delay
        CODE
//  752 {
        ; Saved register size: 0
        ; Auto size: 0
//  753 	//while(de--);
//  754 	 uint16 i,j;
//  755 	 for(i=de;i>0;i--)
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        SJMP    ??delay_1
//  756 	   for(j=587;j>0;j--);
??delay_2:
        MOV     A,R0
        ADD     A,#-0x1
        DEC     R0
        MOV     A,R1
        ADDC    A,#-0x1
??delay_1:
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??delay_2
//  757 }
        RET
        CFI EndBlock cfiBlock8
//  758 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  759 static unsigned char RcvData(void)
??RcvData:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function ??RcvData
        CODE
//  760 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 3)
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        ; Saved register size: 2
        ; Auto size: 0
//  761 	unsigned char count1=0;
        MOV     R1,#0x0
//  762 	unsigned char count2=0;
        MOV     R0,#0x0
//  763 
//  764 	while( !URX0IF )
??RcvData_1:
        MOV     C,0x88.3
        JC      ??RcvData_2
//  765 	{
//  766 		count1++;
        INC     R1
//  767 		if(count1==252)
        MOV     A,#-0x4
        XRL     A,R1
        JNZ     ??RcvData_3
//  768 		{
//  769 		count1=0;
        MOV     R1,#0x0
//  770 		count2++;
        INC     R0
//  771 		}
//  772 		if((count2==252)&&(start_flag==1))
??RcvData_3:
        MOV     A,#-0x4
        XRL     A,R0
        JNZ     ??RcvData_1
        MOV     DPTR,#0x101
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??RcvData_1
//  773 		{
//  774 			start_flag=0;
        CLR     A
        MOVX    @DPTR,A
//  775 			
//  776 			return 0;
        MOV     R1,A
        SJMP    ??RcvData_4
//  777 		}
//  778 	}
//  779 	URX0IF = 0;
??RcvData_2:
        CLR     0x88.3
//  780 	return U0DBUF;
        MOV     R1,0xc1
??RcvData_4:
        LJMP    ?Subroutine1
        CFI EndBlock cfiBlock9
        REQUIRE _A_TCON
        REQUIRE U0DBUF
//  781 }
//  782 
//  783 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  784 static unsigned char Message_Rcv(void)
??Message_Rcv:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function ??Message_Rcv
        CODE
//  785 {
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Rcv, ??RcvData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  786 	unsigned char	ucdata;
//  787 	unsigned char 	rcvdat;
//  788 	unsigned char	uci;
//  789 	start_flag=0;
        MOV     DPTR,#0x101
        CLR     A
        MOVX    @DPTR,A
//  790 
//  791 	//P1_3 = !P1_3;
//  792      start_flag=1;
        INC     A
        MOVX    @DPTR,A
//  793      ucdata=RcvData();
//  794 	if(ucdata!=0x7E)
        ; Setup parameters for call to function RcvData
        LCALL   ??RcvData
        MOV     A,R1
        XRL     A,#0x7e
        JZ      ??Message_Rcv_1
//  795 	   return 0;
??Message_Rcv_2:
        MOV     R1,#0x0
        SJMP    ??Message_Rcv_3
//  796 	start_flag=1;
??Message_Rcv_1:
        MOV     A,#0x1
        MOVX    @DPTR,A
//  797 	ucdata=RcvData();
        ; Setup parameters for call to function RcvData
        LCALL   ??RcvData
        MOV     A,R1
//  798 	ucLDR_Message.com_number=  ucdata;
        MOV     DPTR,#0x110
        MOVX    @DPTR,A
//  799 	ucLDR_Message.msg_cks=ucdata;
        MOV     DPTR,#0x164
        LCALL   ??Subroutine14_0
//  800 	
//  801       ucdata=RcvData();
//  802 	if(start_flag==0)
??CrossCallReturnLabel_22:
        JZ      ??Message_Rcv_2
//  803 		return 0;
//  804 	ucLDR_Message.protocol_command=  ucdata;
        MOV     A,R0
        MOV     DPTR,#0x111
        LCALL   ?Subroutine2
//  805 	ucLDR_Message.msg_cks+=ucdata;	
//  806 	
//  807 	ucdata=RcvData();
//  808 	if(start_flag==0)
??CrossCallReturnLabel_20:
        JZ      ??Message_Rcv_2
//  809 		 return 0;
//  810 	ucLDR_Message.no_used=  ucdata;
        MOV     A,R0
        MOV     DPTR,#0x112
        LCALL   ?Subroutine2
//  811 	ucLDR_Message.msg_cks+=ucdata;	
//  812 	
//  813 	ucdata=RcvData();
//  814 	if(start_flag==0)
??CrossCallReturnLabel_21:
        JZ      ??Message_Rcv_2
//  815 		 return 0;
//  816 	ucLDR_Message.data_length=  ucdata;
        MOV     A,R0
        MOV     DPTR,#0x113
        LCALL   ?Subroutine7
//  817 	ucLDR_Message.msg_cks+=ucdata;
??CrossCallReturnLabel_9:
        MOVX    @DPTR,A
//  818 	
//  819 	for( uci=0 ; uci<ucLDR_Message.data_length ; uci++ )
        MOV     R6,#0x0
        SJMP    ??Message_Rcv_4
//  820 	{
//  821 		ucdata = RcvData();
??Message_Rcv_5:
        ; Setup parameters for call to function RcvData
        LCALL   ?Subroutine5
//  822 		if(start_flag==0)
??CrossCallReturnLabel_5:
        JZ      ??Message_Rcv_2
//  823 			 return 0;
//  824 		ucLDR_Message.com_data[uci] = ucdata;
        MOV     ?V0 + 0,R6
        MOV     A,#0x14
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,#0x1
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,R0
        LCALL   ?Subroutine7
//  825 		ucLDR_Message.msg_cks+=ucdata;
//  826 	}
??CrossCallReturnLabel_10:
        MOVX    @DPTR,A
        INC     R6
??Message_Rcv_4:
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        JC      ??Message_Rcv_5
//  827 	ucdata = RcvData();
        ; Setup parameters for call to function RcvData
        LCALL   ?Subroutine5
//  828 	rcvdat = ucLDR_Message.msg_cks;
//  829 	if(start_flag==0)
??CrossCallReturnLabel_6:
        JZ      ??Message_Rcv_2
//  830 		 return 0;
//  831 	//if(ucLDR_Message.msg_cks==ucdata)
//  832 	if(rcvdat==ucdata)
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??Message_Rcv_2
//  833       return 1;
        MOV     R1,#0x1
??Message_Rcv_3:
        LJMP    ?Subroutine0
        CFI EndBlock cfiBlock10
//  834 	else
//  835 	return 0;	
//  836 
//  837 }

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond11 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_5
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond12 Using cfiCommon0
        CFI (cfiCond12) NoFunction
        CFI (cfiCond12) Conditional ??CrossCallReturnLabel_6
        CFI (cfiCond12) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond12) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond12) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond12) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond12) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond12) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond12) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond12) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond12) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond12) CFA_SP SP+0
        CFI (cfiCond12) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker13 Using cfiCommon1
        CFI (cfiPicker13) NoFunction
        CFI (cfiPicker13) Picker
        LCALL   ?Subroutine9
??CrossCallReturnLabel_23:
        RET
        CFI EndBlock cfiCond11
        CFI EndBlock cfiCond12
        CFI EndBlock cfiPicker13

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiCond14 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_20
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond15 Using cfiCommon0
        CFI (cfiCond15) NoFunction
        CFI (cfiCond15) Conditional ??CrossCallReturnLabel_21
        CFI (cfiCond15) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond15) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond15) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond15) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond15) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond15) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond15) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond15) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond15) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond15) CFA_SP SP+0
        CFI (cfiCond15) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker16 Using cfiCommon1
        CFI (cfiPicker16) NoFunction
        CFI (cfiPicker16) Picker
        LCALL   ?Subroutine7
        CFI EndBlock cfiCond14
        CFI EndBlock cfiCond15
        CFI EndBlock cfiPicker16
??CrossCallReturnLabel_11:
        REQUIRE ??Subroutine14_0
        ; // Fall through to label ??Subroutine14_0

        RSEG NEAR_CODE:CODE:NOROOT(0)
??Subroutine14_0:
        CFI Block cfiCond17 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_22
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond18 Using cfiCommon0
        CFI (cfiCond18) NoFunction
        CFI (cfiCond18) Conditional ??CrossCallReturnLabel_20
        CFI (cfiCond18) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond18) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond18) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond18) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond18) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond18) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond18) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond18) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond18) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond18) CFA_SP SP+0
        CFI (cfiCond18) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond19 Using cfiCommon0
        CFI (cfiCond19) NoFunction
        CFI (cfiCond19) Conditional ??CrossCallReturnLabel_21
        CFI (cfiCond19) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond19) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond19) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond19) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond19) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond19) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond19) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond19) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond19) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond19) CFA_SP SP+0
        CFI (cfiCond19) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker20 Using cfiCommon1
        CFI (cfiPicker20) NoFunction
        CFI (cfiPicker20) Picker
        MOVX    @DPTR,A
        ; Setup parameters for call to function RcvData
        ; Setup parameters for call to function RcvData
        ; Setup parameters for call to function RcvData
        LCALL   ?Subroutine9
??CrossCallReturnLabel_24:
        RET
        CFI EndBlock cfiCond17
        CFI EndBlock cfiCond18
        CFI EndBlock cfiCond19
        CFI EndBlock cfiPicker20

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine9:
        CFI Block cfiCond21 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_23, ??CrossCallReturnLabel_5
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond22 Using cfiCommon0
        CFI (cfiCond22) NoFunction
        CFI (cfiCond22) Conditional ??CrossCallReturnLabel_23, ??CrossCallReturnLabel_6
        CFI (cfiCond22) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond22) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond22) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond22) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond22) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond22) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond22) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond22) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond22) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond22) CFA_SP SP+0
        CFI (cfiCond22) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond23 Using cfiCommon0
        CFI (cfiCond23) NoFunction
        CFI (cfiCond23) Conditional ??CrossCallReturnLabel_24, ??CrossCallReturnLabel_20
        CFI (cfiCond23) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond23) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond23) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond23) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond23) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond23) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond23) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond23) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond23) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond23) CFA_SP SP+0
        CFI (cfiCond23) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond24 Using cfiCommon0
        CFI (cfiCond24) NoFunction
        CFI (cfiCond24) Conditional ??CrossCallReturnLabel_24, ??CrossCallReturnLabel_21
        CFI (cfiCond24) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond24) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond24) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond24) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond24) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond24) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond24) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond24) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond24) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond24) CFA_SP SP+0
        CFI (cfiCond24) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond25 Using cfiCommon0
        CFI (cfiCond25) NoFunction
        CFI (cfiCond25) Conditional ??CrossCallReturnLabel_24, ??CrossCallReturnLabel_22
        CFI (cfiCond25) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond25) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond25) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond25) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond25) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond25) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond25) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond25) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond25) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond25) CFA_SP SP+0
        CFI (cfiCond25) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker26 Using cfiCommon1
        CFI (cfiPicker26) NoFunction
        CFI (cfiPicker26) Picker
        LCALL   ??RcvData
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#0x101
        MOVX    A,@DPTR
        RET
        CFI EndBlock cfiCond21
        CFI EndBlock cfiCond22
        CFI EndBlock cfiCond23
        CFI EndBlock cfiCond24
        CFI EndBlock cfiCond25
        CFI EndBlock cfiPicker26

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine7:
        CFI Block cfiCond27 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_9
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond28 Using cfiCommon0
        CFI (cfiCond28) NoFunction
        CFI (cfiCond28) Conditional ??CrossCallReturnLabel_10
        CFI (cfiCond28) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond28) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond28) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond28) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond28) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond28) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond28) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond28) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond28) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond28) CFA_SP SP+0
        CFI (cfiCond28) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond29 Using cfiCommon0
        CFI (cfiCond29) NoFunction
        CFI (cfiCond29) Conditional ??CrossCallReturnLabel_11, ??CrossCallReturnLabel_20
        CFI (cfiCond29) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond29) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond29) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond29) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond29) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond29) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond29) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond29) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond29) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond29) CFA_SP SP+0
        CFI (cfiCond29) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond30 Using cfiCommon0
        CFI (cfiCond30) NoFunction
        CFI (cfiCond30) Conditional ??CrossCallReturnLabel_11, ??CrossCallReturnLabel_21
        CFI (cfiCond30) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond30) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond30) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond30) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond30) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond30) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond30) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond30) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond30) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond30) CFA_SP SP+0
        CFI (cfiCond30) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker31 Using cfiCommon1
        CFI (cfiPicker31) NoFunction
        CFI (cfiPicker31) Picker
        MOVX    @DPTR,A
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        ADD     A,R0
        RET
        CFI EndBlock cfiCond27
        CFI EndBlock cfiCond28
        CFI EndBlock cfiCond29
        CFI EndBlock cfiCond30
        CFI EndBlock cfiPicker31
//  838 
//  839 
//  840 /*********************************************************************
//  841  * @fn      dl2rc
//  842  *
//  843  * @brief   Copy the DL image to the RC image location.
//  844  *
//  845  *  NOTE:   Assumes that DL image ends on a flash word boundary.
//  846  *
//  847  * @param   None.
//  848  *
//  849  * @return  None.
//  850  *********************************************************************/
//  851 #if 1

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  852 static void Message_Send(void)
??Message_Send:
        CFI Block cfiBlock32 Using cfiCommon0
        CFI Function ??Message_Send
        CODE
//  853 {
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ??Message_Send, ??SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  854 	unsigned char  uci;
//  855 	
//  856 	SendData(0x7E);
        ; Setup parameters for call to function SendData
        MOV     R1,#0x7e
        LCALL   ??SendData
//  857     
//  858 	ucLDR_Message.msg_cks =ucLDR_Message.com_number;
        MOV     DPTR,#0x110
        MOVX    A,@DPTR
        MOV     DPTR,#0x164
        MOVX    @DPTR,A
//  859     SendData(ucLDR_Message.com_number);
        ; Setup parameters for call to function SendData
        MOV     R1,A
        LCALL   ??SendData
//  860     
//  861     ucLDR_Message.msg_cks+=ucLDR_Message.protocol_command;
        MOV     DPTR,#0x111
        LCALL   ?Subroutine8
//  862 	SendData(ucLDR_Message.protocol_command);  
??CrossCallReturnLabel_12:
        ; Setup parameters for call to function SendData
        MOV     DPTR,#0x111
        LCALL   ?Subroutine3
//  863 	
//  864     ucLDR_Message.msg_cks+=ucLDR_Message.no_used;
//  865 	SendData(ucLDR_Message.no_used); 	
??CrossCallReturnLabel_0:
        ; Setup parameters for call to function SendData
        MOV     DPTR,#0x112
        LCALL   ?Subroutine3
//  866 		
//  867     ucLDR_Message.msg_cks+=ucLDR_Message.data_length;
//  868 	SendData(ucLDR_Message.data_length); 
??CrossCallReturnLabel_1:
        ; Setup parameters for call to function SendData
        MOV     DPTR,#0x113
        LCALL   ?Subroutine4
//  869 		
//  870 
//  871     for(uci =0;uci<ucLDR_Message.data_length;uci++)
??CrossCallReturnLabel_2:
        MOV     R6,#0x0
        SJMP    ??Message_Send_1
//  872     {
//  873        ucLDR_Message.msg_cks+=ucLDR_Message.com_data[uci];  
??Message_Send_2:
        MOV     ?V0 + 0,R6
        MOV     A,#0x14
        ADD     A,?V0 + 0
        MOV     R0,A
        MOV     A,#0x1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        ADD     A,R2
        MOVX    @DPTR,A
//  874        SendData(ucLDR_Message.com_data[uci]); 	
        ; Setup parameters for call to function SendData
        MOV     DPL,R0
        MOV     DPH,R1
        LCALL   ?Subroutine4
//  875 	 }
??CrossCallReturnLabel_3:
        INC     R6
??Message_Send_1:
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R6
        CLR     C
        SUBB    A,R0
        JC      ??Message_Send_2
//  876      ucLDR_Message.msg_cks+=0;
        MOV     DPTR,#0x164
        LCALL   ?Subroutine4
        CFI EndBlock cfiBlock32
//  877 	 SendData(ucLDR_Message.msg_cks); 		
//  878 }
??CrossCallReturnLabel_4:
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock33 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock33

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond34 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond35 Using cfiCommon0
        CFI (cfiCond35) NoFunction
        CFI (cfiCond35) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond35) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond35) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond35) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond35) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond35) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond35) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond35) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond35) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond35) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond35) CFA_SP SP+0
        CFI (cfiCond35) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond36 Using cfiCommon0
        CFI (cfiCond36) NoFunction
        CFI (cfiCond36) Conditional ??CrossCallReturnLabel_4
        CFI (cfiCond36) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond36) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond36) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond36) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond36) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond36) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond36) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond36) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond36) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond36) CFA_SP SP+0
        CFI (cfiCond36) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker37 Using cfiCommon1
        CFI (cfiPicker37) NoFunction
        CFI (cfiPicker37) Picker
        MOVX    A,@DPTR
        ; Setup parameters for call to function SendData
        MOV     R1,A
        LCALL   ??SendData
        RET
        CFI EndBlock cfiCond34
        CFI EndBlock cfiCond35
        CFI EndBlock cfiCond36
        CFI EndBlock cfiPicker37

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond38 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond39 Using cfiCommon0
        CFI (cfiCond39) NoFunction
        CFI (cfiCond39) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond39) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond39) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond39) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond39) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond39) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond39) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond39) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond39) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond39) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond39) CFA_SP SP+0
        CFI (cfiCond39) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker40 Using cfiCommon1
        CFI (cfiPicker40) NoFunction
        CFI (cfiPicker40) Picker
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??SendData
        INC     DPTR
        LCALL   ?Subroutine8
??CrossCallReturnLabel_13:
        RET
        CFI EndBlock cfiCond38
        CFI EndBlock cfiCond39
        CFI EndBlock cfiPicker40

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine8:
        CFI Block cfiCond41 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_12
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond42 Using cfiCommon0
        CFI (cfiCond42) NoFunction
        CFI (cfiCond42) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_0
        CFI (cfiCond42) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond42) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond42) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond42) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond42) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond42) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond42) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond42) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond42) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond42) CFA_SP SP+0
        CFI (cfiCond42) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiCond43 Using cfiCommon0
        CFI (cfiCond43) NoFunction
        CFI (cfiCond43) Conditional ??CrossCallReturnLabel_13, ??CrossCallReturnLabel_1
        CFI (cfiCond43) R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond43) VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond43) V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond43) V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond43) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond43) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond43) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond43) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond43) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond43) CFA_SP SP+0
        CFI (cfiCond43) CFA_XSP16 add(XSP16, 9)
        CFI Block cfiPicker44 Using cfiCommon1
        CFI (cfiPicker44) NoFunction
        CFI (cfiPicker44) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPTR,#0x164
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
        RET
        CFI EndBlock cfiCond41
        CFI EndBlock cfiCond42
        CFI EndBlock cfiCond43
        CFI EndBlock cfiPicker44
//  879 
//  880 #endif
//  881 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  882 static void halAesLoadKeyOrInitVector(BYTE* pData, BOOL key)
??halAesLoadKeyOrInitVector:
        CFI Block cfiBlock45 Using cfiCommon0
        CFI Function ??halAesLoadKeyOrInitVector
        CODE
//  883 {
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  884    UINT8 i;
//  885 
//  886    // Checking whether to load a key or an initialisation vector.
//  887    if(key){
        MOV     A,R1
        JZ      ??halAesLoadKeyOrInitVector_1
//  888       AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_KEY);
        MOV     A,0xb3
        ANL     A,#0xf8
        ORL     A,#0x4
        SJMP    ??halAesLoadKeyOrInitVector_2
//  889    }
//  890    else {
//  891       AES_SET_ENCR_DECR_KEY_IV(AES_LOAD_IV);
??halAesLoadKeyOrInitVector_1:
        MOV     A,0xb3
        ANL     A,#0xf8
        ORL     A,#0x6
??halAesLoadKeyOrInitVector_2:
        MOV     0xb3,A
//  892    }
//  893    // Starting loading of key or vector.
//  894    AES_START();
        ORL     0xb3,#0x1
//  895 
//  896    // loading the data (key or vector)
//  897    for(i = 0; i < 16; i++){
        MOV     R0,#0x0
//  898       ENCDI = pData[i];
??halAesLoadKeyOrInitVector_3:
        MOV     ?V0 + 0,R0
        MOV     A,R2
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     0xb1,A
//  899    }
        INC     R0
        MOV     A,R0
        CLR     C
        SUBB    A,#0x10
        JC      ??halAesLoadKeyOrInitVector_3
//  900 }
        SJMP    ?Subroutine0
        CFI EndBlock cfiBlock45
        REQUIRE ENCCS
        REQUIRE ENCDI

        RSEG NEAR_CODE:CODE:NOROOT(0)
??halAesEncrDecr:
        CFI Block cfiBlock46 Using cfiCommon0
        CFI Function ??halAesEncrDecr
        CODE
        MOV     A,#-0x11
        LCALL   ?FUNC_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 17)
        ; Saved register size: 17
        ; Auto size: 0
        MOV     ?V0 + 6,R1
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
        MOV     A,#0x4
        MOV     R0,#?V0 + 0
        LCALL   ?US_SHR
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
        MOV     A,R4
        ANL     A,#0xf
        JZ      ??halAesEncrDecr_1
        MOV     A,?V0 + 2
        ADD     A,#0x1
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
??halAesEncrDecr_1:
        MOV     A,?V0 + 6
        JZ      ??halAesEncrDecr_2
        MOV     A,0xb3
        ANL     A,#0xf8
        ORL     A,#0x2
        MOV     0xb3,A
        SJMP    ??halAesEncrDecr_3
??halAesEncrDecr_2:
        ANL     0xb3,#0xf8
??halAesEncrDecr_3:
        MOV     A,0xb3
        ANL     A,#0x70
        MOV     ?V0 + 7,A
        MOV     ?V0 + 0,#0x0
        MOV     ?V0 + 1,#0x0
        SJMP    ??halAesEncrDecr_4
??halAesEncrDecr_5:
        CLR     A
??halAesEncrDecr_6:
        MOV     0xb1,A
        INC     ?V0 + 9
        MOV     A,?V0 + 9
        CLR     C
        SUBB    A,#0x10
        JC      ??halAesEncrDecr_7
        MOV     ?V0 + 4,#0xf
??halAesEncrDecr_8:
        MOV     ?V0 + 8,?V0 + 4
        MOV     A,#-0x1
        ADD     A,?V0 + 8
        MOV     ?V0 + 4,A
        INC     A
        JNZ     ??halAesEncrDecr_8
        MOV     ?V0 + 9,#0x0
??halAesEncrDecr_9:
        MOV     A,0xb2
        PUSH    A
        CFI CFA_SP SP+-1
        LCALL   ?Subroutine6
??CrossCallReturnLabel_7:
        MOV     A,R6
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,?V0 + 5
        MOV     DPH,A
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
        INC     ?V0 + 9
        MOV     A,?V0 + 9
        CLR     C
        SUBB    A,#0x10
        JC      ??halAesEncrDecr_9
??halAesEncrDecr_10:
        MOV     A,?V0 + 0
        ADD     A,#0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
??halAesEncrDecr_4:
        CLR     C
        MOV     A,?V0 + 0
        SUBB    A,?V0 + 2
        MOV     A,?V0 + 1
        SUBB    A,?V0 + 3
        JNC     ??halAesEncrDecr_11
        ORL     0xb3,#0x1
        MOV     ?V0 + 4,?V0 + 0
        MOV     ?V0 + 5,?V0 + 1
        MOV     A,#0x4
        MOV     R0,#?V0 + 4
        LCALL   ?S_SHL
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
        MOV     A,#0x10
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     A,#0x20
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     A,#0x30
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     A,#0x50
        XRL     A,?V0 + 7
        JZ      ??halAesEncrDecr_10
        MOV     ?V0 + 9,#0x0
??halAesEncrDecr_7:
        LCALL   ?Subroutine6
??CrossCallReturnLabel_8:
        CLR     C
        MOV     A,?V0 + 4
        SUBB    A,R4
        MOV     A,?V0 + 5
        SUBB    A,R5
        JC      $+5
        LJMP    ??halAesEncrDecr_5
        MOV     A,R2
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,?V0 + 5
        MOV     DPH,A
        MOVX    A,@DPTR
        LJMP    ??halAesEncrDecr_6
??halAesEncrDecr_11:
        MOV     R7,#0xa
        LJMP    ?FUNC_LEAVE_XDATA
        CFI EndBlock cfiBlock46
        REQUIRE ENCCS
        REQUIRE ENCDI
        REQUIRE ENCDO

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond47 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_7
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+-1
        CFI CFA_XSP16 add(XSP16, 17)
        CFI Block cfiCond48 Using cfiCommon0
        CFI (cfiCond48) NoFunction
        CFI (cfiCond48) Conditional ??CrossCallReturnLabel_8
        CFI (cfiCond48) R6 load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI (cfiCond48) VB load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond48) V0 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond48) V1 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond48) V2 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond48) V3 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond48) V4 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond48) V5 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond48) V6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond48) V7 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond48) V8 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond48) V9 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond48) R7 load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond48) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond48) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond48) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond48) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond48) CFA_SP SP+0
        CFI (cfiCond48) CFA_XSP16 add(XSP16, 17)
        CFI Block cfiPicker49 Using cfiCommon1
        CFI (cfiPicker49) NoFunction
        CFI (cfiPicker49) Picker
        MOV     ?V0 + 4,?V0 + 9
        MOV     A,R0
        ADD     A,?V0 + 4
        MOV     ?V0 + 4,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     ?V0 + 5,A
        RET
        CFI EndBlock cfiCond47
        CFI EndBlock cfiCond48
        CFI EndBlock cfiPicker49

        RSEG NEAR_CODE:CODE:NOROOT(0)
main:
        CFI Block cfiBlock50 Using cfiCommon0
        CFI Function main
        CODE
        FUNCALL main, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??putsDialog
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesLoadKeyOrInitVector
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesEncrDecr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesLoadKeyOrInitVector
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??MemReadRam
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesEncrDecr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??putsDialog
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??MemReadRam
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesEncrDecr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??MemReadRam
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??delay
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??putsDialog
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??delay
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Uart_Send_String
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Rcv
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??halAesEncrDecr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, HalFlashWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??delay
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Message_Send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL main, ??Uart_Send_String
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        ; Auto size: 36
        MOV     A,#-0x24
        LCALL   ?ALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        MOV     DPTR,#`?<Constant {63, 221, 251, 183, 32, 177, 149, 1`
        PUSH    DPL
        CFI CFA_SP SP+-3
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPH,#(`?<Constant {63, 221, 251, 183, 32, 177, 149, 1` >> 8) & 0xff
        POP     DPL
        CFI CFA_SP SP+-2
        MOV     A,#0x10
        LCALL   ?MOVE_LONG8_XDATA_XDATA
        MOV     R6,A
        MOV     R7,#0x8
        MOV     ?V0 + 0,#0x4
        ANL     0xbe,#0xfb
??main_0:
        MOV     A,0x9d
        MOV     C,0xE0 /* A   */.6
        JNC     ??main_0
        NOP
        MOV     R0,#-0x8
        MOV     R1,#0x1
??main_1:
        NOP
        MOV     A,R0
        ADD     A,#-0x1
        DEC     R0
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??main_1
        MOV     0xc6,#-0x80
??main_2:
        MOV     A,#-0x80
        XRL     A,0x9e
        JNZ     ??main_2
        ORL     0xbe,#0x4
        MOV     DPTR,#0x6270
        MOV     A,R7
        MOVX    @DPTR,A
        ORL     0xfe,#0x4
        ORL     0xfd,#0x80
        ORL     0x8f,#0x1
        ORL     0xfe,#0x4
        ORL     0xfe,#0x8
        MOV     A,#(dmaCh0 >> 8) & 0xff
        MOV     0xd5,A
        MOV     0xd4,#dmaCh0 & 0xff
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0 + 2,#0x1d
        MOV     ?V0 + 3,R6
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     R4,#??ramCode & 0xff
        MOV     R5,#(??ramCode >> 8) & 0xff
        MOV     R2,#-0x1d
        MOV     R3,#0x7
        MOV     R1,#0x0
        LCALL   HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        ANL     0xfd,#0xdf
        ANL     0xf3,#0xdf
        ANL     0xfd,#0xdf
        ANL     0x8f,#0xdf
        ANL     0xc6,#0xbf
??main_3:
        MOV     A,0x9e
        MOV     C,0xE0 /* A   */.6
        JC      ??main_3
        ANL     0xc6,#0xb8
        MOV     0xf1,#0x0
        ORL     0xf3,#0xc
        ANL     0xff,#0x3f
        ORL     0x86,#0x80
        ORL     0xc5,#0xb
        ORL     0xc2,#0xd8
        CLR     0xe8.1
        ORL     0x86,#0x40
        CLR     0x88.3
        ANL     0xb3,#0x8f
        ORL     0xb3,#0x40
        ; Setup parameters for call to function putsDialog
        MOV     R2,#`?<Constant "BOOT\\r\\n">` & 0xff
        MOV     R3,#(`?<Constant "BOOT\\r\\n">` >> 8) & 0xff
        LCALL   ??putsDialog
        ; Setup parameters for call to function halAesLoadKeyOrInitVector
        MOV     R1,#0x1
        MOV     R2,#??cpuIdKey & 0xff
        MOV     R3,#(??cpuIdKey >> 8) & 0xff
        LCALL   ??halAesLoadKeyOrInitVector
        ; Setup parameters for call to function halAesEncrDecr
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     R1,#0x1
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine11
??CrossCallReturnLabel_25:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        ; Setup parameters for call to function halAesLoadKeyOrInitVector
        MOV     R1,#0x1
        MOV     R2,#`?<Constant "MakeTomorrowBest">` & 0xff
        MOV     R3,#(`?<Constant "MakeTomorrowBest">` >> 8) & 0xff
        LCALL   ??halAesLoadKeyOrInitVector
        ; Setup parameters for call to function MemReadRam
        MOV     R1,#0x8
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#0xc
        MOV     R3,#0x78
        LCALL   ??MemReadRam
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0 + 2,#0x14
        MOV     ?V0 + 3,R6
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x10
        MOV     R3,#0x7
        MOV     R1,#0x3
        LCALL   HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        ; Setup parameters for call to function halAesEncrDecr
        MOV     DPL,?XSP + 0
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     R1,#0x1
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine11
??CrossCallReturnLabel_26:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        MOV     DPL,?XSP + 0
        PUSH    DPL
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI CFA_SP SP+-4
        MOV     DPTR,#__Constant_3a4d3254
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        POP     DPH
        CFI CFA_SP SP+-3
        POP     DPL
        CFI CFA_SP SP+-2
        MOV     R0,#?V0 + 4
        LCALL   ?L_EQ_X
        JNZ     ??main_4
        ; Setup parameters for call to function putsDialog
        MOV     R2,#`?<Constant "Initial\\r\\n">` & 0xff
        MOV     R3,#(`?<Constant "Initial\\r\\n">` >> 8) & 0xff
        LCALL   ??putsDialog
        MOV     DPTR,#__Constant_f8900a6
        LCALL   ?XLOAD_R2345
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        LCALL   ?XSTORE_R2345
        ; Setup parameters for call to function MemReadRam
        MOV     R1,#0x8
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine12
??CrossCallReturnLabel_16:
        ; Setup parameters for call to function halAesEncrDecr
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     R1,#0x0
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine11
??CrossCallReturnLabel_27:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        MOV     DPTR,#0x6272
        MOV     A,#0x6
        LCALL   ?Subroutine13
??CrossCallReturnLabel_18:
        ; Setup parameters for call to function HalFlashWrite
        MOV     ?V0 + 2,#0x4
        MOV     ?V0 + 3,R6
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#-0x4
        MOV     R3,#0x7
        LCALL   HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        LJMP    ??main_5
??main_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        PUSH    DPL
        CFI CFA_SP SP+-3
        PUSH    DPH
        CFI CFA_SP SP+-4
        MOV     DPTR,#__Constant_f8900a6
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        POP     DPH
        CFI CFA_SP SP+-3
        POP     DPL
        CFI CFA_SP SP+-2
        MOV     R0,#?V0 + 4
        LCALL   ?L_EQ_X
        JNZ     ??main_6
        ; Setup parameters for call to function MemReadRam
        MOV     R1,#0x8
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?Subroutine12
??CrossCallReturnLabel_17:
        MOV     ?V0 + 4,R7
        MOV     ?V0 + 5,R6
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
??main_7:
        MOV     R4,?V0 + 4
        MOV     R5,?V0 + 5
        MOV     A,R4
        ADD     A,#-0x1
        MOV     ?V0 + 4,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     ?V0 + 5,A
        MOV     A,R4
        ORL     A,R5
        JZ      ??main_8
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        XRL     A,R4
        JZ      ??main_7
        MOV     ?V0 + 2,#-0x18
        MOV     ?V0 + 3,#0x3
??main_9:
        ; Setup parameters for call to function delay
        LCALL   ?Subroutine10
??CrossCallReturnLabel_14:
        JNZ     ??main_9
        LJMP 0x0000
??main_8:
        ; Setup parameters for call to function putsDialog
        MOV     R2,#`?<Constant "Start\\r\\n">` & 0xff
        MOV     R3,#(`?<Constant "Start\\r\\n">` >> 8) & 0xff
        LCALL   ??putsDialog
        SJMP    ??main_5
??main_6:
        MOV     ?V0 + 2,#-0x18
        MOV     ?V0 + 3,#0x3
??main_10:
        ; Setup parameters for call to function delay
        LCALL   ?Subroutine10
??CrossCallReturnLabel_15:
        JNZ     ??main_10
        LJMP 0x0000
??main_5:
        MOV     C,0x80.5
        MOV     R4,#0x4
        MOV     R5,#0x0
        JNC     $+5
        LJMP    ??main_11
        ; Setup parameters for call to function Uart_Send_String
        MOV     R2,#`?<Constant "boot">` & 0xff
        MOV     R3,#(`?<Constant "boot">` >> 8) & 0xff
        LCALL   ??Uart_Send_String
        ORL     0xfe,#0x18
        CLR     0x90.4
        SJMP    ??main_12
??main_13:
        MOV     ?V0 + 2,#0x0
        MOV     ?V0 + 3,#0x0
??main_14:
        ; Setup parameters for call to function HalFlashRead
        MOV     ?V0 + 4,#0x40
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     R4,#0x14
        MOV     R5,#0x1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     R1,?V0 + 0
        LCALL   HalFlashRead
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        MOV     DPTR,#0x113
        MOV     A,#0x40
        MOVX    @DPTR,A
        ; Setup parameters for call to function Message_Send
        LCALL   ??Message_Send
        MOV     A,?V0 + 2
        ADD     A,#0x40
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
        CLR     C
        SUBB    A,#0x8
        JC      ??main_14
        INC     ?V0 + 0
??main_12:
        ; Setup parameters for call to function Message_Rcv
        LCALL   ??Message_Rcv
        MOV     A,R1
        JZ      ??main_12
        MOV     C,0x90.3
        JNC     ??main_15
        CLR     0x90.3
        SJMP    ??main_16
??main_15:
        SETB    0x90.3
??main_16:
        MOV     DPTR,#0x100
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#0x102
        MOVX    @DPTR,A
        MOV     DPTR,#0x111
        MOVX    A,@DPTR
        ADD     A,#-0x41
        JZ      ??main_17
        DEC     A
        JNZ     $+5
        LJMP    ??main_18
        ADD     A,#-0x5
        JZ      ??main_13
        DEC     A
        JNZ     $+5
        LJMP    ??main_19
        SJMP    ??main_12
??main_17:
        ; Setup parameters for call to function halAesEncrDecr
        MOV     ?V0 + 2,#0x14
        MOV     ?V0 + 3,#0x1
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     R1,#0x1
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     R2,#0x14
        MOV     R3,#0x1
        LCALL   ??Subroutine15_0
??CrossCallReturnLabel_28:
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        CLR     C
        MOV     A,R7
        SUBB    A,#0x8
        JC      ??main_20
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        ANL     A,#0x1
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??CrossCallReturnLabel_19
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,R7
        MOV     A,#0x9
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     A,?V0 + 2
        CLR     C
        RLC     A
        MOV     DPTR,#0x6272
        LCALL   ?Subroutine13
??CrossCallReturnLabel_19:
        ; Setup parameters for call to function HalFlashWrite
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        CFI CFA_XSP16 add(XSP16, 38)
        MOV     R4,#0x14
        MOV     R5,#0x1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   HalFlashWrite
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 add(XSP16, 36)
        MOV     DPTR,#0x113
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R0,A
        MOV     A,R6
        ADD     A,R0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
        ; Setup parameters for call to function delay
        MOV     R2,#-0x18
        MOV     R3,#0x3
        LCALL   ??delay
        INC     DPTR
??main_21:
        CLR     A
        SJMP    ??main_22
??main_20:
        MOV     DPTR,#0x114
        MOV     A,#0x1
??main_22:
        MOVX    @DPTR,A
        MOV     DPTR,#0x113
        MOV     A,#0x2
??main_23:
        MOVX    @DPTR,A
        ; Setup parameters for call to function Message_Send
        LCALL   ??Message_Send
        LJMP    ??main_12
??main_19:
        MOV     R6,#0x0
        MOV     R7,#0x8
        MOV     DPTR,#0x114
        SJMP    ??main_21
??main_18:
        MOV     DPTR,#0x114
        MOV     A,#0x55
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#0x113
        MOV     A,#0x3
        SJMP    ??main_23
??main_11:
        ; Setup parameters for call to function Uart_Send_String
        MOV     R2,#`?<Constant "jump">` & 0xff
        MOV     R3,#(`?<Constant "jump">` >> 8) & 0xff
        LCALL   ??Uart_Send_String
        LJMP 0x2000
        MOV     A,#0x24
        LCALL   ?DEALLOC_XSTACK8
        CFI CFA_XSP16 XSP16+0
        RET
        CFI EndBlock cfiBlock50
        REQUIRE SLEEPCMD
        REQUIRE SLEEPSTA
        REQUIRE CLKCONCMD
        REQUIRE CLKCONSTA
        REQUIRE P1DIR
        REQUIRE P0DIR
        REQUIRE P0INP
        REQUIRE DMA0CFGH
        REQUIRE DMA0CFGL
        REQUIRE P0SEL
        REQUIRE ENCCS
        REQUIRE _A_P0
        REQUIRE _A_P1
        REQUIRE PERCFG
        REQUIRE P2DIR
        REQUIRE U0CSR
        REQUIRE U0GCR
        REQUIRE U0BAUD
        REQUIRE _A_IRCON2
        REQUIRE _A_TCON

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine13:
        CFI Block cfiCond51 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_18
        CFI CFA_XSP16 add(XSP16, 36)
        CFI Block cfiCond52 Using cfiCommon0
        CFI (cfiCond52) NoFunction
        CFI (cfiCond52) Conditional ??CrossCallReturnLabel_19
        CFI (cfiCond52) CFA_XSP16 add(XSP16, 36)
        CFI Block cfiPicker53 Using cfiCommon1
        CFI (cfiPicker53) NoFunction
        CFI (cfiPicker53) Picker
        MOVX    @DPTR,A
        MOV     DPTR,#0x6270
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
        RET
        CFI EndBlock cfiCond51
        CFI EndBlock cfiCond52
        CFI EndBlock cfiPicker53

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine12:
        CFI Block cfiCond54 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_16
        CFI CFA_XSP16 add(XSP16, 36)
        CFI Block cfiCond55 Using cfiCommon0
        CFI (cfiCond55) NoFunction
        CFI (cfiCond55) Conditional ??CrossCallReturnLabel_17
        CFI (cfiCond55) CFA_XSP16 add(XSP16, 36)
        CFI Block cfiPicker56 Using cfiCommon1
        CFI (cfiPicker56) NoFunction
        CFI (cfiPicker56) Picker
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??MemReadRam
        RET
        CFI EndBlock cfiCond54
        CFI EndBlock cfiCond55
        CFI EndBlock cfiPicker56

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine11:
        CFI Block cfiCond57 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_25
        CFI CFA_XSP16 add(XSP16, 38)
        CFI Block cfiCond58 Using cfiCommon0
        CFI (cfiCond58) NoFunction
        CFI (cfiCond58) Conditional ??CrossCallReturnLabel_26
        CFI (cfiCond58) CFA_XSP16 add(XSP16, 38)
        CFI Block cfiCond59 Using cfiCommon0
        CFI (cfiCond59) NoFunction
        CFI (cfiCond59) Conditional ??CrossCallReturnLabel_27
        CFI (cfiCond59) CFA_XSP16 add(XSP16, 38)
        CFI Block cfiPicker60 Using cfiCommon1
        CFI (cfiPicker60) NoFunction
        CFI (cfiPicker60) Picker
        MOV     R2,DPL
        MOV     R3,DPH
        CFI EndBlock cfiCond57
        CFI EndBlock cfiCond58
        CFI EndBlock cfiCond59
        CFI EndBlock cfiPicker60
        REQUIRE ??Subroutine15_0
        ; // Fall through to label ??Subroutine15_0

        RSEG NEAR_CODE:CODE:NOROOT(0)
??Subroutine15_0:
        CFI Block cfiCond61 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_28
        CFI CFA_XSP16 add(XSP16, 38)
        CFI Block cfiCond62 Using cfiCommon0
        CFI (cfiCond62) NoFunction
        CFI (cfiCond62) Conditional ??CrossCallReturnLabel_25
        CFI (cfiCond62) CFA_XSP16 add(XSP16, 38)
        CFI Block cfiCond63 Using cfiCommon0
        CFI (cfiCond63) NoFunction
        CFI (cfiCond63) Conditional ??CrossCallReturnLabel_26
        CFI (cfiCond63) CFA_XSP16 add(XSP16, 38)
        CFI Block cfiCond64 Using cfiCommon0
        CFI (cfiCond64) NoFunction
        CFI (cfiCond64) Conditional ??CrossCallReturnLabel_27
        CFI (cfiCond64) CFA_XSP16 add(XSP16, 38)
        CFI Block cfiPicker65 Using cfiCommon1
        CFI (cfiPicker65) NoFunction
        CFI (cfiPicker65) Picker
        LCALL   ??halAesEncrDecr
        MOV     A,#0x2
        RET
        CFI EndBlock cfiCond61
        CFI EndBlock cfiCond62
        CFI EndBlock cfiCond63
        CFI EndBlock cfiCond64
        CFI EndBlock cfiPicker65

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine10:
        CFI Block cfiCond66 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_14
        CFI CFA_XSP16 add(XSP16, 36)
        CFI Block cfiCond67 Using cfiCommon0
        CFI (cfiCond67) NoFunction
        CFI (cfiCond67) Conditional ??CrossCallReturnLabel_15
        CFI (cfiCond67) CFA_XSP16 add(XSP16, 36)
        CFI Block cfiPicker68 Using cfiCommon1
        CFI (cfiPicker68) NoFunction
        CFI (cfiPicker68) Picker
        MOV     R2,#-0x18
        MOV     R3,#0x3
        LCALL   ??delay
        MOV     A,?V0 + 2
        ADD     A,#-0x1
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#-0x1
        MOV     ?V0 + 3,A
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        RET
        CFI EndBlock cfiCond66
        CFI EndBlock cfiCond67
        CFI EndBlock cfiPicker68

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant {63, 221, 251, 183`:
        DATA8
        DB 63
        DB 221
        DB 251
        DB 183
        DB 32
        DB 177
        DB 149
        DB 137
        DB 117
        DB 214
        DB 110
        DB 146
        DB 63
        DB 247
        DB 240
        DB 173

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "MakeTomorrowBest"`:
        DB "MakeTomorrowBest"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "BOOT\\r\\n">>`:
        DB "BOOT\015\012"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Initial\\r\\n">>`:
        DB "Initial\015\012"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "Start\\r\\n">>`:
        DB "Start\015\012"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "boot">>`:
        DB "boot"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "jump">>`:
        DB "jump"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for cpuIdKey>`:
        DATA8
        DB 36
        DB 152
        DB 183
        DB 160
        DB 203
        DB 223
        DB 230
        DB 93
        DB 209
        DB 75
        DB 247
        DB 81
        DB 166
        DB 1
        DB 152
        DB 34

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_3a4d3254>`:
        DATA32
        DD 978137684

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_f8900a6>`:
        DATA32
        DD 260636838

        END
//  901 
//  902 static void halAesEncrDecr(BYTE *pDataIn, UINT16 length, BYTE *pDataOut, /*BYTE *pInitVector, */BOOL decr)
//  903 {
//  904    UINT16  i;
//  905    UINT8   j, k;
//  906    BYTE    mode;
//  907    UINT16  nbrOfBlocks;
//  908    UINT16  convertedBlock;
//  909    UINT8   delay;
//  910 
//  911    nbrOfBlocks = length / 16;
//  912    mode = 0;
//  913 
//  914    if( (length % 16) != 0){
//  915       // length not multiplum of 16, convert one block extra with zeropadding
//  916       nbrOfBlocks++;
//  917    }
//  918 
//  919    // Loading the IV.
//  920    //halAesLoadKeyOrInitVector(pInitVector, FALSE);
//  921 
//  922    // Starting either encryption or decryption
//  923    if(decr){
//  924       AES_SET_ENCR_DECR_KEY_IV(AES_DECRYPT);
//  925    } else {
//  926       AES_SET_ENCR_DECR_KEY_IV(AES_ENCRYPT);
//  927    }
//  928 
//  929    // Getting the operation mode.
//  930    mode = ENCCS & 0x70;
//  931 
//  932    for(convertedBlock = 0; convertedBlock < nbrOfBlocks; convertedBlock++){
//  933       // Starting the conversion.
//  934       AES_START();
//  935 
//  936       i = convertedBlock * 16;
//  937       // Counter, Output Feedback and Cipher Feedback operates on 4 bytes and not 16 bytes.
//  938       if((mode == CFB) || (mode == OFB) || (mode == CTR))
//  939 	 {
//  940 /*
//  941          for(j = 0; j < 4; j++){
//  942             // Writing the input data
//  943             // Zeropadding the remainder of the block
//  944             for(k = 0; k < 4; k++){
//  945                ENCDI = ((i + 4*j + k < length) ? pDataIn[i + 4*j + k] : 0x00 );
//  946             }
//  947             // wait for data ready
//  948             delay = DELAY;
//  949             while(delay--);
//  950             // Read out data for every 4th byte
//  951             for(k = 0; k < 4; k++){
//  952                pDataOut[i + 4*j + k] = ENCDO;
//  953             }
//  954          }
//  955 */
//  956       }
//  957       else if(mode == CBC_MAC){/*
//  958          // Writing the input data
//  959          // Zeropadding the remainder of the block
//  960          for(j = 0; j < 16; j++){
//  961             ENCDI = ((i + j < length) ? pDataIn[i + j] : 0x00 );
//  962          }
//  963          // The last block of the CBC-MAC is computed by using CBC mode.
//  964          if(convertedBlock == nbrOfBlocks - 2){
//  965             AES_SETMODE(CBC);
//  966             delay = DELAY;
//  967             while(delay--);
//  968          }
//  969          // The CBC-MAC does not produce an output on the n-1 first blocks
//  970          // only the last block is read out
//  971          else if(convertedBlock == nbrOfBlocks - 1){
//  972             // wait for data ready
//  973             delay = DELAY;
//  974             while(delay--);
//  975             for(j = 0; j < 16; j++){
//  976                pDataOut[j] = ENCDO;
//  977             }
//  978          }*/
//  979       }
//  980       else{
//  981          // Writing the input data
//  982          // Zeropadding the remainder of the block
//  983          for(j = 0; j < 16; j++){
//  984             ENCDI = ((i+j < length) ? pDataIn[i+j] : 0x00 );
//  985          }
//  986          // wait for data ready
//  987          delay = DELAY;
//  988          while(delay--);
//  989          // Read out data
//  990          for(j = 0; j < 16; j++){
//  991             pDataOut[i+j] = ENCDO;
//  992          }
//  993       }
//  994    }
//  995 }
//  996 
//  997 
//  998  #ifdef _USER_OAD_FLASH_WRITE_
//  999 static void dl2rc(void)
// 1000 {
// 1001   preamble_t preamble;
// 1002   uint32 oset;
// 1003   uint16 addr = HAL_OAD_RC_START / HAL_FLASH_WORD_SIZE;				//0x0800/4		user code start address
// 1004   uint8 buf[4];
// 1005 
// 1006   HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
// 1007   //preamble.len = 65536;
// 1008 
// 1009   for (oset = 0; oset < preamble.len; oset += HAL_FLASH_WORD_SIZE)
// 1010   {
// 1011     HalOADRead(oset, buf, HAL_FLASH_WORD_SIZE, HAL_OAD_DL);
// 1012     if ((addr % (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE)) == 0)
// 1013     {
// 1014       HalFlashErase(addr / (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE));
// 1015     }
// 1016     HalFlashWrite(addr++, buf, 1);
// 1017   }
// 1018 }  
// 1019 
// 1020 /*********************************************************************
// 1021  * @fn      crcCalc
// 1022  *
// 1023  * @brief   Run the CRC16 Polynomial calculation over the RC image.
// 1024  *
// 1025  * @param   None.
// 1026  *
// 1027  * @return  The CRC16 calculated.
// 1028  */
// 1029 static uint16 crcCalc(void)
// 1030 {
// 1031   preamble_t preamble;
// 1032   uint32 oset;
// 1033   uint16 crc = 0;
// 1034 
// 1035   HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
// 1036 
// 1037   // Run the CRC calculation over the active body of code.
// 1038   for (oset = 0; oset < preamble.len; oset++)
// 1039   {
// 1040     if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
// 1041     {
// 1042       uint8 buf;
// 1043       HalOADRead(oset, &buf, 1, HAL_OAD_RC);
// 1044       crc = runPoly(crc, buf);
// 1045     }
// 1046   }
// 1047 
// 1048   // IAR note explains that poly must be run with value zero for each byte of crc.
// 1049   crc = runPoly(crc, 0);
// 1050   crc = runPoly(crc, 0);
// 1051 
// 1052   return crc;
// 1053 }
// 1054 #endif
// 1055 //#endif
// 1056 
// 1057 /*********************************************************************
// 1058  * @fn      runPoly
// 1059  *
// 1060  * @brief   Run the CRC16 Polynomial calculation over the byte parameter.
// 1061  *
// 1062  * @param   crc - Running CRC calculated so far.
// 1063  * @param   val - Value on which to run the CRC16.
// 1064  *
// 1065  * @return  crc - Updated for the run.
// 1066  */
// 1067  #if _USER_OAD_FLASH_WRITE_
// 1068 static uint16 runPoly(uint16 crc, uint8 val)
// 1069 {
// 1070   const uint16 poly = 0x1021;
// 1071   uint8 cnt;
// 1072 
// 1073   for (cnt = 0; cnt < 8; cnt++, val <<= 1)
// 1074   {
// 1075     uint8 msb = (crc & 0x8000) ? 1 : 0;
// 1076 
// 1077     crc <<= 1;
// 1078     if (val & 0x80)  crc |= 0x0001;
// 1079     if (msb)         crc ^= poly;
// 1080   }
// 1081 
// 1082   return crc;
// 1083 }
// 1084 
// 1085 /*********************************************************************
// 1086  * @fn      HalOADChkDL
// 1087  *
// 1088  * @brief   Run the CRC16 Polynomial calculation over the DL image.
// 1089  *
// 1090  * @param   dlImagePreambleOffset - Offset into the monolithic DL image to read the preamble.
// 1091  *
// 1092  * @return  SUCCESS or FAILURE.
// 1093  *********************************************************************/
// 1094 uint8 HalOADChkDL(uint8 dlImagePreambleOffset)
// 1095 {
// 1096   preamble_t preamble;
// 1097   uint32 oset;
// 1098   uint16 crc = 0, crc2;
// 1099 
// 1100   HalOADRead(dlImagePreambleOffset, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_DL);
// 1101 
// 1102   // Run the CRC calculation over the downloaded image.
// 1103   for (oset = 0; oset < preamble.len; oset++)
// 1104   {
// 1105     if ((oset < HAL_OAD_CRC_OSET) || (oset >= HAL_OAD_CRC_OSET+4))
// 1106     {
// 1107       uint8 buf;
// 1108       HalOADRead(oset, &buf, 1, HAL_OAD_DL);
// 1109       crc = runPoly(crc, buf);
// 1110     }
// 1111   }
// 1112 
// 1113   // IAR note explains that poly must be run with value zero for each byte of crc.
// 1114   crc = runPoly(crc, 0);
// 1115   crc = runPoly(crc, 0);
// 1116 
// 1117   HalOADRead(HAL_OAD_CRC_OSET, (uint8 *)&crc2, sizeof(crc2), HAL_OAD_DL);
// 1118   return (crc2 == crc) ? SUCCESS : FAILURE;
// 1119 }
// 1120 
// 1121 /*********************************************************************
// 1122  * @fn      HalOADInvRC
// 1123  *
// 1124  * @brief   Invalidate the active image so that the boot code will instantiate the DL image on the
// 1125  *          next reset.
// 1126  *
// 1127  * @param   None.
// 1128  *
// 1129  * @return  None.
// 1130  *********************************************************************/
// 1131 void HalOADInvRC(void)
// 1132 {
// 1133   uint16 crc[2] = {0,0xFFFF};
// 1134   HalFlashWrite((HAL_OAD_CRC_ADDR / HAL_FLASH_WORD_SIZE), (uint8 *)crc, 1);
// 1135 }
// 1136 
// 1137 /*********************************************************************
// 1138  * @fn      HalOADRead
// 1139  *
// 1140  * @brief   Read from the storage medium according to image type.
// 1141  *
// 1142  * @param   oset - Offset into the monolithic image.
// 1143  * @param   pBuf - Pointer to the buffer in which to copy the bytes read.
// 1144  * @param   len - Number of bytes to read.
// 1145  * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
// 1146  *
// 1147  * @return  None.
// 1148  *********************************************************************/
// 1149 void HalOADRead(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
// 1150 {
// 1151   if (HAL_OAD_RC != type)
// 1152   {
// 1153 #if HAL_OAD_XNV_IS_INT
// 1154     preamble_t preamble;
// 1155 
// 1156     HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
// 1157     //oset += HAL_OAD_RC_START + preamble.len;
// 1158     oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
// 1159 #elif HAL_OAD_XNV_IS_SPI
// 1160     oset += HAL_OAD_DL_OSET;
// 1161     HalSPIRead(oset, pBuf, len);
// 1162     return;
// 1163 #endif
// 1164   }
// 1165   else
// 1166   {
// 1167     oset += HAL_OAD_RC_START;
// 1168   }
// 1169 
// 1170   HalFlashRead(oset / HAL_FLASH_PAGE_SIZE, oset % HAL_FLASH_PAGE_SIZE, pBuf, len);
// 1171 }
// 1172 
// 1173 /*********************************************************************
// 1174  * @fn      HalOADWrite
// 1175  *
// 1176  * @brief   Write to the storage medium according to the image type.
// 1177  *
// 1178  *  NOTE:   Destructive write on page boundary! When writing to the first flash word
// 1179  *          of a page boundary, the page is erased without saving/restoring the bytes not written.
// 1180  *          Writes anywhere else on a page assume that the location written to has been erased.
// 1181  *
// 1182  * @param   oset - Offset into the monolithic image, aligned to HAL_FLASH_WORD_SIZE.
// 1183  * @param   pBuf - Pointer to the buffer in from which to write.
// 1184  * @param   len - Number of bytes to write. If not an even multiple of HAL_FLASH_WORD_SIZE,
// 1185  *                remainder bytes are overwritten with garbage.
// 1186  * @param   type - Which image: HAL_OAD_RC or HAL_OAD_DL.
// 1187  *
// 1188  * @return  None.
// 1189  *********************************************************************/
// 1190 void HalOADWrite(uint32 oset, uint8 *pBuf, uint16 len, image_t type)
// 1191 {
// 1192   if (HAL_OAD_RC != type)
// 1193   {
// 1194 #if HAL_OAD_XNV_IS_INT
// 1195     preamble_t preamble;
// 1196 
// 1197     HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
// 1198     //oset += HAL_OAD_RC_START + preamble.len;
// 1199     oset += HAL_OAD_RC_START + HAL_OAD_DL_OSET;
// 1200 #elif HAL_OAD_XNV_IS_SPI
// 1201     oset += HAL_OAD_DL_OSET;
// 1202     HalSPIWrite(oset, pBuf, len);
// 1203     return;
// 1204 #endif
// 1205   }
// 1206   else
// 1207   {
// 1208     oset += HAL_OAD_RC_START;
// 1209   }
// 1210 
// 1211   if ((oset % HAL_FLASH_PAGE_SIZE) == 0)
// 1212   {
// 1213     HalFlashErase(oset / HAL_FLASH_PAGE_SIZE);
// 1214   }
// 1215 
// 1216   HalFlashWrite(oset / HAL_FLASH_WORD_SIZE, pBuf, len / HAL_FLASH_WORD_SIZE);
// 1217 }
// 1218 
// 1219 #if HAL_OAD_XNV_IS_INT
// 1220 /*********************************************************************
// 1221  * @fn      HalOADAvail
// 1222  *
// 1223  * @brief   Determine the space available for downloading an image.
// 1224  *
// 1225  * @param   None.
// 1226  *
// 1227  * @return  Number of bytes available for storing an OAD image.
// 1228  *********************************************************************/
// 1229 uint32 HalOADAvail(void)
// 1230 {
// 1231   /*
// 1232   preamble_t preamble;
// 1233 
// 1234   HalOADRead(PREAMBLE_OFFSET, (uint8 *)&preamble, sizeof(preamble_t), HAL_OAD_RC);
// 1235   return HAL_OAD_DL_MAX - preamble.len;
// 1236    */
// 1237   return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
// 1238 }
// 1239 
// 1240 #elif HAL_OAD_XNV_IS_SPI
// 1241 
// 1242 /*********************************************************************
// 1243  * CONSTANTS
// 1244  */
// 1245 
// 1246 #define XNV_STAT_CMD  0x05
// 1247 #define XNV_WREN_CMD  0x06
// 1248 #define XNV_WRPG_CMD  0x0A
// 1249 #define XNV_READ_CMD  0x0B
// 1250 
// 1251 #define XNV_STAT_WIP  0x01
// 1252 
// 1253 /*********************************************************************
// 1254  * @fn      xnvSPIWrite
// 1255  *
// 1256  * @brief   SPI write sequence for code size savings.
// 1257  *
// 1258  * @param   ch - The byte to write to the SPI.
// 1259  *
// 1260  * @return  None.
// 1261  *********************************************************************/
// 1262 static void xnvSPIWrite(uint8 ch);
// 1263 static void xnvSPIWrite(uint8 ch)
// 1264 {
// 1265   XNV_SPI_TX(ch);
// 1266   XNV_SPI_WAIT_RXRDY();
// 1267 }
// 1268 
// 1269 /*********************************************************************
// 1270  * @fn      HalOADAvail
// 1271  *
// 1272  * @brief   Determine the space available for downloading an image.
// 1273  *
// 1274  * @param   None.
// 1275  *
// 1276  * @return  Number of bytes available for storing an OAD image.
// 1277  *********************************************************************/
// 1278 uint32 HalOADAvail(void)
// 1279 {
// 1280   return HAL_OAD_DL_MAX - HAL_OAD_DL_OSET;
// 1281 }
// 1282 
// 1283 /*********************************************************************
// 1284  * @fn      HalSPIRead
// 1285  *
// 1286  * @brief   Read from the external NV storage via SPI.
// 1287  *
// 1288  * @param   addr - Offset into the external NV.
// 1289  * @param   pBuf - Pointer to the buffer in which to copy the bytes read from external NV.
// 1290  * @param   len - Number of bytes to read from external NV.
// 1291  *
// 1292  * @return  None.
// 1293  *********************************************************************/
// 1294 static void HalSPIRead(uint32 addr, uint8 *pBuf, uint16 len)
// 1295 {
// 1296 #if !HAL_OAD_BOOT_CODE
// 1297   uint8 shdw = P1DIR;
// 1298   halIntState_t his;
// 1299   HAL_ENTER_CRITICAL_SECTION(his);
// 1300   P1DIR |= BV(3);
// 1301 #endif
// 1302 
// 1303   XNV_SPI_BEGIN();
// 1304   do {
// 1305     xnvSPIWrite(XNV_STAT_CMD);
// 1306   } while (XNV_SPI_RX() & XNV_STAT_WIP);
// 1307   XNV_SPI_END();
// 1308   asm("NOP"); asm("NOP");
// 1309 
// 1310   XNV_SPI_BEGIN();
// 1311   xnvSPIWrite(XNV_READ_CMD);
// 1312   xnvSPIWrite(addr >> 16);
// 1313   xnvSPIWrite(addr >> 8);
// 1314   xnvSPIWrite(addr);
// 1315   xnvSPIWrite(0);
// 1316 
// 1317   while (len--)
// 1318   {
// 1319     xnvSPIWrite(0);
// 1320     *pBuf++ = XNV_SPI_RX();
// 1321   }
// 1322   XNV_SPI_END();
// 1323 
// 1324 #if !HAL_OAD_BOOT_CODE
// 1325   P1DIR = shdw;
// 1326   HAL_EXIT_CRITICAL_SECTION(his);
// 1327 #endif
// 1328 }
// 1329 
// 1330 /*********************************************************************
// 1331  * @fn      HalSPIWrite
// 1332  *
// 1333  * @brief   Write to the external NV storage via SPI.
// 1334  *
// 1335  * @param   addr - Offset into the external NV.
// 1336  * @param   pBuf - Pointer to the buffer in from which to write bytes to external NV.
// 1337  * @param   len - Number of bytes to write to external NV.
// 1338  *
// 1339  * @return  None.
// 1340  *********************************************************************/
// 1341 static void HalSPIWrite(uint32 addr, uint8 *pBuf, uint16 len)
// 1342 {
// 1343   uint8 cnt;
// 1344 #if !HAL_OAD_BOOT_CODE
// 1345   uint8 shdw = P1DIR;
// 1346   halIntState_t his;
// 1347   HAL_ENTER_CRITICAL_SECTION(his);
// 1348   P1DIR |= BV(3);
// 1349 #endif
// 1350 
// 1351   while (len)
// 1352   {
// 1353     XNV_SPI_BEGIN();
// 1354     do {
// 1355       xnvSPIWrite(XNV_STAT_CMD);
// 1356     } while (XNV_SPI_RX() & XNV_STAT_WIP);
// 1357     XNV_SPI_END();
// 1358     asm("NOP"); asm("NOP");
// 1359 
// 1360     XNV_SPI_BEGIN();
// 1361     xnvSPIWrite(XNV_WREN_CMD);
// 1362     XNV_SPI_END();
// 1363     asm("NOP"); asm("NOP");
// 1364 
// 1365     XNV_SPI_BEGIN();
// 1366     xnvSPIWrite(XNV_WRPG_CMD);
// 1367     xnvSPIWrite(addr >> 16);
// 1368     xnvSPIWrite(addr >> 8);
// 1369     xnvSPIWrite(addr);
// 1370 
// 1371     // Can only write within any one page boundary, so prepare for next page write if bytes remain.
// 1372     cnt = 0 - (uint8)addr;
// 1373     if (cnt)
// 1374     {
// 1375       addr += cnt;
// 1376     }
// 1377     else
// 1378     {
// 1379       addr += 256;
// 1380     }
// 1381 
// 1382     do
// 1383     {
// 1384       xnvSPIWrite(*pBuf++);
// 1385       cnt--;
// 1386       len--;
// 1387     } while (len && cnt);
// 1388     XNV_SPI_END();
// 1389   }
// 1390 
// 1391 #if !HAL_OAD_BOOT_CODE
// 1392   P1DIR = shdw;
// 1393   HAL_EXIT_CRITICAL_SECTION(his);
// 1394 #endif
// 1395 }
// 1396 #else
// 1397 #error Invalid Xtra-NV for OAD.
// 1398 #endif
// 1399 
// 1400 #endif
// 1401 
// 1402 #if defined HAL_PA_LNA || defined HAL_PA_LNA_CC2590
// 1403 void MAC_RfFrontendSetup(void)
// 1404 {}
// 1405 #endif
// 1406 
// 1407 #ifdef DEBUG_TRACE
// 1408 static void PutChar(const char Tbyte)
// 1409 {
// 1410 	U0DBUF = Tbyte; 
// 1411 	while(UTX0IF == 0);   //·¢ËÍÍê³É±êÖ¾Î»
// 1412 	UTX0IF = 0;  
// 1413 }
// 1414 
// 1415 static void putsStr(const char *str)
// 1416 {
// 1417 	while(*str!='0')
// 1418 		PutChar(*str++);
// 1419 	//HalUARTWrite(0, (unsigned char*)str++, 1);
// 1420 }
// 1421 
// 1422 static char *mac_itoa(long n, int base)
// 1423  {
// 1424   	char *p;
// 1425  	int minus;
// 1426  	static char buf[16];
// 1427 
// 1428 //	puts_("enter _itoa\n");
// 1429 //	put_hex(n);
// 1430 
// 1431  	p = &buf[16];
// 1432  	*--p =  0;
// 1433  	if (n < 0) 
// 1434 	{
// 1435   		minus = 1;
// 1436   		n = -n;
// 1437  	}
// 1438  	else
// 1439   		minus = 0;
// 1440 
// 1441 
// 1442  	if (n == 0)
// 1443 	{
// 1444   		*--p = '0';
// 1445 	}
// 1446  	else
// 1447   		while (n > 0) 
// 1448 		{  
// 1449 	//		puts_("_itoa ");
// 1450    			*--p = "0123456789abcdef"[n % base];
// 1451 	//		putchar(*p);
// 1452    			n /= base;
// 1453   		}
// 1454 
// 1455  	if (minus)
// 1456   		*--p = '-';
// 1457 
// 1458  	return p;
// 1459 }
// 1460 
// 1461 
// 1462 
// 1463 int Printf(const char *fmt, ...)
// 1464 {
// 1465 	int i;
// 1466 	const char *s;
// 1467  	int d;
// 1468 	char buf[128];
// 1469 	char *p = buf;
// 1470 //	char buf[16];
// 1471 //	char *p = buf;
// 1472  	va_list ap;
// 1473 
// 1474     va_start(ap, fmt);
// 1475 	i = 16;
// 1476 
// 1477     while (*fmt) 
// 1478 	{
// 1479         if (*fmt != '%') 
// 1480 		{
// 1481             PutChar(*fmt++);
// 1482             continue;
// 1483         }
// 1484 		
// 1485 		switch(*++fmt)
// 1486 		{
// 1487             case 's':
// 1488                 s = va_arg(ap, const char *);
// 1489                 for ( ; *s; s++) 
// 1490 		 {
// 1491                    PutChar(*s);
// 1492                 }
// 1493                 break;
// 1494             case 'd':			
// 1495                 d = va_arg(ap, int);
// 1496 				//d>>=8;
// 1497                 p = mac_itoa(d, 10);
// 1498                 for (s = p; *s; s++) 
// 1499 				{
// 1500                     PutChar(*s);
// 1501                 }
// 1502 
// 1503 				break;
// 1504 
// 1505             case 'x':
// 1506 			case 'X':
// 1507                 d = va_arg(ap, int);
// 1508                 p = mac_itoa(d, 16);
// 1509                 for (s = p; *s; s++) 
// 1510 				{
// 1511                     PutChar(*s);
// 1512                 }
// 1513                 break;
// 1514              //Add other specifiers here...              
// 1515             default:  
// 1516                 putsStr(fmt);
// 1517                 break;
// 1518         } 
// 1519         fmt++;
// 1520     }
// 1521     va_end(ap);
// 1522 
// 1523     return 1;   /* Dummy return value */
// 1524 }
// 1525 #endif
// 1526 
// 1527 /**************************************************************************************************
// 1528 */
// C:\Users\freeman\Documents\work\NBK\Canon\Nbk600EX - RF\Components\hal\target\CC2530EB\hal_uart.c
//    1 /**************************************************************************************************
//    2   Filename:       _hal_uart.c
//    3   Revised:        $Date: 2009-06-12 09:16:43 -0700 (Fri, 12 Jun 2009) $
//    4   Revision:       $Revision: 20142 $
//    5 
//    6   Description: This file contains the interface to the H/W UART driver.
//    7 
//    8 
//    9   Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 
//   44 #include "hal_board_cfg.h"
//   45 #include "hal_defs.h"
//   46 #include "hal_types.h"
//   47 #include "hal_uart.h"
//   48 
//   49 /*********************************************************************
//   50  * MACROS
//   51  */
//   52 
//   53 /*********************************************************************
//   54  * TYPEDEFS
//   55  */
//   56 
//   57 /*********************************************************************
//   58  * CONSTANTS
//   59  */
//   60 
//   61 /*********************************************************************
//   62  * GLOBAL VARIABLES
//   63  */
//   64 
//   65 /*********************************************************************
//   66  * GLOBAL FUNCTIONS
//   67  */
//   68 
//   69 /*********************************************************************
//   70  * LOCAL VARIABLES
//   71  */
//   72 
//   73 /*********************************************************************
//   74  * LOCAL FUNCTIONS
//   75  */
//   76 
//   77 #if HAL_UART_DMA
//   78 #include "_hal_uart_dma.c"
//   79 #endif
//   80 #if HAL_UART_ISR
//   81 #include "_hal_uart_isr.c"
//   82 #endif
//   83 #if HAL_UART_USB
//   84 #include "_hal_uart_usb.c"
//   85 #endif
//   86 
//   87 /******************************************************************************
//   88  * @fn      HalUARTInit
//   89  *
//   90  * @brief   Initialize the UART
//   91  *
//   92  * @param   none
//   93  *
//   94  * @return  none
//   95  *****************************************************************************/
//   96 void HalUARTInit(void)
//   97 {
//   98 #if HAL_UART_DMA
//   99   HalUARTInitDMA();
//  100 #endif
//  101 #if HAL_UART_ISR
//  102   HalUARTInitISR();
//  103 #endif
//  104 #if HAL_UART_USB
//  105   HalUARTInitUSB();
//  106 #endif
//  107 }
//  108 
//  109 /******************************************************************************
//  110  * @fn      HalUARTOpen
//  111  *
//  112  * @brief   Open a port according tp the configuration specified by parameter.
//  113  *
//  114  * @param   port   - UART port
//  115  *          config - contains configuration information
//  116  *
//  117  * @return  Status of the function call
//  118  *****************************************************************************/
//  119 uint8 HalUARTOpen(uint8 port, halUARTCfg_t *config)
//  120 {
//  121   (void)port;
//  122   (void)config;
//  123 
//  124 #if (HAL_UART_DMA == 1)
//  125   if (port == HAL_UART_PORT_0)  HalUARTOpenDMA(config);
//  126 #endif
//  127 #if (HAL_UART_DMA == 2)
//  128   if (port == HAL_UART_PORT_1)  HalUARTOpenDMA(config);
//  129 #endif
//  130 #if (HAL_UART_ISR == 1)
//  131   if (port == HAL_UART_PORT_0)  HalUARTOpenISR(config);
//  132 #endif
//  133 #if (HAL_UART_ISR == 2)
//  134   if (port == HAL_UART_PORT_1)  HalUARTOpenISR(config);
//  135 #endif
//  136 #if (HAL_UART_USB)
//  137   HalUARTOpenUSB(config);
//  138 #endif
//  139   
//  140   return HAL_UART_SUCCESS;
//  141 }
//  142 
//  143 /*****************************************************************************
//  144  * @fn      HalUARTRead
//  145  *
//  146  * @brief   Read a buffer from the UART
//  147  *
//  148  * @param   port - USART module designation
//  149  *          buf  - valid data buffer at least 'len' bytes in size
//  150  *          len  - max length number of bytes to copy to 'buf'
//  151  *
//  152  * @return  length of buffer that was read
//  153  *****************************************************************************/
//  154 uint16 HalUARTRead(uint8 port, uint8 *buf, uint16 len)
//  155 {
//  156   (void)port;
//  157   (void)buf;
//  158   (void)len;
//  159 
//  160 #if (HAL_UART_DMA == 1)
//  161   if (port == HAL_UART_PORT_0)  return HalUARTReadDMA(buf, len);
//  162 #endif
//  163 #if (HAL_UART_DMA == 2)
//  164   if (port == HAL_UART_PORT_1)  return HalUARTReadDMA(buf, len);
//  165 #endif
//  166 #if (HAL_UART_ISR == 1)
//  167   if (port == HAL_UART_PORT_0)  return HalUARTReadISR(buf, len);
//  168 #endif
//  169 #if (HAL_UART_ISR == 2)
//  170   if (port == HAL_UART_PORT_1)  return HalUARTReadISR(buf, len);
//  171 #endif
//  172 
//  173 #if HAL_UART_USB
//  174   return HalUARTRx(buf, len);
//  175 #else
//  176   return 0;
//  177 #endif
//  178 }
//  179 
//  180 /******************************************************************************
//  181  * @fn      HalUARTWrite
//  182  *
//  183  * @brief   Write a buffer to the UART.
//  184  *
//  185  * @param   port - UART port
//  186  *          buf  - pointer to the buffer that will be written, not freed
//  187  *          len  - length of
//  188  *
//  189  * @return  length of the buffer that was sent
//  190  *****************************************************************************/
//  191 uint16 HalUARTWrite(uint8 port, uint8 *buf, uint16 len)
//  192 {
//  193   (void)port;
//  194   (void)buf;
//  195   (void)len;
//  196 
//  197 #if (HAL_UART_DMA == 1)
//  198   if (port == HAL_UART_PORT_0)  return HalUARTWriteDMA(buf, len);
//  199 #endif
//  200 #if (HAL_UART_DMA == 2)
//  201   if (port == HAL_UART_PORT_1)  return HalUARTWriteDMA(buf, len);
//  202 #endif
//  203 #if (HAL_UART_ISR == 1)
//  204   if (port == HAL_UART_PORT_0)  return HalUARTWriteISR(buf, len);
//  205 #endif
//  206 #if (HAL_UART_ISR == 2)
//  207   if (port == HAL_UART_PORT_1)  return HalUARTWriteISR(buf, len);
//  208 #endif
//  209 
//  210 #if HAL_UART_USB
//  211   HalUARTTx(buf, len);
//  212   return len;
//  213 #else
//  214   return 0;
//  215 #endif
//  216 }
//  217 
//  218 /******************************************************************************
//  219  * @fn      HalUARTSuspend
//  220  *
//  221  * @brief   Suspend UART hardware before entering PM mode 1, 2 or 3.
//  222  *
//  223  * @param   None
//  224  *
//  225  * @return  None
//  226  *****************************************************************************/
//  227 void HalUARTSuspend( void )
//  228 {
//  229 #if HAL_UART_DMA
//  230   HalUARTSuspendDMA();
//  231 #endif
//  232 #if HAL_UART_ISR
//  233   HalUARTSuspendISR();
//  234 #endif
//  235 }
//  236 
//  237 /******************************************************************************
//  238  * @fn      HalUARTResume
//  239  *
//  240  * @brief   Resume UART hardware after exiting PM mode 1, 2 or 3.
//  241  *
//  242  * @param   None
//  243  *
//  244  * @return  None
//  245  *****************************************************************************/
//  246 void HalUARTResume( void )
//  247 {
//  248 #if HAL_UART_DMA
//  249   HalUARTResumeDMA();
//  250 #endif
//  251 #if HAL_UART_ISR
//  252   HalUARTResumeISR();
//  253 #endif
//  254 }
//  255 
//  256 /***************************************************************************************************
//  257  * @fn      HalUARTPoll
//  258  *
//  259  * @brief   Poll the UART.
//  260  *
//  261  * @param   none
//  262  *
//  263  * @return  none
//  264  *****************************************************************************/
//  265 void HalUARTPoll(void)
//  266 {
//  267 #if HAL_UART_DMA
//  268   HalUARTPollDMA();
//  269 #endif
//  270 #if HAL_UART_ISR
//  271   HalUARTPollISR();
//  272 #endif
//  273 #if HAL_UART_USB
//  274   HalUARTPollUSB();
//  275 #endif
//  276 }
//  277 
//  278 /**************************************************************************************************
//  279  * @fn      Hal_UART_RxBufLen()
//  280  *
//  281  * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
//  282  *
//  283  * @param   port - UART port
//  284  *
//  285  * @return  length of current Rx Buffer
//  286  **************************************************************************************************/
//  287 uint16 Hal_UART_RxBufLen( uint8 port )
//  288 {
//  289   (void)port;
//  290 
//  291 #if (HAL_UART_DMA == 1)
//  292   if (port == HAL_UART_PORT_0)  return HalUARTRxAvailDMA();
//  293 #endif
//  294 #if (HAL_UART_DMA == 2)
//  295   if (port == HAL_UART_PORT_1)  return HalUARTRxAvailDMA();
//  296 #endif
//  297 #if (HAL_UART_ISR == 1)
//  298   if (port == HAL_UART_PORT_0)  return HalUARTRxAvailISR();
//  299 #endif
//  300 #if (HAL_UART_ISR == 2)
//  301   if (port == HAL_UART_PORT_1)  return HalUARTRxAvailISR();
//  302 #endif
//  303 #if HAL_UART_USB
//  304   return HalUARTRxAvailUSB();
//  305 #else
//  306   return 0;
//  307 #endif
//  308 }
//  309 
//  310 /******************************************************************************
//  311 ******************************************************************************/
// 
// 1 996 bytes in segment NEAR_CODE
//    27 bytes in segment RAM_CODE_FLASH
//    29 bytes in segment RAM_CODE_XDATA
//    26 bytes in segment SFR_AN
//    92 bytes in segment XDATA_I
//    92 bytes in segment XDATA_ID
//     8 bytes in segment XDATA_Z
// 
// 2 107 bytes of CODE  memory (+  8 bytes shared)
//     0 bytes of DATA  memory (+ 26 bytes shared)
//   121 bytes of XDATA memory (+  8 bytes shared)
//
//Errors: none
//Warnings: 11
